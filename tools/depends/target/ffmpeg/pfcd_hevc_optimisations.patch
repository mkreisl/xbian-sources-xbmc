From f79345f11918b94327a8a18cb2e13d20b7a0dde5 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 28 Apr 2015 16:18:40 +0100
Subject: [PATCH 01/77] Added display output

---
 ffmpeg.c | 150 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 150 insertions(+)

diff --git a/ffmpeg.c b/ffmpeg.c
index 1ba0a42..3daa2f4 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -22,6 +22,9 @@
  * @file
  * multimedia converter based on the FFmpeg libraries
  */
+ 
+#define RPI_DISPLAY
+//#define RPI_ZERO_COPY
 
 #include "config.h"
 #include <ctype.h>
@@ -68,6 +71,20 @@
 # include "libavfilter/buffersrc.h"
 # include "libavfilter/buffersink.h"
 
+#ifdef RPI_DISPLAY
+#include <bcm_host.h>
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/mmal_parameters_camera.h>
+#include <interface/mmal/mmal_buffer.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_connection.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#ifdef RPI_ZERO_COPY
+#include "libavcodec/rpi_qpu.h"
+#endif
+#endif
+
 #if HAVE_SYS_RESOURCE_H
 #include <sys/time.h>
 #include <sys/types.h>
@@ -158,6 +175,130 @@ static int restore_tty;
 static void free_input_threads(void);
 #endif
 
+#ifdef RPI_DISPLAY
+
+#define NUM_BUFFERS 4
+
+static MMAL_COMPONENT_T* rpi_display = NULL;
+static MMAL_POOL_T *rpi_pool = NULL;
+
+#ifdef RPI_ZERO_COPY
+static uint8_t *get_vc_handle(AVBufferRef *bref) {
+  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+  return (uint8_t *)p->vc_handle;
+}
+#endif
+
+static MMAL_POOL_T* display_alloc_pool(MMAL_PORT_T* port, size_t w, size_t h)
+{
+    MMAL_POOL_T* pool;
+    size_t i;
+    size_t size = (w*h*3)/2;
+#ifdef RPI_ZERO_COPY
+    mmal_port_parameter_set_boolean(port, MMAL_PARAMETER_ZERO_COPY, MMAL_TRUE); // Does this mark that the buffer contains a vc_handle?  Would have expected a vc_image?
+    pool = mmal_port_pool_create(port, NUM_BUFFERS, 0);
+    assert(pool);
+#else
+    pool = mmal_port_pool_create(port, NUM_BUFFERS, size);
+    
+    for (i = 0; i < NUM_BUFFERS; ++i)
+    {
+       MMAL_BUFFER_HEADER_T* buffer = pool->header[i];
+       void* bufPtr = buffer->data;
+       memset(bufPtr, i*30, w*h);
+       memset(bufPtr+w*h, 128, (w*h)/2);
+    }
+#endif
+    
+    return pool;
+}
+
+static void display_cb_input(MMAL_PORT_T *port,MMAL_BUFFER_HEADER_T *buffer) {
+  mmal_buffer_header_release(buffer);
+}
+
+static MMAL_COMPONENT_T* display_init(size_t x, size_t y, size_t w, size_t h)
+{
+    MMAL_COMPONENT_T* display; 
+    MMAL_DISPLAYREGION_T region =
+    {
+        {MMAL_PARAMETER_DISPLAYREGION, sizeof(region)},
+        .set = MMAL_DISPLAY_SET_LAYER | MMAL_DISPLAY_SET_FULLSCREEN | MMAL_DISPLAY_SET_DEST_RECT,
+        .layer = 2,
+        .fullscreen = 0,
+        .dest_rect = {x, y, w, h}
+    };
+    bcm_host_init();  // TODO is this needed?
+    mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER, &display);
+    assert(display);
+    
+    mmal_port_parameter_set(display->input[0], &region.hdr);
+    
+    MMAL_ES_FORMAT_T* format = display->input[0]->format;
+    format->encoding = MMAL_ENCODING_I420;
+    format->es->video.width = w;
+    format->es->video.height = h;
+    format->es->video.crop.x = 0;
+    format->es->video.crop.y = 0;
+    format->es->video.crop.width = w;
+    format->es->video.crop.height = h;
+    mmal_port_format_commit(display->input[0]);
+    
+    mmal_component_enable(display);
+    
+    rpi_pool = display_alloc_pool(display->input[0], w, h);
+    
+    mmal_port_enable(display->input[0],display_cb_input);
+    mmal_port_enable(display->control,display_cb_input);
+    
+    printf("Allocated display %d %d\n",w,h);
+    
+    return display;
+}
+
+static void display_frame(MMAL_COMPONENT_T* display,AVFrame* fr) 
+{
+    int w = fr->width;
+    int h = fr->height;
+    if (!display || !rpi_pool)
+        return;
+    MMAL_BUFFER_HEADER_T* buf = mmal_queue_get(rpi_pool->queue);
+    if (!buf) {
+      // Running too fast so drop the frame
+      return;
+    }
+    assert(buf);
+    buf->cmd = 0;
+    buf->length = (w * h * 3)/2;
+    buf->offset = 0; // Offset to valid data
+    buf->flags = 0;
+#ifdef RPI_ZERO_COPY
+    buf->data = get_vc_handle(fr->buf[0]);
+    buf->alloc_size = (w*h*3)/2;
+#else
+    mmal_buffer_header_mem_lock(buf);
+    memcpy(buf->data, fr->data[0], w * h);
+    memcpy(buf->data+w*h, fr->data[1], w * h / 4);
+    memcpy(buf->data+w*h*5/4, fr->data[2], w * h / 4);
+    mmal_buffer_header_mem_unlock(buf);
+#endif
+    
+    mmal_port_send_buffer(display->input[0], buf);  // I assume this will automatically get released
+}
+
+static void display_exit(MMAL_COMPONENT_T* display)
+{
+    if (display) {
+        mmal_component_destroy(display);
+    }
+    if (rpi_pool) {
+        mmal_port_pool_destroy(display->input[0], rpi_pool);
+    }
+}
+
+#endif
+
+
 /* sub2video hack:
    Convert subtitles to video with alpha to insert them in filter graphs.
    This is a temporary solution until libavfilter gets real subtitles support.
@@ -534,6 +675,10 @@ static void ffmpeg_cleanup(int ret)
         av_log(NULL, AV_LOG_INFO, "Conversion failed!\n");
     }
     term_exit();
+    
+#ifdef RPI_DISPLAY
+    display_exit(rpi_display);
+#endif
 }
 
 void remove_avoptions(AVDictionary **a, AVDictionary *b)
@@ -896,6 +1041,11 @@ static void do_video_out(AVFormatContext *s,
     int frame_size = 0;
     InputStream *ist = NULL;
     AVFilterContext *filter = ost->filter->filter;
+#ifdef RPI_DISPLAY
+    if (!rpi_display)
+        rpi_display = display_init(0,0,next_picture->width,next_picture->height);
+     display_frame(rpi_display,next_picture);
+#endif
 
     if (ost->source_index >= 0)
         ist = input_streams[ost->source_index];
-- 
1.9.1


From 3ad348d4628da7c57ba7e8bcfdd1c5ec8e192412 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 29 Apr 2015 16:49:43 +0100
Subject: [PATCH 02/77] Split transform and intra prediction into commands

---
 libavcodec/hevc.c       | 119 +++++++++++++++++++++++++++++++++++++++++++++++-
 libavcodec/hevc.h       |  58 +++++++++++++++++++++++
 libavcodec/hevc_cabac.c |  15 ++++++
 3 files changed, 191 insertions(+), 1 deletion(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index f950349..a0e37eb 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -895,6 +895,25 @@ static int hls_cross_component_pred(HEVCContext *s, int idx) {
     return 0;
 }
 
+#ifdef RPI
+static void rpi_intra_pred(HEVCContext *s, int log2_trafo_size, int x0, int y0, int c_idx)
+{
+    if (s->enable_rpi) {
+        HEVCLocalContext *lc = s->HEVClc;
+        HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
+        cmd->type = RPI_PRED_INTRA;
+        cmd->size = log2_trafo_size;
+        cmd->c_idx = c_idx;
+        cmd->x = x0;
+        cmd->y = y0;
+        cmd->na = (lc->na.cand_bottom_left<<4) + (lc->na.cand_left<<3) + (lc->na.cand_up_left<<2) + (lc->na.cand_up<<1) + lc->na.cand_up_right;
+        cmd->mode = c_idx ? lc->tu.intra_pred_mode_c :  lc->tu.intra_pred_mode;
+    } else {
+        s->hpc.intra_pred[log2_trafo_size - 2](s, x0, y0, c_idx);
+    }
+}
+#endif
+
 static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                               int xBase, int yBase, int cb_xBase, int cb_yBase,
                               int log2_cb_size, int log2_trafo_size,
@@ -907,8 +926,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
     if (lc->cu.pred_mode == MODE_INTRA) {
         int trafo_size = 1 << log2_trafo_size;
         ff_hevc_set_neighbour_available(s, x0, y0, trafo_size, trafo_size);
-
+#ifdef RPI
+        rpi_intra_pred(s, log2_trafo_size, x0, y0, 0);
+#else
         s->hpc.intra_pred[log2_trafo_size - 2](s, x0, y0, 0);
+#endif
     }
 
     if (cbf_luma || cbf_cb[0] || cbf_cr[0] ||
@@ -994,7 +1016,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
             for (i = 0; i < (s->sps->chroma_format_idc == 2 ? 2 : 1); i++) {
                 if (lc->cu.pred_mode == MODE_INTRA) {
                     ff_hevc_set_neighbour_available(s, x0, y0 + (i << log2_trafo_size_c), trafo_size_h, trafo_size_v);
+#ifdef RPI
+                    rpi_intra_pred(s, log2_trafo_size_c, x0, y0 + (i << log2_trafo_size_c), 1);
+#else
                     s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (i << log2_trafo_size_c), 1);
+#endif
                 }
                 if (cbf_cb[i])
                     ff_hevc_hls_residual_coding(s, x0, y0 + (i << log2_trafo_size_c),
@@ -1023,7 +1049,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
             for (i = 0; i < (s->sps->chroma_format_idc == 2 ? 2 : 1); i++) {
                 if (lc->cu.pred_mode == MODE_INTRA) {
                     ff_hevc_set_neighbour_available(s, x0, y0 + (i << log2_trafo_size_c), trafo_size_h, trafo_size_v);
+#ifdef RPI
+                    rpi_intra_pred(s, log2_trafo_size_c, x0, y0 + (i << log2_trafo_size_c), 2);
+#else
                     s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (i << log2_trafo_size_c), 2);
+#endif
                 }
                 if (cbf_cr[i])
                     ff_hevc_hls_residual_coding(s, x0, y0 + (i << log2_trafo_size_c),
@@ -1052,7 +1082,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                 if (lc->cu.pred_mode == MODE_INTRA) {
                     ff_hevc_set_neighbour_available(s, xBase, yBase + (i << log2_trafo_size),
                                                     trafo_size_h, trafo_size_v);
+#ifdef RPI
+                    rpi_intra_pred(s, log2_trafo_size, xBase, yBase + (i << log2_trafo_size), 1);
+#else
                     s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (i << log2_trafo_size), 1);
+#endif
                 }
                 if (cbf_cb[i])
                     ff_hevc_hls_residual_coding(s, xBase, yBase + (i << log2_trafo_size),
@@ -1062,7 +1096,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                 if (lc->cu.pred_mode == MODE_INTRA) {
                     ff_hevc_set_neighbour_available(s, xBase, yBase + (i << log2_trafo_size),
                                                 trafo_size_h, trafo_size_v);
+#ifdef RPI
+                    rpi_intra_pred(s, log2_trafo_size, xBase, yBase + (i << log2_trafo_size), 2);
+#else
                     s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (i << log2_trafo_size), 2);
+#endif
                 }
                 if (cbf_cr[i])
                     ff_hevc_hls_residual_coding(s, xBase, yBase + (i << log2_trafo_size),
@@ -1074,26 +1112,46 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
             int trafo_size_h = 1 << (log2_trafo_size_c + s->sps->hshift[1]);
             int trafo_size_v = 1 << (log2_trafo_size_c + s->sps->vshift[1]);
             ff_hevc_set_neighbour_available(s, x0, y0, trafo_size_h, trafo_size_v);
+#ifdef RPI
+            rpi_intra_pred(s, log2_trafo_size_c, x0, y0, 1);
+            rpi_intra_pred(s, log2_trafo_size_c, x0, y0, 2);
+#else
             s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0, 1);
             s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0, 2);
+#endif
             if (s->sps->chroma_format_idc == 2) {
                 ff_hevc_set_neighbour_available(s, x0, y0 + (1 << log2_trafo_size_c),
                                                 trafo_size_h, trafo_size_v);
+#ifdef RPI
+                rpi_intra_pred(s, log2_trafo_size_c, x0, y0 + (1 << log2_trafo_size_c), 1);
+                rpi_intra_pred(s, log2_trafo_size_c, x0, y0 + (1 << log2_trafo_size_c), 2);
+#else
                 s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (1 << log2_trafo_size_c), 1);
                 s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (1 << log2_trafo_size_c), 2);
+#endif
             }
         } else if (blk_idx == 3) {
             int trafo_size_h = 1 << (log2_trafo_size + 1);
             int trafo_size_v = 1 << (log2_trafo_size + s->sps->vshift[1]);
             ff_hevc_set_neighbour_available(s, xBase, yBase,
                                             trafo_size_h, trafo_size_v);
+#ifdef RPI
+            rpi_intra_pred(s, log2_trafo_size, xBase, yBase, 1);
+            rpi_intra_pred(s, log2_trafo_size, xBase, yBase, 2);
+#else
             s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase, 1);
             s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase, 2);
+#endif
             if (s->sps->chroma_format_idc == 2) {
                 ff_hevc_set_neighbour_available(s, xBase, yBase + (1 << (log2_trafo_size)),
                                                 trafo_size_h, trafo_size_v);
+#ifdef RPI
+                rpi_intra_pred(s, log2_trafo_size, xBase, yBase + (1 << (log2_trafo_size)), 1);
+                rpi_intra_pred(s, log2_trafo_size, xBase, yBase + (1 << (log2_trafo_size)), 2);
+#else
                 s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (1 << (log2_trafo_size)), 1);
                 s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (1 << (log2_trafo_size)), 2);
+#endif
             }
         }
     }
@@ -2268,6 +2326,31 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
     lc->ctb_up_left_flag = ((x_ctb > 0) && (y_ctb > 0)  && (ctb_addr_in_slice-1 >= s->sps->ctb_width) && (s->pps->tile_id[ctb_addr_ts] == s->pps->tile_id[s->pps->ctb_addr_rs_to_ts[ctb_addr_rs-1 - s->sps->ctb_width]]));
 }
 
+#ifdef RPI
+static void rpi_execute_pred_cmds(HEVCContext *s)
+{
+  int i;
+  HEVCPredCmd *cmd = s->univ_pred_cmds;
+  HEVCLocalContext *lc = s->HEVClc;
+
+  for(i = s->num_pred_cmds; i > 0; i--, cmd++) {
+      if (cmd->type == RPI_PRED_INTRA) {
+          lc->tu.intra_pred_mode_c = lc->tu.intra_pred_mode = cmd->mode;
+          lc->na.cand_bottom_left  = (cmd->na >> 4) & 1;
+          lc->na.cand_left         = (cmd->na >> 3) & 1;
+          lc->na.cand_up_left      = (cmd->na >> 2) & 1;
+          lc->na.cand_up           = (cmd->na >> 1) & 1;
+          lc->na.cand_up_right     = (cmd->na >> 0) & 1;
+          s->hpc.intra_pred[cmd->size - 2](s, cmd->x, cmd->y, cmd->c_idx);
+      } else {
+          s->hevcdsp.transform_add[cmd->size-2](cmd->dst, cmd->buf, cmd->stride);
+      }
+  }
+  s->num_pred_cmds = 0;
+  s->num_coeffs = 0;
+}
+#endif
+
 static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 {
     HEVCContext *s  = avctxt->priv_data;
@@ -2277,6 +2360,10 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     int y_ctb       = 0;
     int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
 
+#ifdef RPI
+    s->enable_rpi = 1; // TODO this should depend on cross component and frame width etc.
+#endif
+
     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
         av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n");
         return AVERROR_INVALIDDATA;
@@ -2306,6 +2393,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
 
         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);
+#ifdef RPI
+        rpi_execute_pred_cmds(s);
+#endif
         if (more_data < 0) {
             s->tab_slice_address[ctb_addr_rs] = -1;
             return more_data;
@@ -2351,6 +2441,10 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
     s = s1->sList[self_id];
     lc = s->HEVClc;
 
+#ifdef RPI
+    s->enable_rpi = 0;
+#endif
+
     if(ctb_row) {
         ret = init_get_bits8(&lc->gb, s->data + s->sh.offset[ctb_row - 1], s->sh.size[ctb_row - 1]);
 
@@ -3197,6 +3291,13 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
 
     av_freep(&s->cabac_state);
 
+#ifdef RPI
+    av_freep(&s->unif_mv_cmds);
+    av_freep(&s->unif_xfm_cmds);
+    av_freep(&s->univ_pred_cmds);
+    av_freep(&s->coeffs_buf);
+#endif
+
     for (i = 0; i < 3; i++) {
         av_freep(&s->sao_pixel_buffer_h[i]);
         av_freep(&s->sao_pixel_buffer_v[i]);
@@ -3254,6 +3355,22 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     s->HEVClcList[0] = s->HEVClc;
     s->sList[0] = s;
 
+#ifdef RPI
+    s->unif_mv_cmds = av_mallocz(sizeof(HEVCMvCmd)*RPI_MAX_MV_CMDS);
+    if (!s->unif_mv_cmds)
+        goto fail;
+    s->unif_xfm_cmds = av_mallocz(sizeof(HEVCXfmCmd)*RPI_MAX_XFM_CMDS);
+    if (!s->unif_xfm_cmds)
+        goto fail;
+    s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
+    if (!s->univ_pred_cmds)
+        goto fail;
+    s->coeffs_buf = av_mallocz(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16);
+    if (!s->coeffs_buf)
+        goto fail;
+    s->enable_rpi = 0;
+#endif
+
     s->cabac_state = av_malloc(HEVC_CONTEXTS);
     if (!s->cabac_state)
         goto fail;
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index eecccb7..7c58834 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -36,6 +36,9 @@
 #include "thread.h"
 #include "videodsp.h"
 
+// define RPI to split the CABAC/prediction/transform into separate stages
+#define RPI
+
 #define MAX_DPB_SIZE 16 // A.4.1
 #define MAX_REFS 16
 
@@ -787,6 +790,49 @@ typedef struct HEVCLocalContext {
     int boundary_flags;
 } HEVCLocalContext;
 
+#ifdef RPI
+
+// RPI_MAX_WIDTH is maximum width in pixels supported by the accelerated code
+#define RPI_MAX_WIDTH 2048
+
+// Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane
+#define RPI_MAX_MV_CMDS   (16*3*(RPI_MAX_WIDTH/4))
+#define RPI_MAX_XFM_CMDS  (16*3*(RPI_MAX_WIDTH/4))
+// Each block can have an intra prediction and a transform_add command
+#define RPI_MAX_PRED_CMDS (2*16*3*(RPI_MAX_WIDTH/4))
+
+// Command for inter prediction
+typedef struct HEVCMvCmd {
+} HEVCMvCmd;
+
+// Command for transform to process a block of coefficients
+typedef struct HEVCXfmCmd {
+} HEVCXfmCmd;
+
+// Command for intra prediction and transform_add of predictions to coefficients
+#define RPI_PRED_TRANSFORM_ADD 0
+#define RPI_PRED_INTRA 1
+typedef struct HEVCPredCmd {
+    uint8_t size;
+    uint8_t type;
+    uint8_t na;
+    uint8_t c_idx;
+    union {
+        uint8_t *dst; // RPI_PRED_TRANSFORM_ADD
+        uint32_t x;   // RPI_PRED_INTRA
+    };
+    union {
+        int16_t *buf; // RPI_PRED_TRANSFORM_ADD
+        uint32_t y;   // RPI_PRED_INTRA
+    };
+    union {
+        enum IntraPredMode mode; // RPI_PRED_TRANSFORM_ADD
+        uint32_t stride;         // RPI_PRED_INTRA
+    };
+} HEVCPredCmd;
+
+#endif
+
 typedef struct HEVCContext {
     const AVClass *c;  // needed by private avoptions
     AVCodecContext *avctx;
@@ -802,6 +848,18 @@ typedef struct HEVCContext {
     int                 width;
     int                 height;
 
+#ifdef RPI
+    int enable_rpi;
+    HEVCMvCmd *unif_mv_cmds;
+    HEVCXfmCmd *unif_xfm_cmds;
+    HEVCPredCmd *univ_pred_cmds;
+    int16_t *coeffs_buf;
+    int num_mv_cmds;
+    int num_xfm_cmds;
+    int num_pred_cmds;
+    int num_coeffs;
+#endif
+
     uint8_t *cabac_state;
 
     /** 1 if the independent slice segment header was successfully parsed */
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index cb369eb..df2f5a3 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1558,6 +1558,21 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
             coeffs[i] = coeffs[i] + ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
         }
     }
+#ifdef RPI
+    if (s->enable_rpi) {
+        int16_t *c = s->coeffs_buf + s->num_coeffs;
+        int n = trafo_size * trafo_size;
+        HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
+        memcpy(c, coeffs, n * sizeof(int16_t));  // TODO change pointer earlier and we can avoid this copy
+        s->num_coeffs += n;
+        cmd->type = RPI_PRED_TRANSFORM_ADD;
+        cmd->size = log2_trafo_size;
+        cmd->buf = c;
+        cmd->dst = dst;
+        cmd->stride = stride;
+        return;
+    }
+#endif
     s->hevcdsp.transform_add[log2_trafo_size-2](dst, coeffs, stride);
 }
 
-- 
1.9.1


From 45876129a0d7e9d477b71116380ce59e5b540099 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 30 Apr 2015 15:23:22 +0100
Subject: [PATCH 03/77] Added simple VPU test code

---
 libavcodec/Makefile             |    7 +
 libavcodec/hevc.c               |   33 +-
 libavcodec/rpi_hevc_transform.h |  212 ++++++
 libavcodec/rpi_hevc_transform.s |  149 +++++
 libavcodec/rpi_mailbox.c        |  293 ++++++++
 libavcodec/rpi_mailbox.h        |   20 +
 libavcodec/rpi_qpu.c            |  647 ++++++++++++++++++
 libavcodec/rpi_qpu.h            |   45 ++
 libavcodec/rpi_shader.c         |  818 ++++++++++++++++++++++
 libavcodec/rpi_shader.h         |   20 +
 libavcodec/rpi_shader.qasm      | 1413 +++++++++++++++++++++++++++++++++++++++
 libavcodec/rpi_user_vcsm.h      |  426 ++++++++++++
 12 files changed, 4082 insertions(+), 1 deletion(-)
 create mode 100644 libavcodec/rpi_hevc_transform.h
 create mode 100644 libavcodec/rpi_hevc_transform.s
 create mode 100644 libavcodec/rpi_mailbox.c
 create mode 100644 libavcodec/rpi_mailbox.h
 create mode 100644 libavcodec/rpi_qpu.c
 create mode 100644 libavcodec/rpi_qpu.h
 create mode 100644 libavcodec/rpi_shader.c
 create mode 100644 libavcodec/rpi_shader.h
 create mode 100644 libavcodec/rpi_shader.qasm
 create mode 100644 libavcodec/rpi_user_vcsm.h

diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 00090bf..412acdf 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -4,6 +4,10 @@ NAME = avcodec
 
 HEADERS = avcodec.h                                                     \
           avfft.h                                                       \
+          rpi_qpu.h                                                     \
+          rpi_shader.h                                                  \
+          rpi_mailbox.h                                                 \
+          rpi_hevc_transform.h                                          \
           dv_profile.h                                                  \
           dxva2.h                                                       \
           old_codec_ids.h                                               \
@@ -33,6 +37,9 @@ OBJS = allcodecs.o                                                      \
        resample.o                                                       \
        resample2.o                                                      \
        utils.o                                                          \
+       rpi_qpu.o                                                        \
+       rpi_shader.o                                                     \
+       rpi_mailbox.o                                                    \
        vorbis_parser.o                                                  \
        xiph.o                                                           \
 
diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index a0e37eb..1cd262d 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -39,6 +39,10 @@
 #include "golomb.h"
 #include "hevc.h"
 
+#ifdef RPI
+#include "rpi_qpu.h"
+#endif
+
 const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
 
 /**
@@ -2394,7 +2398,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 
         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);
 #ifdef RPI
-        rpi_execute_pred_cmds(s);
+        if (x_ctb + ctb_size >= s->sps->width) {
+            rpi_execute_pred_cmds(s);
+        }
 #endif
         if (more_data < 0) {
             s->tab_slice_address[ctb_addr_rs] = -1;
@@ -3369,6 +3375,31 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     if (!s->coeffs_buf)
         goto fail;
     s->enable_rpi = 0;
+    
+    // A little test program
+    {
+      GPU_MEM_PTR_T p;
+      int err = gpu_malloc_cached(16, &p);
+      short *q = (short *)p.arm;
+      int i;
+      int r;
+      printf("Allocated memory %d ARM 0x%x, VC 0x%x, Code 0x%x\n",err,(int)p.arm,p.vc,(int)vpu_get_fn());
+      printf("Allocated memory %d ARM 0x%x, VC 0x%x\n",err,(int)p.arm,p.vc);
+      printf("Preparing data %p\n",q);
+      for(i=0;i<16;i++)
+        q[i] = i;
+      printf("Flush cache\n");
+      gpu_cache_flush(&p);
+      printf("Executing code\n");
+      r = vpu_execute_code( vpu_get_fn(), p.vc, 0, 0, 0, 0, 0);
+      printf("Return value %d (",r);
+      for(i=0;i<16;i++)
+        printf("%d ",q[i]);
+      printf(")\n");
+      gpu_free(&p);
+      goto fail; // Early out
+    }
+    
 #endif
 
     s->cabac_state = av_malloc(HEVC_CONTEXTS);
diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
new file mode 100644
index 0000000..85a9102
--- /dev/null
+++ b/libavcodec/rpi_hevc_transform.h
@@ -0,0 +1,212 @@
+unsigned char rpi_hevc_transform [] = {
+169,
+3,
+3,
+232,
+128,
+0,
+0,
+0,
+20,
+248,
+0,
+136,
+0,
+0,
+192,
+248,
+0,
+0,
+0,
+96,
+3,
+232,
+32,
+0,
+0,
+0,
+7,
+232,
+0,
+2,
+0,
+0,
+8,
+232,
+0,
+4,
+0,
+0,
+12,
+248,
+0,
+128,
+0,
+0,
+192,
+8,
+4,
+0,
+4,
+232,
+64,
+0,
+0,
+0,
+5,
+232,
+0,
+0,
+8,
+0,
+128,
+69,
+113,
+66,
+12,
+248,
+0,
+128,
+0,
+0,
+192,
+8,
+4,
+0,
+128,
+69,
+113,
+70,
+128,
+144,
+39,
+0,
+4,
+255,
+48,
+192,
+128,
+3,
+32,
+8,
+16,
+0,
+76,
+254,
+48,
+192,
+9,
+4,
+32,
+8,
+0,
+0,
+4,
+254,
+0,
+144,
+128,
+2,
+0,
+248,
+62,
+0,
+128,
+144,
+22,
+0,
+4,
+255,
+48,
+192,
+128,
+3,
+32,
+8,
+16,
+0,
+76,
+254,
+48,
+192,
+9,
+4,
+32,
+8,
+0,
+0,
+140,
+248,
+44,
+0,
+0,
+0,
+32,
+48,
+4,
+0,
+128,
+69,
+113,
+66,
+242,
+140,
+211,
+192,
+41,
+3,
+68,
+192,
+80,
+7,
+164,
+255,
+36,
+220,
+96,
+2,
+0,
+248,
+62,
+0,
+3,
+255,
+55,
+208,
+120,
+3,
+224,
+3,
+190,
+11,
+16,
+139,
+246,
+83,
+0,
+103,
+90,
+0,
+8,
+240,
+0,
+128,
+128,
+3,
+0,
+247,
+32,
+128,
+10,
+4,
+136,
+240,
+32,
+0,
+128,
+3,
+112,
+96,
+90,
+0,
+};
diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
new file mode 100644
index 0000000..74b7d07
--- /dev/null
+++ b/libavcodec/rpi_hevc_transform.s
@@ -0,0 +1,149 @@
+# ******************************************************************************
+# Argon Design Ltd.
+# (c) Copyright 2015 Argon Design Ltd. All rights reserved.
+#
+# Module : HEVC
+# Author : Peter de Rivaz
+# ******************************************************************************
+
+# HEVC VPU Transform
+#
+# Transform matrix can be thought of as
+#   output row vector = input row vector * transMatrix2
+#
+# The even rows of the matrix are symmetric
+# The odd rows of the matrix are antisymmetric
+#
+# So only need to compute the first half of the results, then can compute the remainder with a butterfly
+#
+# EXAMPLE
+#   (a b c d) (1 2  2  1)
+#             (3 4 -4 -3)
+#             (5 6  6  5)
+#             (7 8 -8 -7)
+#
+#  x=(a c)(1 2) = 1a+5c 2a+6c
+#         (5 6)
+#
+#  y=(b d)(3 4) = 3b+7d 4b+8d
+#         (7 8)
+#
+#  u=x+y = 1a+5c+3b+7d 2a+4b+6c+8d
+#  v=x-y = 1a+5c-3b-7d 2a+6c-4b-8d
+#  
+#  Final results are (u , v[::-1])
+#
+#
+#  For 32x1 input, load even rows into HX(0++,0), odd rows into HX(16++,0)
+#  Apply the even matrix first and stop before rounding
+#  Then apply the odd matrix in a full manner:
+#
+#   First step is to compute partial products with the first input (16 cycles)        
+#   1a 3b 5c 7d   16x1 input coefficients produce 16x16 output                      
+#   2a 4b 6c 8d
+#   2a -4b 6c -8d
+#   1a -3b 5c -7d
+#
+#   Second step is to sum partial products into final position (8 cycles)
+#   1a+3b+5c+7d
+#   2a+4b+6c+8d
+#   2a-4b+6c-8d
+#   1a-3b+5c-7d
+#
+#   Then can apply butterfly to combine even results and odd results + rounding to produce 16 rows of output at a time (need to save in transposed format)
+#
+#   For 16x16 no butterfly is required and can store final results in original location  (Could do 2 16x16s in parallel to make use of the trick - saves on the adds)
+#
+#   For 8x8 we could compute two in parallel.
+#
+#
+
+test_add:
+  vldh HX(0,0),(r0)
+  vadd HX(0,0),HX(0,0),10
+  vsth HX(0,0),(r0)
+  mov r0,7 # return value
+  b lr
+  
+# Columns are transformed first
+#
+# Store top left half of transMatrix2 in 
+# Store bottom left half of transMatrix2 in HX(32,32)
+#
+# For 16x16
+# HX(0:15,0) contains input data before transform
+# HY(0:15,0) contains 32bit output data after transform
+# HX(32,0) contains even rows of left half of transMatrix2
+# HX(32,32) contains odd rows of left half of transMatrix2
+# HY(48,0) contains partial products ready for summing
+#
+
+  
+# hevc_trans_16x16(short *transMatrix2, short *coeffs, int num)
+# transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory)
+# coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
+# num: number of 16x16 transforms to be done
+#
+hevc_trans_16x16:
+  push r6-r15, lr # TODO cut down number of used registers
+  
+  mov r3, 2*32*2 # Twice Stride of transMatrix2 in bytes
+  vld HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
+  # Now use r0 to describe which matrix we are working on.
+  # Allows us to prefetch the next block of coefficients for efficiency.
+  mov r0,0 # This describes the location where we read our coefficients from
+  mov r3,16*2 # Stride of coefficients in bytes
+  mov r7,16*16*2 # Total block size
+  mov r8,64*16 # Value used to swap from current to next VRF location
+  vldh HX(0++,0)+r0,(r1 += r3) REP 16 
+  mov r4,64 # Constant used for rounding first pass
+  mov r5,1<<19 # Constant used for rounding second pass
+  
+  # At start of block r0,r1 point to the current block (that has already been loaded)
+block_loop:
+  eor r0,r8
+  add r1,r7
+  # Prefetch the next block
+  vldh HX(0++,0)+r0,(r1 += r3) REP 16 
+  eor r0,r8
+  sub r1,r7
+  
+  # Transform the current block
+  bl col_trans_16
+  vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
+  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
+  vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
+  vmov VX(0,0++), HX(0++,32) REP 16          # For simplicity transpose this back to the original position
+  
+  bl col_trans_16
+  vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
+  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
+  vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
+  
+  # Save results - note there has been a transposition during the processing so we save columns
+  vsth VX(0,32++)+r0, (r1 += r3) REP 16 
+  
+  # Move onto next block
+  eor r0,r8
+  add r1,r7
+
+  addcmpbgt r2,-1,0,block_loop
+  pop r6-r15, pc
+  
+# r1,r2,r3 r7,r8 should be preserved
+# HX(0++,0)+r0 is the block to be transformed
+# HX(32++,0) is the 16x16 matrix of transform coefficients
+# Use HY(48,0) for intermediate results
+# r0 can be used, but should be returned to its original value at the end
+col_trans_16:
+  add r4,r0,16 # Final value for this loop
+col_trans_16_loop:
+  # First compute partial products for a single column
+  vmul32s VY(48,0++), VX(0,0)+r0, VX(32,0++) REP 16
+  # Then sum up the results and place back 
+  vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
+  addcmpblt r0,1,r4,col_trans_16_loop
+  sub r0,16  # but r0 back to its original value
+  b lr
+  
+
diff --git a/libavcodec/rpi_mailbox.c b/libavcodec/rpi_mailbox.c
new file mode 100644
index 0000000..536896f
--- /dev/null
+++ b/libavcodec/rpi_mailbox.c
@@ -0,0 +1,293 @@
+/*
+Copyright (c) 2012, Broadcom Europe Ltd.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <assert.h>
+#include <stdint.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <linux/ioctl.h>
+
+#define MAJOR_NUM 100
+#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
+#define DEVICE_FILE_NAME "/dev/char_dev"
+
+#include "rpi_mailbox.h"
+
+#define PAGE_SIZE (4*1024)
+
+// Shared memory will not be cached in ARM cache
+void *mapmem_shared(unsigned base, unsigned size)
+{
+   int mem_fd;
+   unsigned offset = base % PAGE_SIZE;
+   base = base - offset;
+   /* open /dev/mem */
+   if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
+      printf("can't open /dev/mem\nThis program should be run as root. Try prefixing command with: sudo\n");
+      return NULL;
+   }
+   void *mem = mmap(
+      0,
+      size,
+      PROT_READ|PROT_WRITE,
+      MAP_SHARED/*|MAP_FIXED*/,
+      mem_fd,
+      base);
+#ifdef DEBUG
+   printf("base=0x%x, mem=%p\n", base, mem);
+#endif
+   if (mem == MAP_FAILED) {
+      printf("mmap error %d\n", (int)mem);
+      return NULL;
+   }
+   close(mem_fd);
+   return (char *)mem + offset;
+}
+
+// Unshared memory will be faster as lives in ARM cache, but requires cache flushing
+void *mapmem_private(unsigned base, unsigned size)
+{
+   int mem_fd;
+   unsigned offset = base % PAGE_SIZE;
+   base = base - offset;
+   /* open /dev/mem */
+   if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
+      printf("can't open /dev/mem\nThis program should be run as root. Try prefixing command with: sudo\n");
+      return NULL;
+   }
+   void *mem = mmap(
+      0,
+      size,
+      PROT_READ|PROT_WRITE,
+      MAP_PRIVATE/*|MAP_FIXED*/,
+      mem_fd,
+      base);
+#ifdef DEBUG
+   printf("base=0x%x, mem=%p\n", base, mem);
+#endif
+   if (mem == MAP_FAILED) {
+      printf("mmap error %d\n", (int)mem);
+      return NULL;
+   }
+   close(mem_fd);
+   return (char *)mem + offset;
+}
+
+void unmapmem(void *addr, unsigned size)
+{
+   int s = munmap(addr, size);
+   if (s != 0) {
+      printf("munmap error %d\n", s);
+      exit (-1);
+   }
+}
+
+/*
+ * use ioctl to send mbox property message
+ */
+
+static int mbox_property(int file_desc, void *buf)
+{
+   int ret_val = ioctl(file_desc, IOCTL_MBOX_PROPERTY, buf);
+
+   if (ret_val < 0) {
+      printf("ioctl_set_msg failed:%d\n", ret_val);
+   }
+
+#ifdef DEBUG
+   unsigned *p = buf; int i; unsigned size = *(unsigned *)buf;
+   for (i=0; i<size/4; i++)
+      printf("%04x: 0x%08x\n", i*sizeof *p, p[i]);
+#endif
+   return ret_val;
+}
+
+unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000c; // (the tag id)
+   p[i++] = 12; // (size of the buffer)
+   p[i++] = 12; // (size of the data)
+   p[i++] = size; // (num bytes? or pages?)
+   p[i++] = align; // (alignment)
+   p[i++] = flags; // (MEM_FLAG_L1_NONALLOCATING)
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned mem_free(int file_desc, unsigned handle)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000f; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = handle;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned mem_lock(int file_desc, unsigned handle)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000d; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = handle;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned mem_unlock(int file_desc, unsigned handle)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000e; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = handle;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x30010; // (the tag id)
+   p[i++] = 28; // (size of the buffer)
+   p[i++] = 28; // (size of the data)
+   p[i++] = code;
+   p[i++] = r0;
+   p[i++] = r1;
+   p[i++] = r2;
+   p[i++] = r3;
+   p[i++] = r4;
+   p[i++] = r5;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned qpu_enable(int file_desc, unsigned enable)
+{
+   int i=0;
+   unsigned p[32];
+
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x30012; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = enable;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout) {
+   int i=0;
+   unsigned p[32];
+
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+   p[i++] = 0x30011; // (the tag id)
+   p[i++] = 16; // (size of the buffer)
+   p[i++] = 16; // (size of the data)
+   p[i++] = num_qpus;
+   p[i++] = control;
+   p[i++] = noflush;
+   p[i++] = timeout; // ms
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+int mbox_open() {
+   int file_desc;
+
+   // open a char device file used for communicating with kernel mbox driver
+   file_desc = open(DEVICE_FILE_NAME, 0);
+   if (file_desc < 0) {
+      printf("Can't open device file: %s\n", DEVICE_FILE_NAME);
+      printf("Try creating a device file with: sudo mknod %s c %d 0\n", DEVICE_FILE_NAME, MAJOR_NUM);
+   }
+   return file_desc;
+}
+
+void mbox_close(int file_desc) {
+  close(file_desc);
+}
diff --git a/libavcodec/rpi_mailbox.h b/libavcodec/rpi_mailbox.h
new file mode 100644
index 0000000..c264d2e
--- /dev/null
+++ b/libavcodec/rpi_mailbox.h
@@ -0,0 +1,20 @@
+#ifndef RPI_MAILBOX_H
+#define RPI_MAILBOX_H
+
+extern int mbox_open(void);
+extern void mbox_close(int file_desc);
+
+extern unsigned get_version(int file_desc);
+extern unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags);
+extern unsigned mem_free(int file_desc, unsigned handle);
+extern unsigned mem_lock(int file_desc, unsigned handle);
+extern unsigned mem_unlock(int file_desc, unsigned handle);
+extern void *mapmem_shared(unsigned base, unsigned size);
+extern void *mapmem_private(unsigned base, unsigned size);
+extern void unmapmem(void *addr, unsigned size);
+
+extern unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+extern unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout);
+extern unsigned qpu_enable(int file_desc, unsigned enable);
+
+#endif
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
new file mode 100644
index 0000000..1609e31
--- /dev/null
+++ b/libavcodec/rpi_qpu.c
@@ -0,0 +1,647 @@
+// Use the vcsm device for shared memory
+// This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
+#define RPI_USE_VCSM
+#define RPI_TIME_TOTAL_QPU
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+#include <assert.h>
+
+#include <pthread.h>
+#include <time.h>
+
+#include "rpi_mailbox.h"
+#include "rpi_qpu.h"
+#include "rpi_shader.h"
+#include "rpi_hevc_transform.h"
+
+#ifdef RPI_USE_VCSM
+#include "rpi_user_vcsm.h"
+#endif
+
+// On Pi2 there is no way to access the VPU L2 cache
+// GPU_MEM_FLG should be 4 for uncached memory.
+// However, if using VCSM allocated buffers, need to use C at the moment because VCSM does not allocate uncached memory correctly
+// The QPU crashes if we mix L2 cached and L2 uncached accesses due to a HW bug. 
+#define GPU_MEM_FLG 0xC
+#define GPU_MEM_MAP 0x0
+
+#define vcos_verify(x) ((x)>=0)
+
+typedef unsigned char uint8_t;
+typedef signed char int8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int uint32_t;
+typedef int int32_t;
+
+/*static const unsigned code[] =
+{
+  #include "rpi_shader.hex"
+};*/
+
+// Size in 32bit words
+#define QPU_CODE_SIZE 2048
+#define VPU_CODE_SIZE 2048
+
+struct GPU
+{
+  unsigned int qpu_code[QPU_CODE_SIZE];
+  unsigned int vpu_code[VPU_CODE_SIZE];
+  int open_count; // Number of allocated video buffers
+  unsigned int vc_handle; // Handle of this memory
+  int      mb; // Mailbox handle
+  int      vc; // Address in GPU memory
+  int mail[12]; // These are used to pass pairs of code/unifs to the QPUs
+};
+
+// Stop more than one thread trying to allocate memory or use the processing resources at once
+static pthread_mutex_t gpu_mutex = PTHREAD_MUTEX_INITIALIZER;
+static volatile struct GPU* gpu = NULL;
+
+#ifdef RPI_TIME_TOTAL_QPU
+static unsigned int Microseconds(void) {
+    struct timespec ts;
+    unsigned int x;
+    static unsigned int base = 0;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    x = ts.tv_sec*1000000 + ts.tv_nsec/1000;
+    if (base==0) base=x;
+    return x-base;
+}
+#endif
+
+// Connect to QPU, returns 0 on success.
+static int gpu_init(volatile struct GPU **gpu) {
+  int mb = mbox_open();
+  int vc;
+  int handle;
+  volatile struct GPU* ptr;
+	if (mb < 0)
+		return -1;
+
+	if (qpu_enable(mb, 1)) return -2;
+  
+#ifdef RPI_USE_VCSM
+  vcsm_init();
+#endif
+  
+  handle = mem_alloc(mb, sizeof(struct GPU), 4096, GPU_MEM_FLG);
+  if (!handle)
+  {
+    qpu_enable(mb, 0);
+    return -3;
+  }
+	vc = mem_lock(mb, handle);
+	ptr = mapmem_shared((vc+GPU_MEM_MAP)&~0xc0000000, sizeof(struct GPU));
+	if (ptr == NULL)
+	{	mem_free(mb, handle);
+		mem_unlock(mb, handle);
+		qpu_enable(mb, 0);
+		return -4;
+	}
+
+	ptr->mb = mb;
+	ptr->vc_handle = handle;
+	ptr->vc = vc;
+  
+  *gpu = ptr;
+  
+  // Now copy over the QPU code into GPU memory
+  {
+    int num_bytes = qpu_get_fn(QPU_MC_END) - qpu_get_fn(QPU_MC_SETUP);
+    assert(num_bytes<=QPU_CODE_SIZE*sizeof(unsigned int));
+    memcpy((void*)ptr->qpu_code, rpi_shader, num_bytes);
+  }
+  // And the VPU code
+  {
+    int num_bytes = sizeof(rpi_hevc_transform);
+    assert(num_bytes<=VPU_CODE_SIZE*sizeof(unsigned int));
+    memcpy((void*)ptr->vpu_code, rpi_hevc_transform, num_bytes);
+  }
+  
+  return 0;
+}
+
+// Make sure we have exclusive access to the mailbox, and enable qpu if necessary.
+static void gpu_lock(void) {
+  pthread_mutex_lock(&gpu_mutex);
+  if (gpu==NULL) {
+    gpu_init(&gpu);
+  }
+}
+
+static void gpu_unlock(void) {
+  pthread_mutex_unlock(&gpu_mutex);
+}
+
+// Allocate memory on GPU
+// Fills in structure <p> containing ARM pointer, videocore handle, videocore memory address, numbytes
+// Returns 0 on success.
+// This allocates memory that will not be cached in ARM's data cache.
+// Therefore safe to use without data cache flushing.
+int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p) {
+  gpu_lock();
+  p->vc_handle = mem_alloc(gpu->mb, numbytes, 4096, GPU_MEM_FLG);
+  p->vcsm_handle = 0;
+  if (!p->vc_handle)
+  {
+    qpu_enable(gpu->mb, 0);
+    return -3;
+  }
+  p->vc = mem_lock(gpu->mb, p->vc_handle);
+  p->arm = mapmem_shared((p->vc+GPU_MEM_MAP)&~0xc0000000,numbytes);
+  p->numbytes = numbytes;
+  if (p->arm == NULL)
+  {
+    mem_free(gpu->mb, p->vc_handle);
+    mem_unlock(gpu->mb, p->vc_handle);
+    gpu_unlock();
+    qpu_enable(gpu->mb, 0);
+    return -4;
+  }
+  gpu->open_count++;
+  gpu_unlock();
+  return 0;
+}
+
+void gpu_cache_flush(GPU_MEM_PTR_T *p)
+{
+  // This only works when using RPI_USE_VCSM
+  void *tmp = vcsm_lock(p->vcsm_handle); 
+  vcsm_unlock_ptr(tmp);
+}
+
+// This allocates data that will be
+//    Cached in ARM L2
+//    Uncached in VPU L2
+int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p) {
+  gpu_lock();
+#ifdef RPI_USE_VCSM
+  {
+      p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" ); // f....... locks up for VP9 - retest this?
+      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" ); // 3b...... works
+      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" ); //fb...... locks up
+      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST_AND_VC, (char *)"Video Frame" ); // 3b works (but corrupted due to caching)
+      p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
+      p->arm = vcsm_lock(p->vcsm_handle);  
+      p->vc = mem_lock(gpu->mb, p->vc_handle);
+  }
+#else
+  p->vc_handle = mem_alloc(gpu->mb, numbytes, 4096, GPU_MEM_FLG);
+  p->vcsm_handle = 0;
+  if (!p->handle)
+  {
+    qpu_enable(gpu->mb, 0);
+    return -3;
+  }
+  p->vc = mem_lock(gpu->mb, p->vc_handle);
+  printf("This mapmem_private does not seem to work\n");
+  exit(-1);
+  p->arm = mapmem_private((p->vc+GPU_MEM_MAP)&~0xc0000000,numbytes);
+  p->numbytes = numbytes;
+  if (p->arm == NULL)
+  {
+    mem_free(gpu->mb, p->handle);
+    mem_unlock(gpu->mb, p->handle);
+    gpu_unlock();
+    qpu_enable(gpu->mb, 0);
+    return -4;
+  }
+#endif
+  gpu->open_count++;
+  gpu_unlock();
+  return 0;
+}
+
+static void gpu_term(void)
+{
+	int mb = gpu->mb;
+	unsigned handle = gpu->vc_handle;
+  if (gpu==NULL) 
+    return;
+	unmapmem((void*)gpu, sizeof(struct GPU));
+	mem_unlock(mb, handle);
+	mem_free(mb, handle);
+	qpu_enable(mb, 0);
+#ifdef RPI_USE_VCSM
+  vcsm_exit();
+#endif
+	mbox_close(mb);
+  gpu = NULL;
+}
+
+void gpu_free(GPU_MEM_PTR_T *p) {
+  int mb = gpu->mb;
+	unsigned handle = p->vc_handle;
+  gpu_lock();
+#ifdef RPI_USE_VCSM
+  if (p->vcsm_handle) {
+      mem_unlock(mb,p->vc_handle);
+      vcsm_unlock_ptr(p->arm);
+      vcsm_free(p->vcsm_handle);
+  } else {
+    	unmapmem((void*)p->arm, sizeof(struct GPU));
+      mem_unlock(mb, handle);
+      mem_free(mb, handle);
+  }
+#else
+	unmapmem((void*)p->arm, sizeof(struct GPU));
+	mem_unlock(mb, handle);
+	mem_free(mb, handle);
+#endif
+  
+  gpu->open_count--;
+  if (gpu->open_count==0) {
+      printf("Closing GPU\n");
+      gpu_term();
+      gpu = NULL;
+  }
+  gpu_unlock();
+}
+
+unsigned int vpu_get_fn(void) {
+  // Make sure that the gpu is initialized
+  if (gpu==NULL) {
+    printf("Preparing gpu\n");
+    gpu_lock();
+    gpu_unlock();
+  }
+  return gpu->vc + offsetof(struct GPU,vpu_code);
+}
+
+unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
+{
+  unsigned r;
+  gpu_lock();
+  r = execute_code(gpu->mb, code, r0, r1, r2, r3, r4, r5);
+  gpu_unlock();
+  return r;
+}
+
+// Run a program on a QPU with the given code and uniform stream (given in GPU addresses)
+// The first num QPUs will start at code, the next num2 QPUs will start at code2
+void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12)
+{
+  int i;
+#ifdef RPI_TIME_TOTAL_QPU
+  static int last_time=0;
+  static long long on_time=0;
+  static long long off_time=0;
+  int start_time;
+  int end_time;
+  static int count=0;
+#endif
+
+  gpu_lock();
+#ifdef RPI_TIME_TOTAL_QPU
+  start_time = Microseconds();
+  if (last_time==0)
+    last_time = start_time;
+  off_time += start_time-last_time;
+#endif
+  for(i=0;i<num;i++) {
+    gpu->mail[i*2 + 1] = code;  
+  }
+  for(;i<num+num2;i++) {
+    gpu->mail[i*2 + 1] = code2;  
+  }
+  gpu->mail[0 ] = unifs1;
+  gpu->mail[2 ] = unifs2;
+  gpu->mail[4 ] = unifs3;
+  gpu->mail[6 ] = unifs4;
+  gpu->mail[8 ] = unifs5;
+  gpu->mail[10] = unifs6;
+	gpu->mail[12] = unifs7;
+	gpu->mail[14] = unifs8;
+	gpu->mail[16] = unifs9;
+	gpu->mail[18] = unifs10;
+	gpu->mail[20] = unifs11;
+	gpu->mail[22] = unifs12;
+	execute_qpu(
+		gpu->mb,
+		12 /* Number of QPUs */,
+		gpu->vc + offsetof(struct GPU, mail),
+		1 /* no flush */,  // Don't flush VPU L1 cache
+		5000 /* timeout ms */);
+#ifdef RPI_TIME_TOTAL_QPU
+  end_time = Microseconds();
+  last_time = end_time;
+  on_time += end_time - start_time;
+  count++;
+  if ((count&0x7f)==0)
+    printf("On=%dms, Off=%dms\n",(int)(on_time/1000),(int)(off_time/1000));
+#endif
+  gpu_unlock();
+}
+  
+unsigned int qpu_get_fn(int num) {
+    // Make sure that the gpu is initialized
+    unsigned int *fn;
+    if (gpu==NULL) {
+      printf("Preparing gpu\n");
+      gpu_lock();
+      gpu_unlock();
+    }
+    switch(num) {
+    case QPU_MC_SETUP:
+      fn = mc_setup;
+      break;
+    case QPU_MC_FILTER:
+      fn = mc_filter;
+      break;
+    case QPU_MC_EXIT:
+      fn = mc_exit;
+      break;
+    case QPU_MC_INTERRUPT_EXIT:
+      fn = mc_interrupt_exit;
+      break;
+    case QPU_MC_FILTER_B:
+      fn = mc_filter_b;
+      break;
+    case QPU_MC_FILTER_HONLY:
+      fn = mc_filter_honly;
+      break;
+    case QPU_MC_SETUP_UV:
+      fn = mc_setup_uv;
+      break;
+    case QPU_MC_FILTER_UV:
+      fn = mc_filter_uv;
+      break;
+    case QPU_MC_FILTER_UV_B:
+      fn = mc_filter_uv_b;
+      break;
+    case QPU_MC_END:
+      fn = mc_end;
+      break;
+    default:
+      printf("Unknown function\n");
+      exit(-1);
+    }
+    return gpu->vc + 4*(int)(fn-rpi_shader);
+    //return code[num] + gpu->vc;
+}
+
+#if 0
+
+int32_t hcoeffs[] = {-4, 10, -21, 70, 90, -24, 11, -4};
+//int32_t hcoeffs[] = {1, 1, 1, 1, 1, 1, 1, 1};
+int32_t vcoeffs[] = {-2, 6, -13, 37, 115, -20, 9, -4};
+//int32_t vcoeffs[] = {1, 1, 1, 1, 1, 1, 1, 1};
+
+#define ENCODE_COEFFS(c0, c1, c2, c3) (((c0-1) & 0xff) | ((c1-1) & 0xff) << 8 | ((c2-1) & 0xff) << 16 | ((c3-1) & 0xff) << 24);
+
+static uint8_t av_clip_uint8(int32_t a)
+{
+    if (a&(~255)) return (-a)>>31;
+    else          return a;
+}
+
+static int32_t filter8(const uint8_t *data, int pitch)
+{
+   int32_t vsum = 0;
+   int x, y;
+
+   for (y = 0; y < 8; y++) {
+      int32_t hsum = 0;
+
+      for (x = 0; x < 8; x++)
+         hsum += hcoeffs[x]*data[x + y * pitch];
+
+      vsum += vcoeffs[y]*av_clip_uint8( (hsum + 64) >> 7); // Added brackets to stop compiler warning
+   }
+
+   return av_clip_uint8( (vsum + 64) >> 7);
+}
+
+// Note regression changes coefficients so is not thread safe
+//#define REGRESSION
+#ifdef REGRESSION
+#define CMAX 100
+#else
+#define CMAX 2
+#endif
+#define YMAX 16
+
+int rpi_test_shader(void)
+{
+   int i, c;
+
+   uint32_t *unifs;
+
+   uint8_t *in_buffer;
+   uint8_t *out_buffer[2];
+   
+   GPU_MEM_PTR_T unifs_ptr;
+   GPU_MEM_PTR_T in_buffer_ptr;
+   GPU_MEM_PTR_T out_buffer_ptr[2];
+   
+   // Addresses in GPU memory of filter programs
+   uint32_t mc_setup = 0;
+   uint32_t mc_filter = 0;
+   uint32_t mc_exit = 0;
+   
+   int pitch = 0x500;
+
+   if (gpu==NULL) {
+      gpu_lock();
+      gpu_unlock();
+   }
+   
+   printf("This needs to change to reflect new assembler\n");
+   // Use table to compute locations of program start points
+   mc_setup = code[0] + gpu->vc;
+   mc_filter = code[1] + gpu->vc;
+   mc_exit = code[2] + gpu->vc;
+
+   if (!vcos_verify(gpu_malloc_uncached(4*64,&unifs_ptr))) {
+      return -2;
+   }
+   unifs = (uint32_t*)unifs_ptr.arm;
+
+   if (!vcos_verify(gpu_malloc_uncached(64*23,&in_buffer_ptr))) {
+      return -3;
+   }
+   in_buffer = (uint8_t*)in_buffer_ptr.arm;
+
+   if (!vcos_verify(gpu_malloc_uncached(16*pitch,&out_buffer_ptr[0])) || !vcos_verify(gpu_malloc_uncached(16*pitch,&out_buffer_ptr[1]))) {
+      return -4;
+   }
+   out_buffer[0] = (uint8_t*)out_buffer_ptr[0].arm;
+   out_buffer[1] = (uint8_t*)out_buffer_ptr[1].arm;
+
+   for (c = 0; c < CMAX; c++) {
+      int xo[] = {rand()&31, rand()&31};
+
+#ifdef REGRESSION
+      for (i = 0; i < 8; i++) {
+         hcoeffs[i] = (int8_t)rand();
+         vcoeffs[i] = (int8_t)rand();
+         if (hcoeffs[i]==-128)
+           hcoeffs[i]++;
+         if (vcoeffs[i]==-128)
+           vcoeffs[i]++;
+      }
+#endif
+
+      for (i = 0; i < 64*23; i++) {
+         //printf("%d %d %p\n",i,gpu->mb,&in_buffer[i]);
+         in_buffer[i] = rand();
+      }
+           
+      // Clear output array
+      { 
+        int b;
+        for(b=0;b<2;b++) {
+          for(i=0;i<16*16;i++) {
+            out_buffer[b][i] = 3;
+          }
+        }
+      }
+
+      unifs[0] = mc_filter;
+      unifs[1] = in_buffer_ptr.vc+xo[0]+16;
+      unifs[2] = 64; // src pitch
+      unifs[3] = pitch; // dst pitch
+      unifs[4] = 0; // Padding
+      unifs[5] = 0;
+      unifs[6] = 0;
+      unifs[7 ] = mc_filter;
+      unifs[8 ] = in_buffer_ptr.vc+xo[1]+16;
+      unifs[9 ] = ENCODE_COEFFS(hcoeffs[0], hcoeffs[1], hcoeffs[2], hcoeffs[3]);
+      unifs[10] = ENCODE_COEFFS(hcoeffs[4], hcoeffs[5], hcoeffs[6], hcoeffs[7]);
+      unifs[11] = ENCODE_COEFFS(vcoeffs[0], vcoeffs[1], vcoeffs[2], vcoeffs[3]);
+      unifs[12] = ENCODE_COEFFS(vcoeffs[4], vcoeffs[5], vcoeffs[6], vcoeffs[7]);
+      unifs[13] = out_buffer_ptr[0].vc;
+      unifs[14] = mc_exit;
+      unifs[15] = in_buffer_ptr.vc+xo[1]+16;        // dummy
+      unifs[16] = ENCODE_COEFFS(hcoeffs[0], hcoeffs[1], hcoeffs[2], hcoeffs[3]);
+      unifs[17] = ENCODE_COEFFS(hcoeffs[4], hcoeffs[5], hcoeffs[6], hcoeffs[7]);
+      unifs[18] = ENCODE_COEFFS(vcoeffs[0], vcoeffs[1], vcoeffs[2], vcoeffs[3]);
+      unifs[19] = ENCODE_COEFFS(vcoeffs[4], vcoeffs[5], vcoeffs[6], vcoeffs[7]);
+      unifs[20] = out_buffer_ptr[1].vc;
+      
+      printf("Gpu->vc=%x Code=%x dst=%x\n",gpu->vc, mc_filter,out_buffer_ptr[1].vc);
+
+      // flush_dcache(); TODO is this needed on ARM side? - tried to use the direct alias to avoid this problem
+
+      //qpu_run_shader(mc_setup, unifs_ptr.vc);
+      //qpu_run_shader(gpu, gpu->vc, unifs_ptr.vc);
+      rpi_do_block(in_buffer_ptr.vc+xo[0]+16, 64, out_buffer_ptr[0].vc, pitch,out_buffer[0]);
+      rpi_do_block(in_buffer_ptr.vc+xo[1]+16, 64, out_buffer_ptr[1].vc, pitch,out_buffer[1]);
+
+      if (1)
+      {
+         int x, y, b;
+         int bad = 0;
+
+         for (b=0; b<2; ++b)
+            for (y=0; y<YMAX; ++y)
+               for (x=0; x<16; ++x) {
+                  int32_t ref = filter8(in_buffer+x+y*64+xo[b], 64);
+
+                  if (out_buffer[b][x+y*pitch] != ref) {
+                      bad = 1;
+//                     printf("%d, %d, %d, %d\n", c, b, x, y);
+                  }
+#ifndef REGRESSION
+                  //printf("%08x %08x\n", out_buffer[b][x+y*pitch], ref);
+#endif
+               }
+          if (bad)
+            printf("Failed dst=%x test=%d\n",out_buffer_ptr[1].vc,c);
+          else
+            printf("Passed dst=%x test=%d\n",out_buffer_ptr[1].vc,c);
+      }
+      //printf("%d\n", simpenrose_get_qpu_tick_count());
+   }
+
+   gpu_free(&out_buffer_ptr[0]);
+   gpu_free(&out_buffer_ptr[1]);
+   gpu_free(&in_buffer_ptr);
+   gpu_free(&unifs_ptr);
+
+   return 0;
+}
+
+void rpi_do_block_arm(const uint8_t *in_buffer, int src_pitch, uint8_t *dst, int dst_pitch)
+{
+  int x,y;
+  for (y=0; y<16; ++y) {
+    for (x=0; x<16; ++x) {
+       dst[x+y*dst_pitch] = filter8(in_buffer+x+y*src_pitch, src_pitch);
+    }
+  }
+}
+
+void rpi_do_block(const uint8_t *in_buffer_vc, int src_pitch, uint8_t *dst_vc, int dst_pitch, uint8_t *dst)
+{
+   uint32_t *unifs;
+
+   GPU_MEM_PTR_T unifs_ptr;
+   //uint8_t *out_buffer;
+   //GPU_MEM_PTR_T out_buffer_ptr;
+   
+   // Addresses in GPU memory of filter programs
+   uint32_t mc_setup = 0;
+   uint32_t mc_filter = 0;
+   uint32_t mc_exit = 0;
+   //int x,y;
+    
+   if (gpu==NULL) {
+      gpu_lock();
+      gpu_unlock();
+   }
+   
+   // Use table to compute locations of program start points
+   mc_setup = code[0] + gpu->vc;
+   mc_filter = code[1] + gpu->vc;
+   mc_exit = code[2] + gpu->vc;
+   
+   if (!vcos_verify(gpu_malloc_uncached(4*64,&unifs_ptr))) {
+      return;
+   }
+   //gpu_malloc_uncached(16*dst_pitch,&out_buffer_ptr);
+   //out_buffer = (uint8_t*)out_buffer_ptr.arm;
+   
+   /*for (y=0; y<16; ++y) {
+      for (x=0; x<16; ++x) {
+         out_buffer[x+y*dst_pitch] = 7;
+      }
+    }*/
+   
+   unifs = (uint32_t*)unifs_ptr.arm;
+   
+    unifs[0] = mc_filter;
+    unifs[1] = (int)in_buffer_vc;
+    unifs[2] = src_pitch; // src pitch
+    unifs[3] = dst_pitch; // dst pitch
+    unifs[4] = 0; // Padding
+    unifs[5] = 0;
+    unifs[6] = 0;
+    unifs[7 ] = mc_exit;
+    unifs[8 ] = (int)in_buffer_vc;
+    unifs[9 ] = ENCODE_COEFFS(hcoeffs[0], hcoeffs[1], hcoeffs[2], hcoeffs[3]);
+    unifs[10] = ENCODE_COEFFS(hcoeffs[4], hcoeffs[5], hcoeffs[6], hcoeffs[7]);
+    unifs[11] = ENCODE_COEFFS(vcoeffs[0], vcoeffs[1], vcoeffs[2], vcoeffs[3]);
+    unifs[12] = ENCODE_COEFFS(vcoeffs[4], vcoeffs[5], vcoeffs[6], vcoeffs[7]);
+    unifs[13] = (int)dst_vc;
+    //unifs[13] = (int)out_buffer_ptr.vc;
+
+    //printf("Gpu->vc=%x Code=%x dst=%x\n",gpu->vc, mc_filter,out_buffer_ptr[1].vc);
+
+    qpu_run_shader(mc_setup, unifs_ptr.vc);
+    
+    /*for (y=0; y<16; ++y) {
+      for (x=0; x<16; ++x) {
+         dst[x+y*dst_pitch] = out_buffer[x+y*dst_pitch];
+      }
+    }*/
+    
+    gpu_free(&unifs_ptr);
+    //gpu_free(&out_buffer_ptr);
+}
+
+
+#endif
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
new file mode 100644
index 0000000..4e3c35c
--- /dev/null
+++ b/libavcodec/rpi_qpu.h
@@ -0,0 +1,45 @@
+#ifndef RPI_QPU_H
+#define RPI_QPU_H
+
+typedef struct gpu_mem_ptr_s {
+  unsigned char *arm; // Pointer to memory mapped on ARM side
+  int vc_handle;   // Videocore handle of relocatable memory
+  int vcsm_handle; // Handle for use by VCSM
+  int vc;       // Address for use in GPU code
+  int numbytes; // Size of memory block
+} GPU_MEM_PTR_T;
+
+// General GPU functions
+extern int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p);
+extern int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p);
+extern void gpu_free(GPU_MEM_PTR_T *p);
+extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
+
+// QPU specific functions
+extern void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12);
+
+enum {
+  QPU_MC_SETUP,
+  QPU_MC_FILTER,
+  QPU_MC_EXIT,
+  QPU_MC_INTERRUPT_EXIT,
+  QPU_MC_FILTER_B,
+  QPU_MC_FILTER_HONLY,
+  QPU_MC_SETUP_UV,
+  QPU_MC_FILTER_UV,
+  QPU_MC_FILTER_UV_B,
+  QPU_MC_END
+  };
+extern unsigned int qpu_get_fn(int num);
+
+// VPU specific functions
+extern unsigned int vpu_get_fn(void);
+extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+
+// Simple test of shader code
+extern int rpi_test_shader(void);
+
+extern void rpi_do_block(const unsigned char *in_buffer_vc, int src_pitch, unsigned char *dst_vc, int dst_pitch, unsigned char *dst);
+extern void rpi_do_block_arm(const unsigned char *in_buffer, int src_pitch, unsigned char *dst, int dst_pitch);
+
+#endif
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
new file mode 100644
index 0000000..41cc2e1
--- /dev/null
+++ b/libavcodec/rpi_shader.c
@@ -0,0 +1,818 @@
+#include "rpi_shader.h"
+
+#ifdef _MSC_VER
+   #include <stdint.h>
+   /* cast through uintptr_t to avoid warnings */
+   #define POINTER_TO_UINT(X) ((unsigned int)(uintptr_t)(X))
+#else
+   #define POINTER_TO_UINT(X) ((unsigned int)(X))
+#endif
+
+#ifdef __cplusplus
+extern "C" { /* the types are probably wrong... */
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef _MSC_VER
+__declspec(align(8))
+#elif defined(__GNUC__)
+__attribute__((aligned(8)))
+#endif
+unsigned int rpi_shader[] = {
+// ::mc_setup
+/* [0x00000000] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000008] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
+/* [0x00000010] */ 0x15827d80, 0x10020767, // mov ra_y, unif
+/* [0x00000018] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
+/* [0x00000020] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+/* [0x00000028] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+/* [0x00000030] */ 0x15827d80, 0x10021427, // mov rb16, unif
+/* [0x00000038] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000040] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+/* [0x00000048] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+/* [0x00000050] */ 0x00000001, 0xe0020527, // mov ra20, 1
+/* [0x00000058] */ 0x00000040, 0xe0020567, // mov ra21, 64
+/* [0x00000060] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+/* [0x00000068] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+/* [0x00000070] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x00000078] */ 0x00000040, 0xe0021567, // mov rb21, 64
+/* [0x00000080] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x00000088] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x00000090] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x00000098] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x000000a0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x000000a8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x000000b0] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x000000d0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x000000d8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x000000e0] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x000000e8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x000000f0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x000000f8] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000100] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000108] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000110] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00000118] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00000120] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00000128] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000130] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00000138] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000140] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000148] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000150] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000158] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000160] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000168] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000170] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000178] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+/* [0x00000180] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+/* [0x00000188] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x00000190] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+/* [0x00000198] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000001a0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+/* [0x000001a8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x000001b0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+/* [0x000001b8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+/* [0x000001c0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x000001c8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x000001d0] */ 0x4c9d00cf, 0x10024821, // add r0, r0, r3; mul24 r1, r1, rb_pitch
+/* [0x000001d8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+/* [0x000001e0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000001e8] */ 0x949dc5c0, 0xd0025890, // and r2, r2, ~3; mov ra_x_base, r0
+/* [0x000001f0] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+/* [0x000001f8] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+/* [0x00000200] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000208] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000210] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000218] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000220] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000228] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000230] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000238] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+/* [0x00000240] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+// ::mc_filter_uv
+/* [0x00000248] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000250] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000258] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000260] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000268] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000270] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000278] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000280] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000288] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000290] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000298] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000002a0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000002a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000002b0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000002c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000002c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000002d0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x000002d8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x000002e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000002e8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000002f0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000002f8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000300] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000330] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000338] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000340] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000348] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000350] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000358] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000360] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000368] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000370] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000378] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000380] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000388] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000390] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000398] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003a0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :uvloop
+/* [0x000003a8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000003b0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000003b8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000003c0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003c8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003d0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003d8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003e0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000400] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000408] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+/* [0x00000410] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000420] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000430] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000440] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000448] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000450] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000458] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000460] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000468] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000470] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000478] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000480] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x00000488] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000490] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000498] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x000004a0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x000004a8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x000004b0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x000004b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000004c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x000004c8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000004d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x000004d8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x000004e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x000004e8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x000004f0] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x000004f8] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000500] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000508] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000510] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000518] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000520] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000528] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x00000530] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000538] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000540] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000560] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000568] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000570] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000578] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000580] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000588] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000590] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000598] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_filter
+/* [0x000005a0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000005a8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000005b0] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+/* [0x000005b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000005c0] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+/* [0x000005c8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000005d0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+/* [0x000005d8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000005e0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+/* [0x000005e8] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+/* [0x000005f0] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+/* [0x000005f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000600] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+/* [0x00000608] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000610] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+/* [0x00000618] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000620] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000628] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000630] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000638] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000640] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000648] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000650] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000658] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000660] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000668] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000670] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000678] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000680] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000688] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000690] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000698] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000006b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000006d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000006f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000700] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000708] */ 0x000001d0, 0xf07809e7, // brr.anynn -, r:fast_path
+/* [0x00000710] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000718] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000720] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000728] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :loop
+/* [0x00000730] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000738] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000740] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000748] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000750] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+/* [0x00000758] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000760] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000768] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000770] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000778] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000780] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000788] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000790] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000798] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000007a0] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000007a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000007b0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000007b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000007c0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x000007c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x000007d0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x000007d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x000007e0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x000007e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x000007f0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x000007f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000800] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x00000808] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000810] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000818] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000820] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000828] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000830] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000838] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000840] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000848] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:loop
+/* [0x00000850] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x00000858] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x00000860] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x00000868] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x00000870] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x00000878] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000880] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000888] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000890] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000898] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x000008a0] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x000008a8] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x000008b0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000008b8] */ 0xfffffe58, 0xf06809e7, // brr.anyn -, r:loop
+/* [0x000008c0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x000008c8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000008d0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000008d8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000008e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000008e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000008f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// :fast_path
+/* [0x000008f8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :fast_loop
+/* [0x00000900] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000908] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000910] */ 0x95727d9b, 0x1004475f, // mov.ifz ra_y, ra_y_next   ; mov rb31, r3
+/* [0x00000918] */ 0x95690dbf, 0x10044623, // mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
+/* [0x00000920] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000928] */ 0x929de5e4, 0x100248a1, // min r2, r2, rb_frame_height_minus_1 ; mov r1, r4
+/* [0x00000930] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000938] */ 0xec414c87, 0x10024e20, // add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
+/* [0x00000940] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000948] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000950] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
+/* [0x00000958] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
+/* [0x00000960] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
+/* [0x00000968] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
+/* [0x00000970] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
+/* [0x00000978] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
+/* [0x00000980] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
+/* [0x00000988] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
+/* [0x00000990] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000998] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x000009a0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x000009a8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x000009b0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x000009b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000009c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8       ; mov r1, ra22
+/* [0x000009c8] */ 0xffffff18, 0xf06809e7, // brr.anyn -, r:fast_loop
+/* [0x000009d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x000009d8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x000009e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x000009e8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x000009f0] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x000009f8] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000a00] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000a08] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000a10] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000a18] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000a20] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000a28] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x00000a30] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000a38] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:fast_loop
+/* [0x00000a40] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x00000a48] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000a50] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000a60] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_filter_b
+/* [0x00000a78] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000a80] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000a88] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+/* [0x00000a90] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000a98] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+/* [0x00000aa0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000aa8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+/* [0x00000ab0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000ab8] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+/* [0x00000ac0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+/* [0x00000ac8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+/* [0x00000ad0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000ad8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+/* [0x00000ae0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000ae8] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+/* [0x00000af0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000af8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000b00] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000b08] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000b10] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000b18] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000b20] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000b28] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000b30] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000b38] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000b40] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000b48] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000b50] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000b58] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000b60] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000b68] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000b70] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+/* [0x00000b78] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000b80] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000b88] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000b90] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000b98] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000ba0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ba8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000bb0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000bb8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000bc0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000bc8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000bd0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000bd8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000be0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000be8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000bf0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000bf8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000c00] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000c08] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000c10] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :bloop
+/* [0x00000c18] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000c20] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000c28] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000c30] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000c38] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+/* [0x00000c40] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000c48] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000c50] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000c58] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000c60] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000c68] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000c70] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000c78] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000c80] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000c88] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000c90] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000c98] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000ca0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000ca8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000cb0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000cb8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000cc0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000cc8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000cd0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000cd8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000ce0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000ce8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x00000cf0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000cf8] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000d00] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000d08] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000d10] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000d18] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000d20] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000d28] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000d30] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:bloop
+/* [0x00000d38] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x00000d40] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x00000d48] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x00000d50] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x00000d58] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x00000d60] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000d68] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000d70] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000d78] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000d80] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000d88] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000d90] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x00000d98] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000da0] */ 0x8fc8f3f6, 0xd0020867, // asr r1, r1, 15          ; mov -, vr_wait
+/* [0x00000da8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000db0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+/* [0x00000db8] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:bloop
+/* [0x00000dc0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000dc8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x00000dd0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+/* [0x00000dd8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000de0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000de8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000df0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_filter_honly
+/* [0x00000df8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000e00] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000e08] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+/* [0x00000e10] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000e18] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+/* [0x00000e20] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000e28] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+/* [0x00000e30] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000e38] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+/* [0x00000e40] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+/* [0x00000e48] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+/* [0x00000e50] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000e58] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+/* [0x00000e60] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000e68] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+/* [0x00000e70] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000e78] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000e80] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000e88] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000e90] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000e98] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000ea0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000ea8] */ 0x0c9de1c0, 0xd0021467, // add rb17, r0, -2
+/* [0x00000eb0] */ 0x919c71c0, 0xd0024812, // shl r0, r0, 7 ; mov rb18,r0
+/* [0x00000eb8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000ec0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000ec8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000ed0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000ed8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ee0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ee8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ef0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000ef8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f00] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f08] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f10] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000f18] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000f20] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000f28] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000f30] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :loop_honly
+/* [0x00000f38] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000f40] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000f48] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000f50] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000f58] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+/* [0x00000f60] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000f68] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000f70] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000f78] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000f80] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000f88] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000f90] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000f98] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000fa0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000fa8] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000fb0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000fb8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000fc0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000fc8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000fd0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000fd8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000fe0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000fe8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000ff0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000ff8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00001000] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00001008] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
+/* [0x00001010] */ 0x8d5927f6, 0x100269e1, // sub.setf -, r3, rb18 ; mov r1, ra22
+/* [0x00001018] */ 0x559f2fc1, 0x100049e0, // mov -, vw_wait   ; mul24 r0, r0, r1
+/* [0x00001020] */ 0xfffffef8, 0xf06809e7, // brr.anyn -, r:loop_honly
+/* [0x00001028] */ 0x0f9cf1c0, 0xd0020827, // asr r0, r0, 15
+/* [0x00001030] */ 0x129d61c0, 0x10020827, // min r0, r0, rb22
+/* [0x00001038] */ 0x139c01c0, 0xd0020c27, // max vpm, r0, 0
+/* [0x00001040] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001048] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00001050] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001058] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_exit
+/* [0x00001060] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00001068] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00001070] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001078] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001080] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001088] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001090] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00001098] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x000010a0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_exit1
+/* [0x000010a8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x000010b0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010b8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010c0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010c8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000010d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000010e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_interrupt_exit
+/* [0x000010e8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x000010f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001100] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001108] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001110] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001118] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001120] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001128] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001130] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001138] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001140] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001148] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001150] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001158] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001160] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001168] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00001170] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00001178] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_interrupt_exit4
+/* [0x00001180] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00001188] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001190] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001198] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000011a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000011a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000011b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000011b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000011c0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000011c8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000011d0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_interrupt_exit8
+/* [0x000011d8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x000011e0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000011e8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000011f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000011f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001200] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001208] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001210] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001218] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001220] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001228] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001230] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001238] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00001240] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00001248] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_setup_uv
+/* [0x00001250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00001258] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
+/* [0x00001260] */ 0x15827d80, 0x10020767, // mov ra_y, unif
+/* [0x00001268] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
+/* [0x00001270] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00001278] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
+/* [0x00001280] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+/* [0x00001288] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+/* [0x00001290] */ 0x15827d80, 0x10021427, // mov rb16, unif
+/* [0x00001298] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000012a0] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+/* [0x000012a8] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+/* [0x000012b0] */ 0x00000001, 0xe0020527, // mov ra20, 1
+/* [0x000012b8] */ 0x00000040, 0xe0020567, // mov ra21, 64
+/* [0x000012c0] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+/* [0x000012c8] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+/* [0x000012d0] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x000012d8] */ 0x00000040, 0xe0021567, // mov rb21, 64
+/* [0x000012e0] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x000012e8] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x000012f0] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x000012f8] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x00001300] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x00001308] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x00001310] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x00001318] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x00001320] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x00001328] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x00001330] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00001338] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00001340] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00001348] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00001350] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00001358] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00001360] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00001368] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00001370] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00001378] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00001380] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00001388] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00001390] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00001398] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x000013a0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x000013a8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x000013b0] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x000013b8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x000013c0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000013c8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x000013d0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x000013d8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+/* [0x000013e0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x000013e8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+/* [0x000013f0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+/* [0x000013f8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x00001400] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00001408] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00001410] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+/* [0x00001418] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00001420] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+/* [0x00001428] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+/* [0x00001430] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+/* [0x00001438] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001440] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001448] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001450] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00001458] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00001460] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00001468] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001470] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00001478] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+/* [0x00001480] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+// ::mc_filter_uv_b
+/* [0x00001488] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00001490] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00001498] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000014a0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000014a8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000014b0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000014b8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000014c0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000014c8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000014d0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000014d8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000014e0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000014e8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000014f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000014f8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00001500] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00001508] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00001510] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00001518] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00001520] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00001528] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00001530] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00001538] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00001540] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00001548] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00001550] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00001558] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+/* [0x00001560] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00001568] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001570] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001578] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001580] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001588] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00001590] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001598] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000015a0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000015a8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000015b0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015b8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015c0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000015c8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000015d0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015d8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015e0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015e8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x000015f0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000015f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00001600] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :uvloop_b
+/* [0x00001608] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00001610] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00001618] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00001620] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00001628] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00001630] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00001638] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00001640] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00001648] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00001650] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00001658] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00001660] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00001668] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+/* [0x00001670] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00001678] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00001680] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00001688] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00001690] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00001698] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000016a0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x000016a8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x000016b0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x000016b8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x000016c0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x000016c8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x000016d0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x000016d8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x000016e0] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x000016e8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x000016f0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x000016f8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00001700] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00001708] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00001710] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00001718] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00001720] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00001728] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00001730] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x00001738] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x00001740] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x00001748] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x00001750] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x00001758] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00001760] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00001768] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00001770] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00001778] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00001780] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00001788] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x00001790] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00001798] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x000017a0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000017a8] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+/* [0x000017b0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000017b8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x000017c0] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x000017c8] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+/* [0x000017d0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000017d8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000017e0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000017e8] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000017f0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000017f8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001800] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00001808] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001810] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_end
+};
+#ifdef __HIGHC__
+#pragma Align_to(8, rpi_shader)
+#endif
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
new file mode 100644
index 0000000..db971f4
--- /dev/null
+++ b/libavcodec/rpi_shader.h
@@ -0,0 +1,20 @@
+#ifndef rpi_shader_H
+#define rpi_shader_H
+
+extern unsigned int rpi_shader[];
+
+#define mc_setup (rpi_shader + 0)
+#define mc_filter_uv (rpi_shader + 146)
+#define mc_filter (rpi_shader + 360)
+#define mc_filter_b (rpi_shader + 670)
+#define mc_filter_honly (rpi_shader + 894)
+#define mc_exit (rpi_shader + 1048)
+#define mc_exit1 (rpi_shader + 1066)
+#define mc_interrupt_exit (rpi_shader + 1082)
+#define mc_interrupt_exit4 (rpi_shader + 1120)
+#define mc_interrupt_exit8 (rpi_shader + 1142)
+#define mc_setup_uv (rpi_shader + 1172)
+#define mc_filter_uv_b (rpi_shader + 1314)
+#define mc_end (rpi_shader + 1542)
+
+#endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
new file mode 100644
index 0000000..2214745
--- /dev/null
+++ b/libavcodec/rpi_shader.qasm
@@ -0,0 +1,1413 @@
+# register allocation
+#
+# ra0...ra7                                     eight horizontal filter coefficients
+#
+# rb1...rb7                                     seven shifted copies of the current unfiltered row
+#
+# ra8...ra15                                    eight filtered rows of context (rb15 == most recent)
+#
+#                                               (ra15 isn't clamped to zero - this happens during the
+#                                                copy to ra14, and during its use in the vertical filter)
+#
+# rb8...rb15                                    eight vertical filter coefficients
+#
+# ra16                                          clipped(row start address+elem_num)&~3
+# ra17                                          per-channel shifts
+# ra19                                          next ra17
+#
+# rb16                                          pitch
+# rb17                                          height + 5
+# rb18                                          height + 7
+# rb19                                          next ra16
+#
+# ra20                                          1
+# ra21                                          64
+# ra22                                          256
+# ra23                                          8
+#
+# rb20                                          0xffffff00
+# rb21                                          64
+# rb22                                          255
+# rb23                                          24
+#
+# rb24                                          vdw_setup_1(dst_pitch) 
+# rb25                                          frame width-1
+# rb26                                          height<<23 + width<<16 + vdw_setup_0
+# rb27                                          vdw_setup_0 (depends on QPU number)
+# rb28                                          vpm_setup (depends on QPU number)
+# rb29                                          vdw_setup_1(dst_pitch-width)
+# rb30                                          frame height-1
+# rb31                                          used as temp to count loop iterations
+#
+# ra24...ra30                                   15, 14, 13, 12, 11, 10, 9
+# ra24                                          clipped(row start address+8+elem_num)&~3
+# ra25                                          per-channel shifts 2
+# ra26                                          next ra24
+# ra27                                          next ra25
+# ra28                                          next y
+# ra29                                          y for next texture access
+#
+# ra31                                          next kernel address
+
+.set rb_frame_width_minus_1,       rb25
+.set rb_frame_height_minus_1,      rb30
+.set rb_pitch,                     rb16
+.set ra_x_base,                    ra16
+.set rb_x_base_next,               rb19
+.set ra_x2_base,                   ra24
+.set ra_x2_base_next,              ra26
+.set ra_xshift,                    ra17
+
+.set ra_x2shift,                   ra25
+.set ra_u2v_ref_offset,            ra25
+
+.set ra_xshift_next,               ra19
+
+.set ra_x2shift_next,              ra27
+.set ra_u2v_dst_offset,            ra27
+
+.set ra_y_next,                    ra28
+.set ra_y,                         ra29
+
+.set rb_const_64,                  rb21
+
+# mc_setup(next_kernel, x, y, ref_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1)
+::mc_setup
+
+# Read starting kernel
+mov ra31, unif
+
+# Load first request location
+add ra_x_base, unif, elem_num # Store x
+mov ra_y, unif # Store y
+mov ra_x2_base, unif # Store frame base
+
+# Read image dimensions
+sub rb25,unif,1
+sub rb30,unif,1
+
+# get source pitch
+mov rb16, unif
+
+# get destination pitch
+mov r0, unif
+mov r1, vdw_setup_1(0)
+add rb24, r1, r0
+
+# load constants
+
+mov ra20, 1
+mov ra21, 64
+mov ra22, 256
+mov ra23, 8
+
+mov rb20, 0xffffff00
+mov rb21, 64
+mov rb22, 255
+mov rb23, 24
+
+# touch vertical context to keep simulator happy
+
+mov ra8, 0
+mov ra9, 0
+mov ra10, 0    
+mov ra11, 0
+mov ra12, 0    
+mov ra13, 0
+mov ra14, 0    
+mov ra15, 0
+
+# Compute part of VPM to use for DMA output
+mov r2, qpu_num
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+shl r0, r0, 5
+add rb27, r0, r1
+
+# Compute part of VPM to save data into
+mov r2, qpu_num
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vpm_setup(0, 4, h8p(0, 0))
+add rb28, r0, r1 
+
+# Compute base address for first and second access
+#add r0, unif, elem_num     # x
+mov r0, ra_x_base           # Load x
+add r2, r0, 8               # x+8
+max r0, r0, 0; mov r1, ra_y # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
+shl ra_xshift_next, r0, 3
+max r2, r2, 0
+add ra_y, r1, 1
+min r2, r2, rb_frame_width_minus_1
+shl ra_x2shift_next, r2, 3
+max r1, r1, 0  # y
+min r1, r1, rb_frame_height_minus_1
+add r0, r0, r3; mul24 r1, r1, rb_pitch
+add r2, r2, r3
+and r0, r0, ~3
+and r2, r2, ~3; mov ra_x_base, r0
+# submit texture requests for first line
+add t0s, r0, r1 ; mov ra_x2_base, r2
+add t0s, r2, r1
+
+# Dump padding words
+mov r0, unif
+mov r0, unif
+
+# submit texture requests for second line
+max r1, ra_y, 0
+min r1, r1, rb_frame_height_minus_1
+add ra_y, ra_y, 1
+bra -, ra31
+nop ; mul24 r1, r1, rb_pitch
+add t0s, r1, ra_x_base
+add t0s, r1, ra_x2_base
+
+################################################################################
+
+# mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter_uv
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+shl ra_xshift_next, r0, 3
+sub r2, unif, r3 # compute offset from frame base u to frame base v
+add r0, r0, r3
+and rb_x_base_next, r0, ~3 
+mov ra_y_next, r1
+add ra_x2_base_next, rb_x_base_next, r2
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+asr rb12, r0, rb23  
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+mov r3, 0
+
+:uvloop
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:uvloop
+max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr r0, r0, 15          ; mov r1, ra21
+min.setf ra15, r0, rb22
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r0, ra14, rb14
+sub r1, r1, r0          ; mul24 r0, ra13, rb13
+sub r1, r1, r0          ; mul24 r0, ra12, rb12
+sub r1, r1, r0          ; mul24 r0, ra11, rb11
+sub r1, r1, r0          ; mul24 r0, ra10, rb10
+sub r1, r1, r0          ; mul24 r0, ra9, rb9
+sub r1, r1, r0          ; mul24 r0, ra8, rb8
+sub r1, r1, r0          ; mul24 r0, ra15, rb15
+sub.ifnn r1, r1, r0     ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+brr.anyn -, r:uvloop 
+asr r1, r1, 15          
+min r1, r1, rb22        
+max vpm, r1, 0
+
+# DMA out for U
+
+mov vw_setup, rb26 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+# DMA out for V
+# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+# Could potentially push this write into the start of the next pipeline stage.
+mov r0, 16
+mov -, vw_wait
+
+bra -, ra31
+add vw_setup, rb26, r0 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+################################################################################
+
+
+# mc_filter(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+mov ra_x2shift, ra_x2shift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+add r2, r0, 8 # x+8
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+shl ra_xshift_next, r0, 3
+max r2, r2, 0
+min r2, r2, rb_frame_width_minus_1
+shl ra_x2shift_next, r2, 3
+add r0, r0, r3
+add r2, r2, r3
+and rb_x_base_next, r0, ~3 
+and ra_x2_base_next, r2, ~3
+mov ra_y_next, r1
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+brr.anynn -, r:fast_path
+asr rb12, r0, rb23  # delay slot 1
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 # delay slot 2
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+## nop                                                                 ; ldtmu0     # loop counter increment
+## shr r0, r4, ra17                                                    ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21         ; mul24 r3, r0, ra0
+## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15                  
+## sub r2, r2, r3                                                    ; ldtmu0
+## 
+## mov r0, ra22
+## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # apply horizontal filter
+## 
+## asr r2, r2, 15    ; mul24 r3, r0, ra0
+## min r2, r2, rb22
+## max ra13, r2, 0
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21         
+## sub r2, r2, r3 ; mul24      r3, ra1 << 1, r0 << 1
+## nop            ; mul24.ifnz r3, ra1 << 9, r1 << 9
+## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
+## nop            ; mul24.ifnz r3, ra2 << 10, r1 << 10
+## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
+## nop            ; mul24.ifnz r3, ra3 << 11, r1 << 11
+## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
+## nop            ; mul24.ifnz r3, ra4 << 12, r1 << 12
+## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
+## nop            ; mul24.ifnz r3, ra5 << 13, r1 << 13
+## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
+## nop            ; mul24.ifnz r3, ra6 << 14, r1 << 14
+## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
+## nop            ; mul24.ifnz r3, ra7 << 15, r1 << 15
+## sub r0, r2, r3
+## 
+## # apply horizontal filter
+## 
+## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+## asr r0, r0, 15
+## min r0, r0, rb22
+## max ra14, r0, 0
+## 
+## 
+## 
+## 
+## nop                                                                 ; ldtmu0     # loop counter increment
+## shr r0, r4, ra17                                                    ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21         ; mul24 r3, r0, ra0
+## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+## sub r0, r2, r3
+## 
+## # apply horizontal filter
+## 
+## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+## asr r0, r0, 15
+## min r0, r0, rb22
+## max ra15, r0, 0
+
+
+
+
+mov r3, 0
+
+:loop
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:loop
+max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr r0, r0, 15          ; mov r1, ra21
+min.setf ra15, r0, rb22
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r0, ra14, rb14
+sub r1, r1, r0          ; mul24 r0, ra13, rb13
+sub r1, r1, r0          ; mul24 r0, ra12, rb12
+sub r1, r1, r0          ; mul24 r0, ra11, rb11
+sub r1, r1, r0          ; mul24 r0, ra10, rb10
+sub r1, r1, r0          ; mul24 r0, ra9, rb9
+sub r1, r1, r0          ; mul24 r0, ra8, rb8
+sub r1, r1, r0          ; mul24 r0, ra15, rb15
+sub.ifnn r1, r1, r0     ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+brr.anyn -, r:loop 
+asr r1, r1, 15          
+min r1, r1, rb22        
+max vpm, r1, 0
+
+# DMA out
+
+bra -, ra31
+mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+mov vw_setup, rb29
+mov vw_addr, unif # start the VDW
+
+####################################################
+
+:fast_path
+## nop                                                                 ; ldtmu0     # loop counter increment
+## shr r0, r4, ra17                                                    ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21         ; mul24 r3, r0, ra0
+## sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
+## sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
+## sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
+## sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
+## sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
+## sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
+## sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
+## sub r2, r2, r3                                                    ; ldtmu0
+## 
+## mov r0, ra22
+## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # apply horizontal filter
+## 
+## asr r2, r2, 15    ; mul24 r3, r0, ra0
+## min r2, r2, rb22
+## max ra13, r2, 0
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21         
+## sub r2, r2, r3 ; mul24    r3, ra1 << 1, r0 << 1
+## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
+## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
+## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
+## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
+## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
+## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
+## sub r0, r2, r3
+## 
+## # apply horizontal filter
+## 
+## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+## asr r0, r0, 15
+## min r0, r0, rb22
+## max ra14, r0, 0
+## 
+## 
+## 
+## 
+## nop                                                                 ; ldtmu0     # loop counter increment
+## shr r0, r4, ra17                                                    ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21   ; mul24    r3, r0, ra0
+## sub r2, r2, r3 ; mul24    r3, ra1 << 1, r0 << 1
+## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
+## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
+## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
+## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
+## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
+## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
+## sub r0, r2, r3
+## 
+## # apply horizontal filter
+## 
+## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+## asr r0, r0, 15
+## min r0, r0, rb22
+## max ra15, r0, 0
+
+
+mov r3, 0  # This signifies the amount of unrolling
+
+:fast_loop
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+# Due to pipelining we can only skip second pipeline instructions related to the fetched pixels
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_y, ra_y_next   ; mov rb31, r3
+mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch   
+
+max r2, ra_y, 0           
+min r2, r2, rb_frame_height_minus_1 ; mov r1, r4  # discard texture read
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20                                     
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
+sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
+sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
+sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
+sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
+sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
+sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
+sub r0, r2, r3       ; mov r3, rb31
+
+mov ra8, ra9         
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8       ; mov r1, ra22
+
+# apply horizontal filter                   
+                    
+brr.anyn -, r:fast_loop
+max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr r0, r0, 15          ; mov r1, ra21
+min.setf ra15, r0, rb22
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r0, ra14, rb14
+sub r1, r1, r0          ; mul24 r0, ra13, rb13
+sub r1, r1, r0          ; mul24 r0, ra12, rb12
+sub r1, r1, r0          ; mul24 r0, ra11, rb11
+sub r1, r1, r0          ; mul24 r0, ra10, rb10
+sub r1, r1, r0          ; mul24 r0, ra9, rb9
+sub r1, r1, r0          ; mul24 r0, ra8, rb8
+sub r1, r1, r0          ; mul24 r0, ra15, rb15
+sub.ifnn r1, r1, r0     ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+brr.anyn -, r:fast_loop 
+asr r1, r1, 15          
+min r1, r1, rb22        
+max vpm, r1, 0
+
+# DMA out
+
+bra -, ra31
+mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+mov vw_setup, rb29
+mov vw_addr, unif # start the VDW
+
+################################################################################
+
+# mc_filter_b(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter_b
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+mov ra_x2shift, ra_x2shift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+add r2, r0, 8 # x+8
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+shl ra_xshift_next, r0, 3
+max r2, r2, 0
+min r2, r2, rb_frame_width_minus_1
+shl ra_x2shift_next, r2, 3
+add r0, r0, r3
+add r2, r2, r3
+and rb_x_base_next, r0, ~3 
+and ra_x2_base_next, r2, ~3
+mov ra_y_next, r1
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+# r0 is currently height<<7
+# For vr_setup we want height<<20 (so 20-7=13 additional bits)
+shl r3, r0, 13 
+shl r3, r3, 8 # Mask off top 8 bits
+shr r3, r3, 8
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+# In a B frame, so also set up VPM read
+add vr_setup, r3, rb28
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+asr rb12, r0, rb23
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  
+mov r3, 0
+
+:bloop
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:bloop
+max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr r0, r0, 15          ; mov r1, ra21
+min.setf ra15, r0, rb22
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r0, ra14, rb14
+sub r1, r1, r0          ; mul24 r0, ra13, rb13
+sub r1, r1, r0          ; mul24 r0, ra12, rb12
+sub r1, r1, r0          ; mul24 r0, ra11, rb11
+sub r1, r1, r0          ; mul24 r0, ra10, rb10
+sub r1, r1, r0          ; mul24 r0, ra9, rb9
+sub r1, r1, r0          ; mul24 r0, ra8, rb8
+sub r1, r1, r0          ; mul24 r0, ra15, rb15
+sub.ifnn r1, r1, r0     ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+asr r1, r1, 15          ; mov -, vr_wait         
+min r1, r1, rb22        
+add r0, vpm, 1          # Blend in previous VPM contents at this location
+brr.anyn -, r:bloop 
+max r1, r1, 0
+add r1, r1, r0
+shr vpm, r1, 1
+
+# DMA out
+
+bra -, ra31
+mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+mov vw_setup, rb29
+mov vw_addr, unif # start the VDW
+
+################################################################################
+
+# mc_filter_honly(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+# This filter only does horizontal filtering.
+# It is assumed that the region to fetch does not include extra rows above.
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter_honly
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+mov ra_x2shift, ra_x2shift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+add r2, r0, 8 # x+8
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+shl ra_xshift_next, r0, 3
+max r2, r2, 0
+min r2, r2, rb_frame_width_minus_1
+shl ra_x2shift_next, r2, 3
+add r0, r0, r3
+add r2, r2, r3
+and rb_x_base_next, r0, ~3 
+and ra_x2_base_next, r2, ~3
+mov ra_y_next, r1
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, -2 # Pipelining means we move data across 2 iterations early
+shl r0, r0, 7 ; mov rb18,r0
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+mov r0, unif
+
+# r2 is elem_num
+# r3 is loop counter
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
+mov r3, 0
+
+:loop_honly
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3       ; mov r3, rb31
+
+sub.setf -, r3, rb18 ; mov r1, ra22
+
+mov -, vw_wait   ; mul24 r0, r0, r1  
+brr.anyn -, r:loop_honly     
+asr r0, r0, 15          # delay 1     
+min r0, r0, rb22        # delay 2
+max vpm, r0, 0          # delay 3
+ 
+# DMA out
+bra -, ra31
+mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+mov vw_setup, rb29
+mov vw_addr, unif # start the VDW
+
+
+################################################################################
+
+# mc_exit()
+
+::mc_exit
+mov  -, vw_wait # wait on the VDW
+
+mov -,srel(0)
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+nop        ; nop ; thrend
+nop        ; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+::mc_exit1 
+mov  -, vw_wait # wait on the VDW
+
+#mov -,srel(1)
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+# mc_interrupt_exit()
+::mc_interrupt_exit 
+mov  -, vw_wait # wait on the VDW
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+mov -,sacq(0) # 1 
+mov -,sacq(0) # 2 
+mov -,sacq(0) # 3 
+mov -,sacq(0) # 4 
+mov -,sacq(0) # 5 
+mov -,sacq(0) # 6 
+mov -,sacq(0) # 7 
+mov -,sacq(0) # 8 
+mov -,sacq(0) # 9 
+mov -,sacq(0) # 10
+mov -,sacq(0) # 11
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+# mc_interrupt_exit4()
+::mc_interrupt_exit4 
+mov  -, vw_wait # wait on the VDW
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+mov -,sacq(0) # 1 
+mov -,sacq(0) # 2 
+mov -,sacq(0) # 3 
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+# mc_interrupt_exit8()
+::mc_interrupt_exit8 
+mov  -, vw_wait # wait on the VDW
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+mov -,sacq(0) # 1 
+mov -,sacq(0) # 2 
+mov -,sacq(0) # 3 
+mov -,sacq(0) # 4 
+mov -,sacq(0) # 5 
+mov -,sacq(0) # 6 
+mov -,sacq(0) # 7 
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+################################################################################
+# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
+::mc_setup_uv
+
+# Read starting kernel
+mov ra31, unif
+
+# Load first request location
+add ra_x_base, unif, elem_num # Store x
+mov ra_y, unif # Store y
+mov ra_x2_base, unif # Store frame u base
+nop
+sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
+
+# Read image dimensions
+sub rb25,unif,1
+sub rb30,unif,1
+
+# get source pitch
+mov rb16, unif
+
+# get destination pitch
+mov r0, unif
+mov r1, vdw_setup_1(0)
+add rb24, r1, r0
+
+# load constants
+
+mov ra20, 1
+mov ra21, 64
+mov ra22, 256
+mov ra23, 8
+
+mov rb20, 0xffffff00
+mov rb21, 64
+mov rb22, 255
+mov rb23, 24
+
+# touch vertical context to keep simulator happy
+
+mov ra8, 0
+mov ra9, 0
+mov ra10, 0    
+mov ra11, 0
+mov ra12, 0    
+mov ra13, 0
+mov ra14, 0    
+mov ra15, 0
+
+# Compute part of VPM to use for DMA output
+mov r2, qpu_num
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+shl r0, r0, 5
+add rb27, r0, r1
+
+# Compute part of VPM to save data into
+mov r2, qpu_num
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vpm_setup(0, 4, h8p(0, 0))
+add rb28, r0, r1 
+
+# Compute base address for first and second access
+mov r0, ra_x_base           # Load x
+max r0, r0, 0; mov r1, ra_y # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
+shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+add ra_y, r1, 1
+add r0, r0, r3
+and r0, r0, ~3
+max r1, r1, 0 ; mov ra_x_base, r0 # y
+min r1, r1, rb_frame_height_minus_1
+# submit texture requests for first line
+add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+add t0s, r0, r1 ; mov ra_x2_base, r2
+add t0s, r2, r1
+
+# Dump padding words
+mov r0, unif
+mov r0, unif
+mov r0, unif
+
+# submit texture requests for second line
+max r1, ra_y, 0
+min r1, r1, rb_frame_height_minus_1
+add ra_y, ra_y, 1
+bra -, ra31
+nop ; mul24 r1, r1, rb_pitch
+add t0s, r1, ra_x_base
+add t0s, r1, ra_x2_base
+
+
+
+################################################################################
+
+::mc_filter_uv_b
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+shl ra_xshift_next, r0, 3
+sub r2, unif, r3 # compute offset from frame base u to frame base v
+add r0, r0, r3
+and rb_x_base_next, r0, ~3 
+mov ra_y_next, r1
+add ra_x2_base_next, rb_x_base_next, r2
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+
+# r0 is currently height<<7
+# For vr_setup we want height<<20 (so 20-7=13 additional bits)
+shl r3, r0, 13 
+shl r3, r3, 8 # Mask off top 8 bits
+shr r3, r3, 8
+
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+# In a B frame, so also set up VPM read
+add vr_setup, r3, rb28
+
+sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+asr rb12, r0, rb23  
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+mov r3, 0
+
+:uvloop_b
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:uvloop_b
+max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr r0, r0, 15          ; mov r1, ra21
+min.setf ra15, r0, rb22
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r0, ra14, rb14
+sub r1, r1, r0          ; mul24 r0, ra13, rb13
+sub r1, r1, r0          ; mul24 r0, ra12, rb12
+sub r1, r1, r0          ; mul24 r0, ra11, rb11
+sub r1, r1, r0          ; mul24 r0, ra10, rb10
+sub r1, r1, r0          ; mul24 r0, ra9, rb9
+sub r1, r1, r0          ; mul24 r0, ra8, rb8
+sub r1, r1, r0          ; mul24 r0, ra15, rb15
+sub.ifnn r1, r1, r0     ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+asr r1, r1, 15          
+min r1, r1, rb22        
+add r0, vpm, 1          # Blend in previous VPM contents at this location
+brr.anyn -, r:uvloop_b
+max r1, r1, 0
+add r1, r1, r0
+shr vpm, r1, 1
+
+
+# DMA out for U
+
+mov vw_setup, rb26 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+# DMA out for V
+# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+# Could potentially push this write into the start of the next pipeline stage.
+mov r0, 16
+mov -, vw_wait
+
+bra -, ra31
+add vw_setup, rb26, r0 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+::mc_end
diff --git a/libavcodec/rpi_user_vcsm.h b/libavcodec/rpi_user_vcsm.h
new file mode 100644
index 0000000..cdc4e4d
--- /dev/null
+++ b/libavcodec/rpi_user_vcsm.h
@@ -0,0 +1,426 @@
+/*
+Copyright (c) 2012, Broadcom Europe Ltd
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef __USER_VCSM__H__INCLUDED__
+#define __USER_VCSM__H__INCLUDED__
+
+/* VideoCore Shared Memory - user interface library.
+**
+** This library provides all the necessary abstraction for any application to
+** make use of the shared memory service which is distributed accross a kernel
+** driver and a videocore service.
+**
+** It is an application design decision to choose or not to use this service.
+**
+** The logical flow of operations that a user application needs to follow when
+** using this service is:
+**
+**       1) Initialize the service.
+**       2) Allocate shared memory blocks.
+**       3) Start using the allocated blocks.
+**          - In order to gain ownership on a block, lock the allocated block,
+**            locking a block returns a valid address that the user application
+**            can access.
+**          - When finished with using the block for the current execution cycle
+**            or function, and so when giving up the ownership, unlock the block.
+**       4) A block can be locked/unlocked as many times required - within or outside
+**          of - a specific execution context.
+**       5) To completely release an allocated block, free it.
+**       6) If the service is no longer required, terminate it.
+**
+**
+** Some generic considerations:
+
+** Allocating memory blocks.
+**
+**   Memory blocks can be allocated in different manners depending on the cache
+**   behavior desired.  A given block can either be:
+
+**       - Allocated in a non cached fashion all the way through host and videocore.
+**       - Allocated in a cached fashion on host OR videocore.
+**       - Allocated in a cached fashion on host AND videocore.
+**
+**   It is an application decision to determine how to allocate a block.  Evidently
+**   if the application will be doing substantial read/write accesses to a given block,
+**   it is recommended to allocate the block at least in a 'host cached' fashion for
+**   better results.
+**
+**
+** Locking memory blocks.
+**
+**   When the memory block has been allocated in a host cached fashion, locking the
+**   memory block (and so taking ownership of it) will trigger a cache invalidation.
+**
+**   For the above reason and when using host cached allocation, it is important that
+**   an application properly implements the lock/unlock mechanism to ensure cache will
+**   stay coherent, otherwise there is no guarantee it will at all be.
+**
+**   It is possible to dynamically change the host cache behavior (ie cached or non
+**   cached) of a given allocation without needing to free and re-allocate the block.
+**   This feature can be useful for such application which requires access to the block
+**   only at certain times and not otherwise.  By changing the cache behavior dynamically
+**   the application can optimize performances for a given duration of use.
+**   Such dynamic cache behavior remapping only applies to host cache and not videocore
+**   cache.  If one requires to change the videocore cache behavior, then a new block
+**   must be created to replace the old one.
+**
+**   On successful locking, a valid pointer is returned that the application can use
+**   to access to data inside the block.  There is no guarantee that the pointer will
+**   stay valid following the unlock action corresponding to this lock.
+**
+**
+** Unocking memory blocks.
+**
+**   When the memory block has been allocated in a host cached fashion, unlocking the
+**   memory block (and so forgiving its ownership) will trigger a cache flush unless
+**   explicitely asked not to flush the cache for performances reasons.
+**
+**   For the above reason and when using host cached allocation, it is important that
+**   an application properly implements the lock/unlock mechanism to ensure cache will
+**   stay coherent, otherwise there is no guarantee it will at all be.
+**
+**
+** A complete API is defined below.
+*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Different status that can be dumped.
+*/
+typedef enum
+{
+   VCSM_STATUS_VC_WALK_ALLOC = 0,   // Walks *all* the allocation on videocore.
+                                    // Result of the walk is seen in the videocore
+                                    // log.
+   VCSM_STATUS_HOST_WALK_MAP,       // Walks the *full* mapping allocation on host
+                                    // driver (ie for all processes).  Result of
+                                    // the walk is seen in the kernel log.
+   VCSM_STATUS_HOST_WALK_PID_MAP,   // Walks the per process mapping allocation on host
+                                    // driver (for current process).  Result of
+                                    // the walk is seen in the kernel log.
+   VCSM_STATUS_HOST_WALK_PID_ALLOC, // Walks the per process host allocation on host
+                                    // driver (for current process).  Result of
+                                    // the walk is seen in the kernel log.
+   VCSM_STATUS_VC_MAP_ALL,          // Equivalent to both VCSM_STATUS_VC_WALK_ALLOC and
+                                    // VCSM_STATUS_HOST_WALK_MAP.
+                                    //
+   VCSM_STATUS_NONE,                // Must be last - invalid.
+
+} VCSM_STATUS_T;
+
+/* Different kind of cache behavior.
+*/
+typedef enum
+{
+   VCSM_CACHE_TYPE_NONE = 0,        // No caching applies.
+   VCSM_CACHE_TYPE_HOST,            // Allocation is cached on host (user space).
+   VCSM_CACHE_TYPE_VC,              // Allocation is cached on videocore.
+   VCSM_CACHE_TYPE_HOST_AND_VC,     // Allocation is cached on both host and videocore.
+
+} VCSM_CACHE_TYPE_T;
+
+/* Initialize the vcsm processing.
+**
+** Must be called once before attempting to do anything else.
+**
+** Returns 0 on success, -1 on error.
+*/
+int vcsm_init( void );
+
+
+/* Terminates the vcsm processing.
+**
+** Must be called vcsm services are no longer needed, it will
+** take care of removing any allocation under the current process
+** control if deemed necessary.
+*/
+void vcsm_exit( void );
+
+
+/* Queries the status of the the vcsm.
+**
+** Triggers dump of various kind of information, see the
+** different variants specified in VCSM_STATUS_T.
+**
+** Pid is optional.
+*/
+void vcsm_status( VCSM_STATUS_T status, int pid );
+
+
+/* Allocates a non-cached block of memory of size 'size' via the vcsm memory
+** allocator.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** On success, the user must invoke vcsm_lock with the returned opaque
+** handle to gain access to the memory associated with the opaque handle.
+** When finished using the memory, the user calls vcsm_unlock_xx (see those
+** function definition for more details on the one that can be used).
+** 
+** A well behaved application should make every attempt to lock/unlock
+** only for the duration it needs to access the memory data associated with
+** the opaque handle.
+*/
+unsigned int vcsm_malloc( unsigned int size, char *name );
+
+
+/* Allocates a cached block of memory of size 'size' via the vcsm memory
+** allocator, the type of caching requested is passed as argument of the
+** function call.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** On success, the user must invoke vcsm_lock with the returned opaque
+** handle to gain access to the memory associated with the opaque handle.
+** When finished using the memory, the user calls vcsm_unlock_xx (see those
+** function definition for more details on the one that can be used).
+** 
+** A well behaved application should make every attempt to lock/unlock
+** only for the duration it needs to access the memory data associated with
+** the opaque handle.
+*/
+unsigned int vcsm_malloc_cache( unsigned int size, VCSM_CACHE_TYPE_T cache, char *name );
+
+
+/* Shares an allocated block of memory via the vcsm memory allocator.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** On success, the user must invoke vcsm_lock with the returned opaque
+** handle to gain access to the memory associated with the opaque handle.
+** When finished using the memory, the user calls vcsm_unlock_xx (see those
+** function definition for more details on the one that can be used).
+**
+** A well behaved application should make every attempt to lock/unlock
+** only for the duration it needs to access the memory data associated with
+** the opaque handle.
+*/
+unsigned int vcsm_malloc_share( unsigned int handle );
+
+
+/* Resizes a block of memory allocated previously by vcsm_alloc.
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** The handle must be unlocked by user prior to attempting any
+** resize action.
+**
+** On error, the original size allocated against the handle
+** remains available the same way it would be following a
+** successful vcsm_malloc.
+*/
+int vcsm_resize( unsigned int handle, unsigned int new_size );
+
+
+/* Frees a block of memory that was successfully allocated by
+** a prior call the vcms_alloc.
+**
+** The handle should be considered invalid upon return from this
+** call.
+**
+** Whether any memory is actually freed up or not as the result of
+** this call will depends on many factors, if all goes well it will
+** be freed.  If something goes wrong, the memory will likely end up
+** being freed up as part of the vcsm_exit process.  In the end the
+** memory is guaranteed to be freed one way or another.
+*/
+void vcsm_free( unsigned int handle );
+
+
+/* Retrieves a videocore opaque handle from a mapped user address
+** pointer.  The videocore handle will correspond to the actual
+** memory mapped in videocore.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** Note: the videocore opaque handle is distinct from the user
+**       opaque handle (allocated via vcsm_malloc) and it is only
+**       significant for such application which knows what to do
+**       with it, for the others it is just a number with little
+**       use since nothing can be done with it (in particular
+**       for safety reason it cannot be used to map anything).
+*/
+unsigned int vcsm_vc_hdl_from_ptr( void *usr_ptr );
+
+
+/* Retrieves a videocore opaque handle from a opaque handle
+** pointer.  The videocore handle will correspond to the actual
+** memory mapped in videocore.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** Note: the videocore opaque handle is distinct from the user
+**       opaque handle (allocated via vcsm_malloc) and it is only
+**       significant for such application which knows what to do
+**       with it, for the others it is just a number with little
+**       use since nothing can be done with it (in particular
+**       for safety reason it cannot be used to map anything).
+*/
+unsigned int vcsm_vc_hdl_from_hdl( unsigned int handle );
+
+
+/* Retrieves a user opaque handle from a mapped user address
+** pointer.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+*/
+unsigned int vcsm_usr_handle( void *usr_ptr );
+
+
+/* Retrieves a mapped user address from an opaque user
+** handle.
+**
+** Returns:        0 on error
+**                 a non-zero address on success.
+**
+** On success, the address corresponds to the pointer
+** which can access the data allocated via the vcsm_malloc
+** call.
+*/
+void *vcsm_usr_address( unsigned int handle );
+
+
+/* Locks the memory associated with this opaque handle.
+**
+** Returns:        NULL on error
+**                 a valid pointer on success.
+**
+** A user MUST lock the handle received from vcsm_malloc
+** in order to be able to use the memory associated with it.
+**
+** On success, the pointer returned is only valid within
+** the lock content (ie until a corresponding vcsm_unlock_xx
+** is invoked).
+*/
+void *vcsm_lock( unsigned int handle );
+
+
+/* Locks the memory associated with this opaque handle.  The lock
+** also gives a chance to update the *host* cache behavior of the
+** allocated buffer if so desired.  The *videocore* cache behavior
+** of the allocated buffer cannot be changed by this call and such
+** attempt will be ignored.
+**
+** The system will attempt to honour the cache_update mode request,
+** the cache_result mode will provide the final answer on which cache
+** mode is really in use.  Failing to change the cache mode will not
+** result in a failure to lock the buffer as it is an application
+** decision to choose what to do if (cache_result != cache_update)
+**
+** The value returned in cache_result can only be considered valid if
+** the returned pointer is non NULL.  The cache_result pointer may be
+** NULL if the application does not care about the actual outcome of
+** its action with regards to the cache behavior change.
+**
+** Returns:        NULL on error
+**                 a valid pointer on success.
+**
+** A user MUST lock the handle received from vcsm_malloc
+** in order to be able to use the memory associated with it.
+**
+** On success, the pointer returned is only valid within
+** the lock content (ie until a corresponding vcsm_unlock_xx
+** is invoked).
+*/
+void *vcsm_lock_cache( unsigned int handle,
+                       VCSM_CACHE_TYPE_T cache_update,
+                       VCSM_CACHE_TYPE_T *cache_result );
+
+
+/* Unlocks the memory associated with this user mapped address.
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** After unlocking a mapped address, the user should no longer
+** attempt to reference it.
+*/
+int vcsm_unlock_ptr( void *usr_ptr );
+
+
+/* Unlocks the memory associated with this user mapped address.
+** Apply special processing that would override the otherwise
+** default behavior.
+**
+** If 'cache_no_flush' is specified:
+**    Do not flush cache as the result of the unlock (if cache
+**    flush was otherwise applicable in this case).
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** After unlocking a mapped address, the user should no longer
+** attempt to reference it.
+*/
+int vcsm_unlock_ptr_sp( void *usr_ptr, int cache_no_flush );
+
+
+/* Unlocks the memory associated with this user opaque handle.
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** After unlocking an opaque handle, the user should no longer
+** attempt to reference the mapped addressed once associated
+** with it.
+*/
+int vcsm_unlock_hdl( unsigned int handle );
+
+
+/* Unlocks the memory associated with this user opaque handle.
+** Apply special processing that would override the otherwise
+** default behavior.
+**
+** If 'cache_no_flush' is specified:
+**    Do not flush cache as the result of the unlock (if cache
+**    flush was otherwise applicable in this case).
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** After unlocking an opaque handle, the user should no longer
+** attempt to reference the mapped addressed once associated
+** with it.
+*/
+int vcsm_unlock_hdl_sp( unsigned int handle, int cache_no_flush );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __USER_VCSM__H__INCLUDED__ */
+
-- 
1.9.1


From 21b4c324b6b7681eed533a55712b0ab84247bf40 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@argondesign.com>
Date: Sat, 2 May 2015 21:15:37 +0100
Subject: [PATCH 04/77] First working version with uncached memory

---
 libavcodec/hevc.c               |  61 +++++-
 libavcodec/hevc.h               |  11 +-
 libavcodec/hevc_cabac.c         |  41 +++-
 libavcodec/hevc_filter.c        |  16 ++
 libavcodec/hevcpred_template.c  |   6 +
 libavcodec/rpi_hevc_transform.h | 422 +++++++++++++++++++++++++++++++++++++++-
 libavcodec/rpi_hevc_transform.s | 151 ++++++++++++--
 libavcodec/rpi_qpu.c            |  72 +++++++
 libavcodec/rpi_qpu.h            |   1 +
 9 files changed, 734 insertions(+), 47 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 1cd262d..43edea1 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -43,6 +43,8 @@
 #include "rpi_qpu.h"
 #endif
 
+// #define DISABLE_MC
+
 const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
 
 /**
@@ -1043,11 +1045,15 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                         for (i = 0; i < (size * size); i++) {
                             coeffs[i] = ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
                         }
+                        printf("Cross component not supported\n"); // TODO
+                        exit(-1);
                         s->hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
                     }
             }
 
             if (lc->tu.cross_pf) {
+                printf("Cross component not supported\n"); // TODO
+                exit(-1);        
                 hls_cross_component_pred(s, 1);
             }
             for (i = 0; i < (s->sps->chroma_format_idc == 2 ? 2 : 1); i++) {
@@ -1076,6 +1082,8 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                         for (i = 0; i < (size * size); i++) {
                             coeffs[i] = ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
                         }
+                        printf("Cross component not supported\n"); // TODO
+                        exit(-1);
                         s->hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
                     }
             }
@@ -1372,6 +1380,10 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
     int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
     int idx              = ff_hevc_pel_weight[block_w];
+    
+#ifdef DISABLE_MC
+    return;
+#endif
 
     x_off += mv->x >> 2;
     y_off += mv->y >> 2;
@@ -1442,6 +1454,10 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
 
     uint8_t *src0  = ref0->data[0] + y_off0 * src0stride + (int)((unsigned)x_off0 << s->sps->pixel_shift);
     uint8_t *src1  = ref1->data[0] + y_off1 * src1stride + (int)((unsigned)x_off1 << s->sps->pixel_shift);
+    
+#ifdef DISABLE_MC
+    return;
+#endif
 
     if (x_off0 < QPEL_EXTRA_BEFORE || y_off0 < QPEL_EXTRA_AFTER ||
         x_off0 >= pic_width - block_w - QPEL_EXTRA_AFTER ||
@@ -1527,6 +1543,10 @@ static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
     intptr_t my          = av_mod_uintp2(mv->y, 2 + vshift);
     intptr_t _mx         = mx << (1 - hshift);
     intptr_t _my         = my << (1 - vshift);
+    
+#ifdef DISABLE_MC
+    return;
+#endif   
 
     x_off += mv->x >> (2 + hshift);
     y_off += mv->y >> (2 + vshift);
@@ -1591,6 +1611,10 @@ static void chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVF
     Mv *mv1              = &current_mv->mv[1];
     int hshift = s->sps->hshift[1];
     int vshift = s->sps->vshift[1];
+    
+#ifdef DISABLE_MC
+    return;
+#endif    
 
     intptr_t mx0 = av_mod_uintp2(mv0->x, 2 + hshift);
     intptr_t my0 = av_mod_uintp2(mv0->y, 2 + vshift);
@@ -2331,6 +2355,22 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
 }
 
 #ifdef RPI
+static void rpi_execute_transform(HEVCContext *s)
+{
+    int i=2;
+    //int j;
+    //int16_t *coeffs = s->coeffs_buf_arm[i];
+    //for(j=s->num_coeffs[i]; j > 0; j-= 16*16, coeffs+=16*16) {
+    //    s->hevcdsp.idct[4-2](coeffs, 16);
+    //}
+    
+    //gpu_cache_flush(&s->coeffs_buf[i]);
+    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[i].vc, s->num_coeffs[i] >> 8, 0, 0, 0);
+    
+    for(i=0;i<4;i++)
+        s->num_coeffs[i] = 0;
+}
+
 static void rpi_execute_pred_cmds(HEVCContext *s)
 {
   int i;
@@ -2351,7 +2391,6 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
       }
   }
   s->num_pred_cmds = 0;
-  s->num_coeffs = 0;
 }
 #endif
 
@@ -2398,7 +2437,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 
         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);
 #ifdef RPI
-        if (x_ctb + ctb_size >= s->sps->width) {
+        if (1 || x_ctb + ctb_size >= s->sps->width) { // TODO watch out for deblocking!
+            rpi_execute_transform(s);
             rpi_execute_pred_cmds(s);
         }
 #endif
@@ -3301,7 +3341,9 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
     av_freep(&s->unif_mv_cmds);
     av_freep(&s->unif_xfm_cmds);
     av_freep(&s->univ_pred_cmds);
-    av_freep(&s->coeffs_buf);
+    for(i = 0; i < 4; i++) {
+        gpu_free(&s->coeffs_buf[i]);
+    }
 #endif
 
     for (i = 0; i < 3; i++) {
@@ -3371,13 +3413,16 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
     if (!s->univ_pred_cmds)
         goto fail;
-    s->coeffs_buf = av_mallocz(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16);
-    if (!s->coeffs_buf)
-        goto fail;
+    for(i = 0; i < 4; i++) {
+        gpu_malloc_uncached(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16, &s->coeffs_buf[i]); // TODO slim this down and share across sizes
+        s->coeffs_buf_arm[i] = (int16_t*) s->coeffs_buf[i].arm;
+        if (!s->coeffs_buf_arm[i])
+            goto fail;
+    }
     s->enable_rpi = 0;
     
     // A little test program
-    {
+    /*{
       GPU_MEM_PTR_T p;
       int err = gpu_malloc_cached(16, &p);
       short *q = (short *)p.arm;
@@ -3398,7 +3443,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
       printf(")\n");
       gpu_free(&p);
       goto fail; // Early out
-    }
+    }*/
     
 #endif
 
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 7c58834..9f69412 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -39,6 +39,10 @@
 // define RPI to split the CABAC/prediction/transform into separate stages
 #define RPI
 
+#ifdef RPI
+#include "rpi_qpu.h"
+#endif
+
 #define MAX_DPB_SIZE 16 // A.4.1
 #define MAX_REFS 16
 
@@ -853,11 +857,12 @@ typedef struct HEVCContext {
     HEVCMvCmd *unif_mv_cmds;
     HEVCXfmCmd *unif_xfm_cmds;
     HEVCPredCmd *univ_pred_cmds;
-    int16_t *coeffs_buf;
-    int num_mv_cmds;
+    GPU_MEM_PTR_T coeffs_buf[4];
+    int16_t *coeffs_buf_arm[4];
+    int num_coeffs[4];
     int num_xfm_cmds;
+    int num_mv_cmds;
     int num_pred_cmds;
-    int num_coeffs;
 #endif
 
     uint8_t *cabac_state;
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index df2f5a3..6a37726 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1079,6 +1079,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     int vshift = s->sps->vshift[c_idx];
     uint8_t *dst = &s->frame->data[c_idx][(y0 >> vshift) * stride +
                                           ((x0 >> hshift) << s->sps->pixel_shift)];
+    int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag && !transform_skip_flag && !lc->tu.cross_pf && log2_trafo_size==4;
     int16_t *coeffs = (int16_t*)(c_idx ? lc->edge_emu_buffer2 : lc->edge_emu_buffer);
     uint8_t significant_coeff_group_flag[8][8] = {{0}};
     int explicit_rdpcm_flag = 0;
@@ -1092,6 +1093,18 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     uint8_t dc_scale;
     int pred_mode_intra = (c_idx == 0) ? lc->tu.intra_pred_mode :
                                          lc->tu.intra_pred_mode_c;
+#ifdef RPI
+    if (s->enable_rpi) {
+        int n = trafo_size * trafo_size;
+        if (use_vpu) {
+            coeffs = s->coeffs_buf_arm[log2_trafo_size - 2] + s->num_coeffs[log2_trafo_size - 2];
+            s->num_coeffs[log2_trafo_size - 2] += n;
+        } else {
+            coeffs = s->coeffs_buf_arm[0] + s->num_coeffs[0];
+            s->num_coeffs[0] += n;
+        }
+    }
+#endif
 
     memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
 
@@ -1506,7 +1519,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
             }
         }
     }
-
+    
     if (lc->cu.cu_transquant_bypass_flag) {
         if (explicit_rdpcm_flag || (s->sps->implicit_rdpcm_enabled_flag &&
                                     (pred_mode_intra == 10 || pred_mode_intra == 26))) {
@@ -1536,6 +1549,24 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
         } else if (lc->cu.pred_mode == MODE_INTRA && c_idx == 0 && log2_trafo_size == 2) {
             s->hevcdsp.idct_4x4_luma(coeffs);
         } else {
+#ifdef RPI
+            if (!use_vpu) {
+              int max_xy = FFMAX(last_significant_coeff_x, last_significant_coeff_y);
+              if (max_xy == 0)
+                  s->hevcdsp.idct_dc[log2_trafo_size-2](coeffs);
+              else {
+                  int col_limit = last_significant_coeff_x + last_significant_coeff_y + 4;
+                  if (max_xy < 4)
+                      col_limit = FFMIN(4, col_limit);
+                  else if (max_xy < 8)
+                      col_limit = FFMIN(8, col_limit);
+                  else if (max_xy < 12)
+                      col_limit = FFMIN(24, col_limit);
+
+                  s->hevcdsp.idct[log2_trafo_size-2](coeffs, col_limit);
+              }
+            }
+#else
             int max_xy = FFMAX(last_significant_coeff_x, last_significant_coeff_y);
             if (max_xy == 0)
                 s->hevcdsp.idct_dc[log2_trafo_size-2](coeffs);
@@ -1549,6 +1580,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                     col_limit = FFMIN(24, col_limit);
                 s->hevcdsp.idct[log2_trafo_size-2](coeffs, col_limit);
             }
+#endif
         }
     }
     if (lc->tu.cross_pf) {
@@ -1560,14 +1592,11 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     }
 #ifdef RPI
     if (s->enable_rpi) {
-        int16_t *c = s->coeffs_buf + s->num_coeffs;
-        int n = trafo_size * trafo_size;
         HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
-        memcpy(c, coeffs, n * sizeof(int16_t));  // TODO change pointer earlier and we can avoid this copy
-        s->num_coeffs += n;
+        //memcpy(coeffs2, coeffs, sizeof(int16_t) * trafo_size * trafo_size); // TODO
         cmd->type = RPI_PRED_TRANSFORM_ADD;
         cmd->size = log2_trafo_size;
-        cmd->buf = c;
+        cmd->buf = coeffs;
         cmd->dst = dst;
         cmd->stride = stride;
         return;
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index f50a640..c7fbc75 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -21,6 +21,10 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
+ 
+//#define DISABLE_SAO
+//#define DISABLE_DEBLOCK
+//#define DISABLE_STRENGTHS
 
 #include "libavutil/common.h"
 #include "libavutil/internal.h"
@@ -272,6 +276,10 @@ static void sao_filter_CTB(HEVCContext *s, int x, int y)
     edges[1]   = y_ctb == 0;
     edges[2]   = x_ctb == s->sps->ctb_width  - 1;
     edges[3]   = y_ctb == s->sps->ctb_height - 1;
+    
+#ifdef DISABLE_SAO
+    return;
+#endif
 
     if (restore) {
         if (!edges[0]) {
@@ -495,6 +503,10 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
     int pcmf = (s->sps->pcm_enabled_flag &&
                 s->sps->pcm.loop_filter_disable_flag) ||
                s->pps->transquant_bypass_enable_flag;
+               
+#ifdef DISABLE_DEBLOCK
+    return;
+#endif               
 
     if (x0) {
         left_tc_offset   = s->deblock[ctb - 1].tc_offset;
@@ -725,6 +737,10 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
                            (x0 >> log2_min_pu_size)].pred_flag == PF_INTRA;
     int boundary_upper, boundary_left;
     int i, j, bs;
+    
+#ifdef DISABLE_STRENGTHS
+    return;
+#endif    
 
     boundary_upper = y0 > 0 && !(y0 & 7);
     if (boundary_upper &&
diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
index 6b763b3..d90bdad 100644
--- a/libavcodec/hevcpred_template.c
+++ b/libavcodec/hevcpred_template.c
@@ -19,6 +19,8 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
+ 
+//#define DISABLE_INTRA
 
 #include "libavutil/pixdesc.h"
 
@@ -113,6 +115,10 @@ do {                                  \
                            (y0 + size_in_luma_v)) >> vshift;
     int top_right_size   = (FFMIN(x0 + 2 * size_in_luma_h, s->sps->width) -
                            (x0 + size_in_luma_h)) >> hshift;
+                           
+#ifdef DISABLE_INTRA
+    return;
+#endif                           
 
     if (s->pps->constrained_intra_pred_flag == 1) {
         int size_in_luma_pu_v = PU(size_in_luma_v);
diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
index 85a9102..c0c279f 100644
--- a/libavcodec/rpi_hevc_transform.h
+++ b/libavcodec/rpi_hevc_transform.h
@@ -3,11 +3,11 @@ unsigned char rpi_hevc_transform [] = {
 3,
 3,
 232,
-128,
+32,
 0,
 0,
 0,
-20,
+12,
 248,
 0,
 136,
@@ -56,9 +56,9 @@ unsigned char rpi_hevc_transform [] = {
 5,
 232,
 0,
-0,
 8,
 0,
+0,
 128,
 69,
 113,
@@ -108,8 +108,8 @@ unsigned char rpi_hevc_transform [] = {
 128,
 2,
 0,
-248,
-62,
+8,
+2,
 0,
 128,
 144,
@@ -123,13 +123,13 @@ unsigned char rpi_hevc_transform [] = {
 3,
 32,
 8,
-16,
+20,
 0,
 76,
 254,
 48,
 192,
-9,
+4,
 4,
 32,
 8,
@@ -155,14 +155,46 @@ unsigned char rpi_hevc_transform [] = {
 192,
 41,
 3,
-68,
+70,
+192,
+80,
+7,
+164,
+255,
+36,
+204,
+96,
+2,
+0,
+248,
+62,
+0,
+3,
+255,
+55,
+208,
+120,
+3,
+224,
+3,
+190,
+11,
+16,
+139,
+246,
+91,
+0,
+103,
+90,
+0,
+70,
 192,
 80,
 7,
 164,
 255,
 36,
-220,
+204,
 96,
 2,
 0,
@@ -182,7 +214,7 @@ unsigned char rpi_hevc_transform [] = {
 16,
 139,
 246,
-83,
+91,
 0,
 103,
 90,
@@ -209,4 +241,374 @@ unsigned char rpi_hevc_transform [] = {
 96,
 90,
 0,
+169,
+3,
+3,
+232,
+32,
+0,
+0,
+0,
+12,
+248,
+0,
+136,
+0,
+0,
+192,
+248,
+0,
+0,
+64,
+232,
+0,
+2,
+0,
+0,
+12,
+248,
+0,
+168,
+0,
+0,
+192,
+248,
+0,
+0,
+3,
+232,
+128,
+0,
+0,
+0,
+7,
+232,
+0,
+2,
+0,
+0,
+4,
+232,
+64,
+0,
+0,
+0,
+5,
+232,
+0,
+8,
+0,
+0,
+57,
+239,
+224,
+247,
+255,
+255,
+72,
+192,
+95,
+207,
+88,
+122,
+88,
+124,
+137,
+64,
+26,
+64,
+161,
+64,
+152,
+64,
+128,
+144,
+31,
+0,
+72,
+232,
+32,
+0,
+0,
+0,
+65,
+232,
+32,
+0,
+0,
+0,
+128,
+144,
+23,
+0,
+145,
+64,
+168,
+64,
+128,
+144,
+19,
+0,
+72,
+232,
+32,
+0,
+0,
+0,
+65,
+232,
+32,
+0,
+0,
+0,
+128,
+144,
+11,
+0,
+74,
+232,
+0,
+8,
+0,
+0,
+242,
+140,
+229,
+192,
+57,
+239,
+32,
+8,
+0,
+0,
+41,
+3,
+12,
+248,
+0,
+128,
+0,
+0,
+192,
+8,
+4,
+0,
+12,
+248,
+0,
+132,
+64,
+0,
+192,
+8,
+4,
+0,
+0,
+96,
+255,
+159,
+131,
+255,
+0,
+232,
+0,
+4,
+0,
+0,
+255,
+159,
+142,
+255,
+4,
+255,
+48,
+204,
+16,
+3,
+224,
+251,
+62,
+0,
+5,
+255,
+51,
+204,
+128,
+3,
+224,
+251,
+16,
+0,
+77,
+254,
+51,
+204,
+9,
+4,
+224,
+251,
+0,
+0,
+128,
+64,
+6,
+232,
+64,
+0,
+0,
+0,
+140,
+248,
+47,
+0,
+0,
+0,
+224,
+99,
+0,
+0,
+4,
+254,
+0,
+144,
+128,
+2,
+0,
+8,
+2,
+0,
+32,
+247,
+240,
+207,
+16,
+3,
+32,
+247,
+176,
+207,
+17,
+3,
+32,
+247,
+112,
+207,
+18,
+3,
+32,
+247,
+48,
+207,
+19,
+3,
+32,
+247,
+240,
+206,
+20,
+3,
+32,
+247,
+176,
+206,
+21,
+3,
+32,
+247,
+112,
+206,
+22,
+3,
+32,
+247,
+48,
+206,
+23,
+3,
+32,
+247,
+240,
+205,
+24,
+3,
+32,
+247,
+176,
+205,
+25,
+3,
+32,
+247,
+112,
+205,
+26,
+3,
+32,
+247,
+48,
+205,
+27,
+3,
+32,
+247,
+240,
+204,
+28,
+3,
+32,
+247,
+176,
+204,
+29,
+3,
+32,
+247,
+112,
+204,
+30,
+3,
+32,
+247,
+48,
+204,
+31,
+3,
+5,
+255,
+51,
+204,
+128,
+3,
+224,
+251,
+16,
+0,
+77,
+254,
+51,
+204,
+9,
+4,
+224,
+251,
+0,
+0,
+0,
+237,
+0,
+4,
+0,
+0,
+140,
+248,
+47,
+0,
+0,
+0,
+224,
+99,
+0,
+0,
+90,
+0,
 };
diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
index 74b7d07..edefb51 100644
--- a/libavcodec/rpi_hevc_transform.s
+++ b/libavcodec/rpi_hevc_transform.s
@@ -57,13 +57,6 @@
 #   For 8x8 we could compute two in parallel.
 #
 #
-
-test_add:
-  vldh HX(0,0),(r0)
-  vadd HX(0,0),HX(0,0),10
-  vsth HX(0,0),(r0)
-  mov r0,7 # return value
-  b lr
   
 # Columns are transformed first
 #
@@ -79,7 +72,7 @@ test_add:
 #
 
   
-# hevc_trans_16x16(short *transMatrix2, short *coeffs, int num)
+# hevc_trans_16x16(short *transMatrix2, short *coeffs, int num) # TODO add size so we can branch to correct implementation (or perhaps have coeffs32 and num32 as secondary inputs!)
 # transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory)
 # coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
 # num: number of 16x16 transforms to be done
@@ -87,17 +80,17 @@ test_add:
 hevc_trans_16x16:
   push r6-r15, lr # TODO cut down number of used registers
   
-  mov r3, 2*32*2 # Twice Stride of transMatrix2 in bytes
-  vld HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
+  mov r3, 16*2 # Stride of transMatrix2 in bytes
+  vldh HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
   # Now use r0 to describe which matrix we are working on.
   # Allows us to prefetch the next block of coefficients for efficiency.
   mov r0,0 # This describes the location where we read our coefficients from
-  mov r3,16*2 # Stride of coefficients in bytes
+  mov r3,16*2 # Stride of coefficients in bytes (TODO remove)
   mov r7,16*16*2 # Total block size
   mov r8,64*16 # Value used to swap from current to next VRF location
   vldh HX(0++,0)+r0,(r1 += r3) REP 16 
   mov r4,64 # Constant used for rounding first pass
-  mov r5,1<<19 # Constant used for rounding second pass
+  mov r5,1<<11 # Constant used for rounding second pass
   
   # At start of block r0,r1 point to the current block (that has already been loaded)
 block_loop:
@@ -113,12 +106,12 @@ block_loop:
   vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
   #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
   vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
-  vmov VX(0,0++), HX(0++,32) REP 16          # For simplicity transpose this back to the original position
+  vmov VX(0,0++)+r0, HX(0++,32)+r0 REP 16    # For simplicity transpose this back to the original position
   
   bl col_trans_16
-  vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
-  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
-  vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
+  vadd HY(0++,0)+r0,HY(0++,0)+r0,r5 REP 16   # Now add on rounding, shift down by 7, and saturate
+  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16 # 4+12=16 so this ends up with the output saturated and in the top half of the word.
+  vasl HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16    # This should be saturating, but the instruction above does not assemble?
   
   # Save results - note there has been a transposition during the processing so we save columns
   vsth VX(0,32++)+r0, (r1 += r3) REP 16 
@@ -132,18 +125,136 @@ block_loop:
   
 # r1,r2,r3 r7,r8 should be preserved
 # HX(0++,0)+r0 is the block to be transformed
-# HX(32++,0) is the 16x16 matrix of transform coefficients
+# HX(32++,0)+r6 is the 16x16 matrix of transform coefficients
 # Use HY(48,0) for intermediate results
 # r0 can be used, but should be returned to its original value at the end
 col_trans_16:
-  add r4,r0,16 # Final value for this loop
+  add r6,r0,16 # Final value for this loop
 col_trans_16_loop:
   # First compute partial products for a single column
-  vmul32s VY(48,0++), VX(0,0)+r0, VX(32,0++) REP 16
+  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,0++) REP 16
   # Then sum up the results and place back 
   vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
-  addcmpblt r0,1,r4,col_trans_16_loop
+  addcmpblt r0,1,r6,col_trans_16_loop
   sub r0,16  # but r0 back to its original value
   b lr
   
+col_trans_odd_16:
+  add r6,r0,16 # Final value for this loop
+col_trans_odd_16_loop:
+  # First compute partial products for a single column
+  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,0++) REP 16
+  # Then sum up the results and place back 
+  vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
+  addcmpblt r0,1,r6,col_trans_odd_16_loop
+  sub r0,16  # but r0 back to its original value
+  b lr
+  
+  
+test_add:
+  vldh HX(0,0),(r0)
+  vadd HX(0,0),HX(0,0),10
+  vsth HX(0,0),(r0)
+  mov r0,7 # return value
+  b lr
+
+# hevc_trans_32x32(short *transMatrix2, short *coeffs, int num)
+# transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory) Even followed by odd
+# coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
+# num: number of 16x16 transforms to be done
+#
+hevc_trans_32x32:
+  push r6-r15, lr # TODO cut down number of used registers
+  
+  # Fetch transform matrices
+  mov r3, 16*2 # Stride of transMatrix2 in bytes (and of coefficients)
+  vldh HX(32++,0),(r0 += r3) REP 16 # This is the even 16x16 matrix
+  add r0, 16*16*2
+  vldh HX(32++,32),(r0 += r3) REP 16 # This is the odd 16x16 matrix
+  
+  mov r3, 32*2*2 # Stride used to fetch alternate rows of our input coefficient buffer
+  mov r7, 16*16*2 # Total block size
+  mov r4, 64 # Constant used for rounding first pass
+  mov r5, 1<<11 # Constant used for rounding second pass
+  sub sp,sp,32*32*2+32 # Allocate some space on the stack for us to store 32*32 shorts as temporary results (needs to be aligned)
+  # set r8 to 32byte aligned stack pointer
+  add r8,sp,31
+  lsr r8,5
+  lsl r8,5
+  mov r9,r8  # Backup of the temporary storage
+  mov r10,r1 # Backup of the coefficient buffer
+block_loop32:
 
+  # COLUMN TRANSFORM
+  # Transform the first 16 columns
+  mov r1,r10  # Input Coefficient buffer
+  mov r8,r9   # Output temporary storage
+  bl trans32
+  # Transform the second 16 columns
+  add r8,32
+  add r1,32
+  bl trans32
+  
+  # ROW TRANSFORM
+  mov r1,r9  # Input temporary storage 
+  mov r8,r10   # Output Coefficient buffer
+  bl trans32
+  # Transform the second 16 columns
+  add r8,32
+  add r1,32
+  bl trans32
+     
+  add r10, 32*32*2 # move onto next block of coefficients
+  addcmpbgt r2,-1,0,block_loop32
+  
+  add sp,sp,32*32*2+32 # Restore stack
+  
+  pop r6-r15, pc
+  
+trans32:
+  # We can no longer afford the VRF space to do prefetching when doing 32x32
+  # Fetch the even rows
+  vldh HX(0++,0)+r0,(r1 += r3) REP 16
+  # Fetch the odd rows
+  vldh HX(16++,0)+r0,64(r1 += r3) REP 16 # First odd row is 32 shorts ahead of r1
+  
+  # Transform the even rows using even matrix
+  mov r0, 0 # Even rows
+  bl col_trans_16
+  
+  # Now transform the odd rows using odd matrix
+  mov r0, 64*16 # Odd rows
+  bl col_trans_odd_16
+  
+  # Now apply butterfly to compute the first 16 results
+  vadd HY(48++,0),HY(0++,0),HY(16++,0) REP 16
+  vadd HY(48++,0),HY(48++,0),r4 REP 32   # add on rounding, 
+  vasl HY(48++,0),HY(48++,0),9 REP 32    # shift down by 7, and saturate
+  # 16bit results now in HX(48,32)
+  mov r0,r8
+  mov r6,32*2
+  vsth VX(48,32++),(r0+=r6) REP 16
+  vmov VX(0,0++)+r0, HX(0++,32)+r0 REP 16    # Store transposed
+  
+  # Now apply butterfly to compute the second 16 results (in reverse order)
+  vsub HY(63,0),HY(0,0),HY(16,0)
+  vsub HY(62,0),HY(0,0),HY(17,0)
+  vsub HY(61,0),HY(0,0),HY(18,0)
+  vsub HY(60,0),HY(0,0),HY(19,0)
+  vsub HY(59,0),HY(0,0),HY(20,0)
+  vsub HY(58,0),HY(0,0),HY(21,0)
+  vsub HY(57,0),HY(0,0),HY(22,0)
+  vsub HY(56,0),HY(0,0),HY(23,0)
+  vsub HY(55,0),HY(0,0),HY(24,0)
+  vsub HY(54,0),HY(0,0),HY(25,0)
+  vsub HY(53,0),HY(0,0),HY(26,0)
+  vsub HY(52,0),HY(0,0),HY(27,0)
+  vsub HY(51,0),HY(0,0),HY(28,0)
+  vsub HY(50,0),HY(0,0),HY(29,0)
+  vsub HY(49,0),HY(0,0),HY(30,0)
+  vsub HY(48,0),HY(0,0),HY(31,0)
+  vadd HY(48++,0),HY(48++,0),r4 REP 32   # add on rounding, 
+  vasl HY(48++,0),HY(48++,0),9 REP 32    # shift down by 7, and saturate
+  add r0,r8,16*32*2 # Move to 16th row
+  vsth VX(48,32++),(r0+=r6) REP 16
+  b lr
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 1609e31..479ae88 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -2,6 +2,7 @@
 // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
 #define RPI_USE_VCSM
 #define RPI_TIME_TOTAL_QPU
+#define RPI_TIME_TOTAL_VPU
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -45,10 +46,47 @@ typedef int int32_t;
 #define QPU_CODE_SIZE 2048
 #define VPU_CODE_SIZE 2048
 
+const short rpi_transMatrix2even[32][16] = { // Even rows first
+{64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64},
+{90,  87,  80,  70,  57,  43,  25,   9,  -9, -25, -43, -57, -70, -80, -87, -90},
+{89,  75,  50,  18, -18, -50, -75, -89, -89, -75, -50, -18,  18,  50,  75,  89},
+{87,  57,   9, -43, -80, -90, -70, -25,  25,  70,  90,  80,  43,  -9, -57, -87},
+{83,  36, -36, -83, -83, -36,  36,  83,  83,  36, -36, -83, -83, -36,  36,  83},
+{80,   9, -70, -87, -25,  57,  90,  43, -43, -90, -57,  25,  87,  70,  -9, -80},
+{75, -18, -89, -50,  50,  89,  18, -75, -75,  18,  89,  50, -50, -89, -18,  75},
+{70, -43, -87,   9,  90,  25, -80, -57,  57,  80, -25, -90,  -9,  87,  43, -70},
+{64, -64, -64,  64,  64, -64, -64,  64,  64, -64, -64,  64,  64, -64, -64,  64},
+{57, -80, -25,  90,  -9, -87,  43,  70, -70, -43,  87,   9, -90,  25,  80, -57},
+{50, -89,  18,  75, -75, -18,  89, -50, -50,  89, -18, -75,  75,  18, -89,  50},
+{43, -90,  57,  25, -87,  70,   9, -80,  80,  -9, -70,  87, -25, -57,  90, -43},
+{36, -83,  83, -36, -36,  83, -83,  36,  36, -83,  83, -36, -36,  83, -83,  36},
+{25, -70,  90, -80,  43,   9, -57,  87, -87,  57,  -9, -43,  80, -90,  70, -25},
+{18, -50,  75, -89,  89, -75,  50, -18, -18,  50, -75,  89, -89,  75, -50,  18},
+{ 9, -25,  43, -57,  70, -80,  87, -90,  90, -87,  80, -70,  57, -43,  25,  -9},
+// Odd rows
+{90,  90,  88,  85,  82,  78,  73,  67,  61,  54,  46,  38,  31,  22,  13,   4},
+{90,  82,  67,  46,  22,  -4, -31, -54, -73, -85, -90, -88, -78, -61, -38, -13},
+{88,  67,  31, -13, -54, -82, -90, -78, -46,  -4,  38,  73,  90,  85,  61,  22},
+{85,  46, -13, -67, -90, -73, -22,  38,  82,  88,  54,  -4, -61, -90, -78, -31},
+{82,  22, -54, -90, -61,  13,  78,  85,  31, -46, -90, -67,   4,  73,  88,  38},
+{78,  -4, -82, -73,  13,  85,  67, -22, -88, -61,  31,  90,  54, -38, -90, -46},
+{73, -31, -90, -22,  78,  67, -38, -90, -13,  82,  61, -46, -88,  -4,  85,  54},
+{67, -54, -78,  38,  85, -22, -90,   4,  90,  13, -88, -31,  82,  46, -73, -61},
+{61, -73, -46,  82,  31, -88, -13,  90,  -4, -90,  22,  85, -38, -78,  54,  67},
+{54, -85,  -4,  88, -46, -61,  82,  13, -90,  38,  67, -78, -22,  90, -31, -73},
+{46, -90,  38,  54, -90,  31,  61, -88,  22,  67, -85,  13,  73, -82,   4,  78},
+{38, -88,  73,  -4, -67,  90, -46, -31,  85, -78,  13,  61, -90,  54,  22, -82},
+{31, -78,  90, -61,   4,  54, -88,  82, -38, -22,  73, -90,  67, -13, -46,  85},
+{22, -61,  85, -90,  73, -38,  -4,  46, -78,  90, -82,  54, -13, -31,  67, -88},
+{13, -38,  61, -78,  88, -90,  85, -73,  54, -31,   4,  22, -46,  67, -82,  90},
+{ 4, -13,  22, -31,  38, -46,  54, -61,  67, -73,  78, -82,  85, -88,  90, -90}
+};
+
 struct GPU
 {
   unsigned int qpu_code[QPU_CODE_SIZE];
   unsigned int vpu_code[VPU_CODE_SIZE];
+  short transMatrix2even[16*16];
   int open_count; // Number of allocated video buffers
   unsigned int vc_handle; // Handle of this memory
   int      mb; // Mailbox handle
@@ -120,6 +158,8 @@ static int gpu_init(volatile struct GPU **gpu) {
     assert(num_bytes<=VPU_CODE_SIZE*sizeof(unsigned int));
     memcpy((void*)ptr->vpu_code, rpi_hevc_transform, num_bytes);
   }
+  // And the transform coefficients
+  memcpy((void*)ptr->transMatrix2even, rpi_transMatrix2even, 16*16*sizeof(short));
   
   return 0;
 }
@@ -271,11 +311,43 @@ unsigned int vpu_get_fn(void) {
   return gpu->vc + offsetof(struct GPU,vpu_code);
 }
 
+unsigned int vpu_get_constants(void) {
+  if (gpu==NULL) {
+    gpu_lock();
+    gpu_unlock();
+  }
+  return gpu->vc + offsetof(struct GPU,transMatrix2even);
+}
+
 unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
 {
   unsigned r;
+#ifdef RPI_TIME_TOTAL_VPU
+  static int last_time=0;
+  static long long on_time=0;
+  static long long off_time=0;
+  int start_time;
+  int end_time;
+  static int count=0;
+  static long long countr2=0;
+#endif
   gpu_lock();
+#ifdef RPI_TIME_TOTAL_VPU
+  start_time = Microseconds();
+  if (last_time==0)
+    last_time = start_time;
+  off_time += start_time-last_time;
+#endif
   r = execute_code(gpu->mb, code, r0, r1, r2, r3, r4, r5);
+#ifdef RPI_TIME_TOTAL_VPU
+  end_time = Microseconds();
+  last_time = end_time;
+  on_time += end_time - start_time;
+  count++;
+  countr2 += r2;
+  if ((count&0x7f)==0)
+    printf("VPU %d %lld On=%dms, Off=%dms\n",count,countr2,(int)(on_time/1000),(int)(off_time/1000));
+#endif
   gpu_unlock();
   return r;
 }
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index 4e3c35c..814fc3c 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -34,6 +34,7 @@ extern unsigned int qpu_get_fn(int num);
 
 // VPU specific functions
 extern unsigned int vpu_get_fn(void);
+extern unsigned int vpu_get_constants(void);
 extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
 
 // Simple test of shader code
-- 
1.9.1


From ee03c1b3e2ed83470c8991ddc2b39c56185ef4be Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 5 May 2015 09:41:23 +0100
Subject: [PATCH 05/77] Fixed deblocking

---
 libavcodec/hevc.c | 20 +++++++++++++++++---
 1 file changed, 17 insertions(+), 3 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 43edea1..c86209f 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2364,8 +2364,9 @@ static void rpi_execute_transform(HEVCContext *s)
     //    s->hevcdsp.idct[4-2](coeffs, 16);
     //}
     
-    //gpu_cache_flush(&s->coeffs_buf[i]);
+    gpu_cache_flush(&s->coeffs_buf[i]);
     vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[i].vc, s->num_coeffs[i] >> 8, 0, 0, 0);
+    gpu_cache_flush(&s->coeffs_buf[i]);
     
     for(i=0;i<4;i++)
         s->num_coeffs[i] = 0;
@@ -2404,6 +2405,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
 
 #ifdef RPI
+    int start_ctb_x = (s->sh.slice_ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;
     s->enable_rpi = 1; // TODO this should depend on cross component and frame width etc.
 #endif
 
@@ -2437,9 +2439,17 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 
         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);
 #ifdef RPI
-        if (1 || x_ctb + ctb_size >= s->sps->width) { // TODO watch out for deblocking!
+        if (s->enable_rpi && x_ctb + ctb_size >= s->sps->width) {
+            int x;
+            // Transform all blocks
             rpi_execute_transform(s);
+            // Perform intra prediction and residual reconstruction
             rpi_execute_pred_cmds(s);
+            // Perform deblocking for CTBs in this row
+            for(x = start_ctb_x; x <= x_ctb; x += ctb_size) {  // TODO this will fail for tiles
+                ff_hevc_hls_filters(s, x, y_ctb, ctb_size);
+            }
+            start_ctb_x = 0;
         }
 #endif
         if (more_data < 0) {
@@ -2450,6 +2460,10 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 
         ctb_addr_ts++;
         ff_hevc_save_states(s, ctb_addr_ts);
+#ifdef RPI
+        if (s->enable_rpi)
+            continue;
+#endif
         ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);
     }
 
@@ -3414,7 +3428,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     if (!s->univ_pred_cmds)
         goto fail;
     for(i = 0; i < 4; i++) {
-        gpu_malloc_uncached(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16, &s->coeffs_buf[i]); // TODO slim this down and share across sizes
+        gpu_malloc_cached(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16, &s->coeffs_buf[i]); // TODO slim this down and share across sizes
         s->coeffs_buf_arm[i] = (int16_t*) s->coeffs_buf[i].arm;
         if (!s->coeffs_buf_arm[i])
             goto fail;
-- 
1.9.1


From f1dcb3c698eb2b413cb06b96988c5f22e6713121 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 5 May 2015 11:32:30 +0100
Subject: [PATCH 06/77] Added 32x32 transform

---
 libavcodec/hevc.c               |   8 +-
 libavcodec/hevc_cabac.c         |   2 +-
 libavcodec/rpi_hevc_transform.h | 200 +++++++--------
 libavcodec/rpi_hevc_transform.s | 528 ++++++++++++++++++++--------------------
 libavcodec/rpi_qpu.c            |   4 +-
 5 files changed, 359 insertions(+), 383 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index c86209f..303f1b5 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2364,9 +2364,11 @@ static void rpi_execute_transform(HEVCContext *s)
     //    s->hevcdsp.idct[4-2](coeffs, 16);
     //}
     
-    gpu_cache_flush(&s->coeffs_buf[i]);
-    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[i].vc, s->num_coeffs[i] >> 8, 0, 0, 0);
-    gpu_cache_flush(&s->coeffs_buf[i]);
+    gpu_cache_flush(&s->coeffs_buf[2]);
+    gpu_cache_flush(&s->coeffs_buf[3]);
+    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[2].vc, s->num_coeffs[2] >> 8, s->coeffs_buf[3].vc, s->num_coeffs[3] >> 10, 0);
+    gpu_cache_flush(&s->coeffs_buf[2]);
+    gpu_cache_flush(&s->coeffs_buf[3]);
     
     for(i=0;i<4;i++)
         s->num_coeffs[i] = 0;
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index 6a37726..85c7384 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1079,7 +1079,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     int vshift = s->sps->vshift[c_idx];
     uint8_t *dst = &s->frame->data[c_idx][(y0 >> vshift) * stride +
                                           ((x0 >> hshift) << s->sps->pixel_shift)];
-    int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag && !transform_skip_flag && !lc->tu.cross_pf && log2_trafo_size==4;
+    int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag && !transform_skip_flag && !lc->tu.cross_pf && log2_trafo_size>=4;
     int16_t *coeffs = (int16_t*)(c_idx ? lc->edge_emu_buffer2 : lc->edge_emu_buffer);
     uint8_t significant_coeff_group_flag[8][8] = {{0}};
     int explicit_rdpcm_flag = 0;
diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
index c0c279f..6d772d7 100644
--- a/libavcodec/rpi_hevc_transform.h
+++ b/libavcodec/rpi_hevc_transform.h
@@ -1,6 +1,10 @@
 unsigned char rpi_hevc_transform [] = {
 169,
 3,
+62,
+64,
+79,
+64,
 3,
 232,
 32,
@@ -17,6 +21,22 @@ unsigned char rpi_hevc_transform [] = {
 248,
 0,
 0,
+64,
+232,
+0,
+2,
+0,
+0,
+12,
+248,
+0,
+168,
+0,
+0,
+192,
+248,
+0,
+0,
 0,
 96,
 3,
@@ -79,7 +99,7 @@ unsigned char rpi_hevc_transform [] = {
 70,
 128,
 144,
-39,
+40,
 0,
 4,
 255,
@@ -113,7 +133,7 @@ unsigned char rpi_hevc_transform [] = {
 0,
 128,
 144,
-22,
+23,
 0,
 4,
 255,
@@ -153,6 +173,8 @@ unsigned char rpi_hevc_transform [] = {
 140,
 211,
 192,
+34,
+31,
 41,
 3,
 70,
@@ -195,7 +217,7 @@ unsigned char rpi_hevc_transform [] = {
 255,
 36,
 204,
-96,
+224,
 2,
 0,
 248,
@@ -219,62 +241,10 @@ unsigned char rpi_hevc_transform [] = {
 103,
 90,
 0,
-8,
-240,
-0,
-128,
-128,
-3,
-0,
-247,
-32,
-128,
-10,
-4,
-136,
-240,
-32,
-0,
-128,
-3,
-112,
-96,
-90,
-0,
-169,
-3,
-3,
-232,
-32,
-0,
-0,
-0,
-12,
-248,
-0,
-136,
-0,
-0,
-192,
-248,
-0,
-0,
+225,
+64,
+242,
 64,
-232,
-0,
-2,
-0,
-0,
-12,
-248,
-0,
-168,
-0,
-0,
-192,
-248,
-0,
-0,
 3,
 232,
 128,
@@ -287,18 +257,6 @@ unsigned char rpi_hevc_transform [] = {
 2,
 0,
 0,
-4,
-232,
-64,
-0,
-0,
-0,
-5,
-232,
-0,
-8,
-0,
-0,
 57,
 239,
 224,
@@ -317,18 +275,26 @@ unsigned char rpi_hevc_transform [] = {
 64,
 26,
 64,
+4,
+232,
+64,
+0,
+0,
+0,
+149,
+96,
 161,
 64,
 152,
 64,
 128,
 144,
-31,
+35,
 0,
 72,
 232,
-32,
 0,
+4,
 0,
 0,
 65,
@@ -339,8 +305,16 @@ unsigned char rpi_hevc_transform [] = {
 0,
 128,
 144,
-23,
+27,
+0,
+4,
+232,
+0,
+8,
 0,
+0,
+69,
+96,
 145,
 64,
 168,
@@ -351,8 +325,8 @@ unsigned char rpi_hevc_transform [] = {
 0,
 72,
 232,
-32,
 0,
+4,
 0,
 0,
 65,
@@ -373,7 +347,7 @@ unsigned char rpi_hevc_transform [] = {
 0,
 242,
 140,
-229,
+221,
 192,
 57,
 239,
@@ -383,6 +357,8 @@ unsigned char rpi_hevc_transform [] = {
 0,
 41,
 3,
+239,
+3,
 12,
 248,
 0,
@@ -390,7 +366,7 @@ unsigned char rpi_hevc_transform [] = {
 0,
 0,
 192,
-8,
+248,
 4,
 0,
 12,
@@ -400,14 +376,14 @@ unsigned char rpi_hevc_transform [] = {
 64,
 0,
 192,
-8,
+248,
 4,
 0,
 0,
 96,
 255,
 159,
-131,
+154,
 255,
 0,
 232,
@@ -417,7 +393,7 @@ unsigned char rpi_hevc_transform [] = {
 0,
 255,
 159,
-142,
+165,
 255,
 4,
 255,
@@ -429,7 +405,7 @@ unsigned char rpi_hevc_transform [] = {
 251,
 62,
 0,
-5,
+4,
 255,
 51,
 204,
@@ -439,15 +415,15 @@ unsigned char rpi_hevc_transform [] = {
 251,
 16,
 0,
-77,
+76,
 254,
 51,
 204,
-9,
-4,
+128,
+3,
 224,
 251,
-0,
+20,
 0,
 128,
 64,
@@ -467,16 +443,6 @@ unsigned char rpi_hevc_transform [] = {
 99,
 0,
 0,
-4,
-254,
-0,
-144,
-128,
-2,
-0,
-8,
-2,
-0,
 32,
 247,
 240,
@@ -488,92 +454,92 @@ unsigned char rpi_hevc_transform [] = {
 176,
 207,
 17,
-3,
+19,
 32,
 247,
 112,
 207,
 18,
-3,
+35,
 32,
 247,
 48,
 207,
 19,
-3,
+51,
 32,
 247,
 240,
 206,
 20,
-3,
+67,
 32,
 247,
 176,
 206,
 21,
-3,
+83,
 32,
 247,
 112,
 206,
 22,
-3,
+99,
 32,
 247,
 48,
 206,
 23,
-3,
+115,
 32,
 247,
 240,
 205,
 24,
-3,
+131,
 32,
 247,
 176,
 205,
 25,
-3,
+147,
 32,
 247,
 112,
 205,
 26,
-3,
+163,
 32,
 247,
 48,
 205,
 27,
-3,
+179,
 32,
 247,
 240,
 204,
 28,
-3,
+195,
 32,
 247,
 176,
 204,
 29,
-3,
+211,
 32,
 247,
 112,
 204,
 30,
-3,
+227,
 32,
 247,
 48,
 204,
 31,
-3,
-5,
+243,
+4,
 255,
 51,
 204,
@@ -583,20 +549,20 @@ unsigned char rpi_hevc_transform [] = {
 251,
 16,
 0,
-77,
+76,
 254,
 51,
 204,
-9,
-4,
+128,
+3,
 224,
 251,
-0,
+20,
 0,
 0,
 237,
+32,
 0,
-4,
 0,
 0,
 140,
@@ -609,6 +575,6 @@ unsigned char rpi_hevc_transform [] = {
 99,
 0,
 0,
-90,
-0,
+111,
+3,
 };
diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
index edefb51..a660b58 100644
--- a/libavcodec/rpi_hevc_transform.s
+++ b/libavcodec/rpi_hevc_transform.s
@@ -1,260 +1,268 @@
-# ******************************************************************************
-# Argon Design Ltd.
-# (c) Copyright 2015 Argon Design Ltd. All rights reserved.
-#
-# Module : HEVC
-# Author : Peter de Rivaz
-# ******************************************************************************
-
-# HEVC VPU Transform
-#
-# Transform matrix can be thought of as
-#   output row vector = input row vector * transMatrix2
-#
-# The even rows of the matrix are symmetric
-# The odd rows of the matrix are antisymmetric
-#
-# So only need to compute the first half of the results, then can compute the remainder with a butterfly
-#
-# EXAMPLE
-#   (a b c d) (1 2  2  1)
-#             (3 4 -4 -3)
-#             (5 6  6  5)
-#             (7 8 -8 -7)
-#
-#  x=(a c)(1 2) = 1a+5c 2a+6c
-#         (5 6)
-#
-#  y=(b d)(3 4) = 3b+7d 4b+8d
-#         (7 8)
-#
-#  u=x+y = 1a+5c+3b+7d 2a+4b+6c+8d
-#  v=x-y = 1a+5c-3b-7d 2a+6c-4b-8d
-#  
-#  Final results are (u , v[::-1])
-#
-#
-#  For 32x1 input, load even rows into HX(0++,0), odd rows into HX(16++,0)
-#  Apply the even matrix first and stop before rounding
-#  Then apply the odd matrix in a full manner:
-#
-#   First step is to compute partial products with the first input (16 cycles)        
-#   1a 3b 5c 7d   16x1 input coefficients produce 16x16 output                      
-#   2a 4b 6c 8d
-#   2a -4b 6c -8d
-#   1a -3b 5c -7d
-#
-#   Second step is to sum partial products into final position (8 cycles)
-#   1a+3b+5c+7d
-#   2a+4b+6c+8d
-#   2a-4b+6c-8d
-#   1a-3b+5c-7d
-#
-#   Then can apply butterfly to combine even results and odd results + rounding to produce 16 rows of output at a time (need to save in transposed format)
-#
-#   For 16x16 no butterfly is required and can store final results in original location  (Could do 2 16x16s in parallel to make use of the trick - saves on the adds)
-#
-#   For 8x8 we could compute two in parallel.
-#
-#
-  
-# Columns are transformed first
-#
-# Store top left half of transMatrix2 in 
-# Store bottom left half of transMatrix2 in HX(32,32)
-#
-# For 16x16
-# HX(0:15,0) contains input data before transform
-# HY(0:15,0) contains 32bit output data after transform
-# HX(32,0) contains even rows of left half of transMatrix2
-# HX(32,32) contains odd rows of left half of transMatrix2
-# HY(48,0) contains partial products ready for summing
-#
-
-  
-# hevc_trans_16x16(short *transMatrix2, short *coeffs, int num) # TODO add size so we can branch to correct implementation (or perhaps have coeffs32 and num32 as secondary inputs!)
-# transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory)
-# coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
-# num: number of 16x16 transforms to be done
-#
-hevc_trans_16x16:
-  push r6-r15, lr # TODO cut down number of used registers
-  
-  mov r3, 16*2 # Stride of transMatrix2 in bytes
-  vldh HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
-  # Now use r0 to describe which matrix we are working on.
-  # Allows us to prefetch the next block of coefficients for efficiency.
-  mov r0,0 # This describes the location where we read our coefficients from
-  mov r3,16*2 # Stride of coefficients in bytes (TODO remove)
-  mov r7,16*16*2 # Total block size
-  mov r8,64*16 # Value used to swap from current to next VRF location
-  vldh HX(0++,0)+r0,(r1 += r3) REP 16 
-  mov r4,64 # Constant used for rounding first pass
-  mov r5,1<<11 # Constant used for rounding second pass
-  
-  # At start of block r0,r1 point to the current block (that has already been loaded)
-block_loop:
-  eor r0,r8
-  add r1,r7
-  # Prefetch the next block
-  vldh HX(0++,0)+r0,(r1 += r3) REP 16 
-  eor r0,r8
-  sub r1,r7
-  
-  # Transform the current block
-  bl col_trans_16
-  vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
-  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
-  vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
-  vmov VX(0,0++)+r0, HX(0++,32)+r0 REP 16    # For simplicity transpose this back to the original position
-  
-  bl col_trans_16
-  vadd HY(0++,0)+r0,HY(0++,0)+r0,r5 REP 16   # Now add on rounding, shift down by 7, and saturate
-  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16 # 4+12=16 so this ends up with the output saturated and in the top half of the word.
-  vasl HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16    # This should be saturating, but the instruction above does not assemble?
-  
-  # Save results - note there has been a transposition during the processing so we save columns
-  vsth VX(0,32++)+r0, (r1 += r3) REP 16 
-  
-  # Move onto next block
-  eor r0,r8
-  add r1,r7
-
-  addcmpbgt r2,-1,0,block_loop
-  pop r6-r15, pc
-  
-# r1,r2,r3 r7,r8 should be preserved
-# HX(0++,0)+r0 is the block to be transformed
-# HX(32++,0)+r6 is the 16x16 matrix of transform coefficients
-# Use HY(48,0) for intermediate results
-# r0 can be used, but should be returned to its original value at the end
-col_trans_16:
-  add r6,r0,16 # Final value for this loop
-col_trans_16_loop:
-  # First compute partial products for a single column
-  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,0++) REP 16
-  # Then sum up the results and place back 
-  vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
-  addcmpblt r0,1,r6,col_trans_16_loop
-  sub r0,16  # but r0 back to its original value
-  b lr
-  
-col_trans_odd_16:
-  add r6,r0,16 # Final value for this loop
-col_trans_odd_16_loop:
-  # First compute partial products for a single column
-  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,0++) REP 16
-  # Then sum up the results and place back 
-  vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
-  addcmpblt r0,1,r6,col_trans_odd_16_loop
-  sub r0,16  # but r0 back to its original value
-  b lr
-  
-  
-test_add:
-  vldh HX(0,0),(r0)
-  vadd HX(0,0),HX(0,0),10
-  vsth HX(0,0),(r0)
-  mov r0,7 # return value
-  b lr
-
-# hevc_trans_32x32(short *transMatrix2, short *coeffs, int num)
-# transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory) Even followed by odd
-# coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
-# num: number of 16x16 transforms to be done
-#
-hevc_trans_32x32:
-  push r6-r15, lr # TODO cut down number of used registers
-  
-  # Fetch transform matrices
-  mov r3, 16*2 # Stride of transMatrix2 in bytes (and of coefficients)
-  vldh HX(32++,0),(r0 += r3) REP 16 # This is the even 16x16 matrix
-  add r0, 16*16*2
-  vldh HX(32++,32),(r0 += r3) REP 16 # This is the odd 16x16 matrix
-  
-  mov r3, 32*2*2 # Stride used to fetch alternate rows of our input coefficient buffer
-  mov r7, 16*16*2 # Total block size
-  mov r4, 64 # Constant used for rounding first pass
-  mov r5, 1<<11 # Constant used for rounding second pass
-  sub sp,sp,32*32*2+32 # Allocate some space on the stack for us to store 32*32 shorts as temporary results (needs to be aligned)
-  # set r8 to 32byte aligned stack pointer
-  add r8,sp,31
-  lsr r8,5
-  lsl r8,5
-  mov r9,r8  # Backup of the temporary storage
-  mov r10,r1 # Backup of the coefficient buffer
-block_loop32:
-
-  # COLUMN TRANSFORM
-  # Transform the first 16 columns
-  mov r1,r10  # Input Coefficient buffer
-  mov r8,r9   # Output temporary storage
-  bl trans32
-  # Transform the second 16 columns
-  add r8,32
-  add r1,32
-  bl trans32
-  
-  # ROW TRANSFORM
-  mov r1,r9  # Input temporary storage 
-  mov r8,r10   # Output Coefficient buffer
-  bl trans32
-  # Transform the second 16 columns
-  add r8,32
-  add r1,32
-  bl trans32
-     
-  add r10, 32*32*2 # move onto next block of coefficients
-  addcmpbgt r2,-1,0,block_loop32
-  
-  add sp,sp,32*32*2+32 # Restore stack
-  
-  pop r6-r15, pc
-  
-trans32:
-  # We can no longer afford the VRF space to do prefetching when doing 32x32
-  # Fetch the even rows
-  vldh HX(0++,0)+r0,(r1 += r3) REP 16
-  # Fetch the odd rows
-  vldh HX(16++,0)+r0,64(r1 += r3) REP 16 # First odd row is 32 shorts ahead of r1
-  
-  # Transform the even rows using even matrix
-  mov r0, 0 # Even rows
-  bl col_trans_16
-  
-  # Now transform the odd rows using odd matrix
-  mov r0, 64*16 # Odd rows
-  bl col_trans_odd_16
-  
-  # Now apply butterfly to compute the first 16 results
-  vadd HY(48++,0),HY(0++,0),HY(16++,0) REP 16
-  vadd HY(48++,0),HY(48++,0),r4 REP 32   # add on rounding, 
-  vasl HY(48++,0),HY(48++,0),9 REP 32    # shift down by 7, and saturate
-  # 16bit results now in HX(48,32)
-  mov r0,r8
-  mov r6,32*2
-  vsth VX(48,32++),(r0+=r6) REP 16
-  vmov VX(0,0++)+r0, HX(0++,32)+r0 REP 16    # Store transposed
-  
-  # Now apply butterfly to compute the second 16 results (in reverse order)
-  vsub HY(63,0),HY(0,0),HY(16,0)
-  vsub HY(62,0),HY(0,0),HY(17,0)
-  vsub HY(61,0),HY(0,0),HY(18,0)
-  vsub HY(60,0),HY(0,0),HY(19,0)
-  vsub HY(59,0),HY(0,0),HY(20,0)
-  vsub HY(58,0),HY(0,0),HY(21,0)
-  vsub HY(57,0),HY(0,0),HY(22,0)
-  vsub HY(56,0),HY(0,0),HY(23,0)
-  vsub HY(55,0),HY(0,0),HY(24,0)
-  vsub HY(54,0),HY(0,0),HY(25,0)
-  vsub HY(53,0),HY(0,0),HY(26,0)
-  vsub HY(52,0),HY(0,0),HY(27,0)
-  vsub HY(51,0),HY(0,0),HY(28,0)
-  vsub HY(50,0),HY(0,0),HY(29,0)
-  vsub HY(49,0),HY(0,0),HY(30,0)
-  vsub HY(48,0),HY(0,0),HY(31,0)
-  vadd HY(48++,0),HY(48++,0),r4 REP 32   # add on rounding, 
-  vasl HY(48++,0),HY(48++,0),9 REP 32    # shift down by 7, and saturate
-  add r0,r8,16*32*2 # Move to 16th row
-  vsth VX(48,32++),(r0+=r6) REP 16
-  b lr
+# ******************************************************************************
+# Argon Design Ltd.
+# (c) Copyright 2015 Argon Design Ltd. All rights reserved.
+#
+# Module : HEVC
+# Author : Peter de Rivaz
+# ******************************************************************************
+
+# HEVC VPU Transform
+#
+# Transform matrix can be thought of as
+#   output row vector = input row vector * transMatrix2
+#
+# The even rows of the matrix are symmetric
+# The odd rows of the matrix are antisymmetric
+#
+# So only need to compute the first half of the results, then can compute the remainder with a butterfly
+#
+# EXAMPLE
+#   (a b c d) (1 2  2  1)
+#             (3 4 -4 -3)
+#             (5 6  6  5)
+#             (7 8 -8 -7)
+#
+#  x=(a c)(1 2) = 1a+5c 2a+6c
+#         (5 6)
+#
+#  y=(b d)(3 4) = 3b+7d 4b+8d
+#         (7 8)
+#
+#  u=x+y = 1a+5c+3b+7d 2a+4b+6c+8d
+#  v=x-y = 1a+5c-3b-7d 2a+6c-4b-8d
+#
+#  Final results are (u , v[::-1])
+#
+#
+#  For 32x1 input, load even rows into HX(0++,0), odd rows into HX(16++,0)
+#  Apply the even matrix first and stop before rounding
+#  Then apply the odd matrix in a full manner:
+#
+#   First step is to compute partial products with the first input (16 cycles)
+#   1a 3b 5c 7d   16x1 input coefficients produce 16x16 output
+#   2a 4b 6c 8d
+#   2a -4b 6c -8d
+#   1a -3b 5c -7d
+#
+#   Second step is to sum partial products into final position (8 cycles)
+#   1a+3b+5c+7d
+#   2a+4b+6c+8d
+#   2a-4b+6c-8d
+#   1a-3b+5c-7d
+#
+#   Then can apply butterfly to combine even results and odd results + rounding to produce 16 rows of output at a time (need to save in transposed format)
+#
+#   For 16x16 no butterfly is required and can store final results in original location  (Could do 2 16x16s in parallel to make use of the trick - saves on the adds)
+#
+#   For 8x8 we could compute two in parallel.
+#
+#
+
+# Columns are transformed first
+#
+# Store top left half of transMatrix2 in
+# Store bottom left half of transMatrix2 in HX(32,32)
+#
+# For 16x16
+# HX(0:15,0) contains input data before transform
+# HY(0:15,0) contains 32bit output data after transform
+# HX(32,0) contains even rows of left half of transMatrix2
+# HX(32,32) contains odd rows of left half of transMatrix2
+# HY(48,0) contains partial products ready for summing
+#
+
+
+# hevc_trans_16x16(short *transMatrix2, short *coeffs, int num) # TODO add size so we can branch to correct implementation (or perhaps have coeffs32 and num32 as secondary inputs!)
+# transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory)
+# coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
+# num: number of 16x16 transforms to be done
+# coeffs32
+# num32: number of 32x32 transforms
+#
+hevc_trans_16x16:
+  push r6-r15, lr # TODO cut down number of used registers
+  mov r14,r3 # coeffs32
+  mov r15,r4 # num32
+  mov r3, 16*2 # Stride of transMatrix2 in bytes
+  vldh HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
+
+  add r0, 16*16*2 # For 32x32 transforms we also need this matrix
+  vldh HX(32++,32),(r0 += r3) REP 16 # This is the odd 16x16 matrix
+
+  # Now use r0 to describe which matrix we are working on.
+  # Allows us to prefetch the next block of coefficients for efficiency.
+  mov r0,0 # This describes the location where we read our coefficients from
+  mov r3,16*2 # Stride of coefficients in bytes (TODO remove)
+  mov r7,16*16*2 # Total block size
+  mov r8,64*16 # Value used to swap from current to next VRF location
+  vldh HX(0++,0)+r0,(r1 += r3) REP 16
+  mov r4,64 # Constant used for rounding first pass
+  mov r5,1<<11 # Constant used for rounding second pass
+
+  # At start of block r0,r1 point to the current block (that has already been loaded)
+block_loop:
+  eor r0,r8
+  add r1,r7
+  # Prefetch the next block
+  vldh HX(0++,0)+r0,(r1 += r3) REP 16
+  eor r0,r8
+  sub r1,r7
+
+  # Transform the current block
+  bl col_trans_16
+  vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
+  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
+  vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
+  vmov VX(0,0++)+r0, HX(0++,32)+r0 REP 16    # For simplicity transpose this back to the original position
+
+  bl col_trans_16
+  vadd HY(0++,0)+r0,HY(0++,0)+r0,r5 REP 16   # Now add on rounding, shift down by 7, and saturate
+  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16 # 4+12=16 so this ends up with the output saturated and in the top half of the word.
+  vasl HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16    # This should be saturating, but the instruction above does not assemble?
+
+  # Save results - note there has been a transposition during the processing so we save columns
+  vsth VX(0,32++)+r0, (r1 += r3) REP 16
+
+  # Move onto next block
+  eor r0,r8
+  add r1,r7
+
+  addcmpbgt r2,-1,0,block_loop
+
+  # Now go and do any 32x32 transforms
+  b hevc_trans_32x32
+
+  pop r6-r15, pc
+
+# r1,r2,r3 r7,r8 should be preserved
+# HX(0++,0)+r0 is the block to be transformed
+# HX(32++,0)+r6 is the 16x16 matrix of transform coefficients
+# Use HY(48,0) for intermediate results
+# r0 can be used, but should be returned to its original value at the end
+col_trans_16:
+  add r6,r0,16 # Final value for this loop
+col_trans_16_loop:
+  # First compute partial products for a single column
+  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,0++) REP 16
+  # Then sum up the results and place back
+  vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
+  addcmpblt r0,1,r6,col_trans_16_loop
+  sub r0,16  # put r0 back to its original value
+  b lr
+
+col_trans_odd_16:
+  add r6,r0,16 # Final value for this loop
+col_trans_odd_16_loop:
+  # First compute partial products for a single column
+  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,32++) REP 16
+  # Then sum up the results and place back
+  vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
+  addcmpblt r0,1,r6,col_trans_odd_16_loop
+  sub r0,16  # put r0 back to its original value
+  b lr
+
+# hevc_trans_32x32(short *transMatrix2, short *coeffs, int num)
+# transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory) Even followed by odd
+# coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
+# num: number of 16x16 transforms to be done
+#
+hevc_trans_32x32:
+  mov r1,r14 # coeffs
+  mov r2,r15 # num
+
+  # Fetch odd transform matrix
+  #mov r3, 16*2 # Stride of transMatrix2 in bytes (and of coefficients)
+  #vldh HX(32++,0),(r0 += r3) REP 16 # This is the even 16x16 matrix
+  #add r0, 16*16*2
+  #vldh HX(32++,32),(r0 += r3) REP 16 # This is the odd 16x16 matrix
+
+  mov r3, 32*2*2 # Stride used to fetch alternate rows of our input coefficient buffer
+  mov r7, 16*16*2 # Total block size
+  sub sp,sp,32*32*2+32 # Allocate some space on the stack for us to store 32*32 shorts as temporary results (needs to be aligned)
+  # set r8 to 32byte aligned stack pointer
+  add r8,sp,31
+  lsr r8,5
+  lsl r8,5
+  mov r9,r8  # Backup of the temporary storage
+  mov r10,r1 # Backup of the coefficient buffer
+block_loop32:
+
+  # COLUMN TRANSFORM
+  mov r4, 64 # Constant used for rounding first pass
+  mov r5, 9 # left shift used for rounding first pass
+
+  # Transform the first 16 columns
+  mov r1,r10  # Input Coefficient buffer
+  mov r8,r9   # Output temporary storage
+  bl trans32
+  # Transform the second 16 columns
+  add r8,32*16*2
+  add r1,32
+  bl trans32
+
+  # ROW TRANSFORM
+  mov r4, 1<<11 # Constant used for rounding second pass
+  mov r5, 4 # left shift used for rounding second pass
+
+  mov r1,r9  # Input temporary storage
+  mov r8,r10   # Output Coefficient buffer
+  bl trans32
+  # Transform the second 16 columns
+  add r8,32*16*2
+  add r1,32
+  bl trans32
+
+  add r10, 32*32*2 # move onto next block of coefficients
+  addcmpbgt r2,-1,0,block_loop32
+
+  add sp,sp,32*32*2+32 # Restore stack
+
+  pop r6-r15, pc
+
+trans32:
+  push lr
+  # We can no longer afford the VRF space to do prefetching when doing 32x32
+  # Fetch the even rows
+  vldh HX(0++,0),(r1 += r3) REP 16
+  # Fetch the odd rows
+  vldh HX(16++,0),64(r1 += r3) REP 16 # First odd row is 32 shorts ahead of r1
+
+  # Transform the even rows using even matrix
+  mov r0, 0 # Even rows
+  bl col_trans_16
+
+  # Now transform the odd rows using odd matrix
+  mov r0, 64*16 # Odd rows
+  bl col_trans_odd_16
+
+  # Now apply butterfly to compute the first 16 results
+  vadd HY(48++,0),HY(0++,0),HY(16++,0) REP 16
+  vadd HY(48++,0),HY(48++,0),r4 REP 16   # add on rounding,
+  vasl HY(48++,0),HY(48++,0),r5 REP 16    # shift down by 7, and saturate
+  # 16bit results now in HX(48,32)
+  mov r0,r8
+  mov r6,32*2
+  vsth VX(48,32++),(r0+=r6) REP 16
+
+  # Now apply butterfly to compute the second 16 results (in reverse order)
+  vsub HY(63,0),HY(0 ,0),HY(16,0)
+  vsub HY(62,0),HY(1 ,0),HY(17,0)
+  vsub HY(61,0),HY(2 ,0),HY(18,0)
+  vsub HY(60,0),HY(3 ,0),HY(19,0)
+  vsub HY(59,0),HY(4 ,0),HY(20,0)
+  vsub HY(58,0),HY(5 ,0),HY(21,0)
+  vsub HY(57,0),HY(6 ,0),HY(22,0)
+  vsub HY(56,0),HY(7 ,0),HY(23,0)
+  vsub HY(55,0),HY(8 ,0),HY(24,0)
+  vsub HY(54,0),HY(9 ,0),HY(25,0)
+  vsub HY(53,0),HY(10,0),HY(26,0)
+  vsub HY(52,0),HY(11,0),HY(27,0)
+  vsub HY(51,0),HY(12,0),HY(28,0)
+  vsub HY(50,0),HY(13,0),HY(29,0)
+  vsub HY(49,0),HY(14,0),HY(30,0)
+  vsub HY(48,0),HY(15,0),HY(31,0)
+  vadd HY(48++,0),HY(48++,0),r4 REP 16   # add on rounding,
+  vasl HY(48++,0),HY(48++,0),r5 REP 16    # shift down by 7, and saturate
+  add r0,r8,32
+  vsth VX(48,32++),(r0+=r6) REP 16
+  pop pc
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 479ae88..90f504a 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -86,7 +86,7 @@ struct GPU
 {
   unsigned int qpu_code[QPU_CODE_SIZE];
   unsigned int vpu_code[VPU_CODE_SIZE];
-  short transMatrix2even[16*16];
+  short transMatrix2even[16*16*2];
   int open_count; // Number of allocated video buffers
   unsigned int vc_handle; // Handle of this memory
   int      mb; // Mailbox handle
@@ -159,7 +159,7 @@ static int gpu_init(volatile struct GPU **gpu) {
     memcpy((void*)ptr->vpu_code, rpi_hevc_transform, num_bytes);
   }
   // And the transform coefficients
-  memcpy((void*)ptr->transMatrix2even, rpi_transMatrix2even, 16*16*sizeof(short));
+  memcpy((void*)ptr->transMatrix2even, rpi_transMatrix2even, sizeof(rpi_transMatrix2even));
   
   return 0;
 }
-- 
1.9.1


From 2811cf9e36954eda35d73e29849791f8320940c4 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 5 May 2015 16:57:03 +0100
Subject: [PATCH 07/77] Clear coefficients in advance

---
 libavcodec/hevc.c               | 129 ++++++++++++++++++++++++++++------------
 libavcodec/hevc.h               |   6 +-
 libavcodec/hevc_cabac.c         |   7 ++-
 libavcodec/rpi_hevc_transform.h |  50 ++++++++++++++++
 libavcodec/rpi_hevc_transform.s |  16 +++++
 5 files changed, 168 insertions(+), 40 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 303f1b5..4b3bb44 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -41,6 +41,8 @@
 
 #ifdef RPI
 #include "rpi_qpu.h"
+// For some unknown reason, the code seems to crash if I do a late malloc
+#define EARLY_MALLOC
 #endif
 
 // #define DISABLE_MC
@@ -59,6 +61,20 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 /* free everything allocated  by pic_arrays_init() */
 static void pic_arrays_free(HEVCContext *s)
 {
+#ifdef RPI
+#ifdef EARLY_MALLOC
+#else
+    printf("pic_arrays_free\n");
+    if (s->coeffs_buf_arm[0]) {
+      gpu_free(&s->coeffs_buf_default);
+      s->coeffs_buf_arm[0] = 0;
+    }
+    if (s->coeffs_buf_arm[2]) {
+      gpu_free(&s->coeffs_buf_accelerated);
+      s->coeffs_buf_arm[2] = 0;
+    }
+#endif
+#endif
     av_freep(&s->sao);
     av_freep(&s->deblock);
 
@@ -94,6 +110,28 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
                            ((height >> log2_min_cb_size) + 1);
     int ctb_count        = sps->ctb_width * sps->ctb_height;
     int min_pu_size      = sps->min_pu_width * sps->min_pu_height;
+    
+#ifdef RPI
+#ifdef EARLY_MALLOC
+#else
+    int coeffs_in_ctb = (1 << s->sps->log2_ctb_size) * (1 << s->sps->log2_ctb_size);
+    int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
+    printf("pic_arrays_init\n");
+    printf("Allocated %d\n",coefs_per_row);
+    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
+    s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
+    if (!s->coeffs_buf_arm[0])
+        goto fail;
+    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
+    s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
+    s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
+    if (!s->coeffs_buf_arm[2])
+        goto fail;    
+    s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
+    s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
+    printf("Done\n");
+#endif
+#endif
 
     s->bs_width  = (width  >> 2) + 1;
     s->bs_height = (height >> 2) + 1;
@@ -2364,11 +2402,10 @@ static void rpi_execute_transform(HEVCContext *s)
     //    s->hevcdsp.idct[4-2](coeffs, 16);
     //}
     
-    gpu_cache_flush(&s->coeffs_buf[2]);
-    gpu_cache_flush(&s->coeffs_buf[3]);
-    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[2].vc, s->num_coeffs[2] >> 8, s->coeffs_buf[3].vc, s->num_coeffs[3] >> 10, 0);
-    gpu_cache_flush(&s->coeffs_buf[2]);
-    gpu_cache_flush(&s->coeffs_buf[3]);
+    
+    gpu_cache_flush(&s->coeffs_buf_accelerated);
+    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
+    //gpu_cache_flush(&s->coeffs_buf_accelerated);
     
     for(i=0;i<4;i++)
         s->num_coeffs[i] = 0;
@@ -2390,7 +2427,9 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
           lc->na.cand_up_right     = (cmd->na >> 0) & 1;
           s->hpc.intra_pred[cmd->size - 2](s, cmd->x, cmd->y, cmd->c_idx);
       } else {
+          int trafo_size = 1 << cmd->size;
           s->hevcdsp.transform_add[cmd->size-2](cmd->dst, cmd->buf, cmd->stride);
+          memset(cmd->buf, 0, trafo_size * trafo_size * sizeof(int16_t)); // Clear coefficients here while they are in the cache
       }
   }
   s->num_pred_cmds = 0;
@@ -3357,9 +3396,17 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
     av_freep(&s->unif_mv_cmds);
     av_freep(&s->unif_xfm_cmds);
     av_freep(&s->univ_pred_cmds);
-    for(i = 0; i < 4; i++) {
-        gpu_free(&s->coeffs_buf[i]);
+    
+#ifdef EARLY_MALLOC
+    if (s->coeffs_buf_arm[0]) {
+      gpu_free(&s->coeffs_buf_default);
+      s->coeffs_buf_arm[0] = 0;
     }
+    if (s->coeffs_buf_arm[2]) {
+      gpu_free(&s->coeffs_buf_accelerated);
+      s->coeffs_buf_arm[2] = 0;
+    }
+#endif
 #endif
 
     for (i = 0; i < 3; i++) {
@@ -3406,6 +3453,16 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
     return 0;
 }
 
+#ifdef RPI
+static av_cold void memclear16(int16_t *p, int n)
+{
+  vpu_execute_code( vpu_get_fn(), p, n, 0, 0, 0, 1);
+  //int i;
+  //for(i=0;i<n;i++)
+  //  p[i] = 0;
+}
+#endif
+
 static av_cold int hevc_init_context(AVCodecContext *avctx)
 {
     HEVCContext *s = avctx->priv_data;
@@ -3429,38 +3486,36 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
     if (!s->univ_pred_cmds)
         goto fail;
-    for(i = 0; i < 4; i++) {
-        gpu_malloc_cached(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16, &s->coeffs_buf[i]); // TODO slim this down and share across sizes
-        s->coeffs_buf_arm[i] = (int16_t*) s->coeffs_buf[i].arm;
-        if (!s->coeffs_buf_arm[i])
-            goto fail;
-    }
+        
+    s->coeffs_buf_arm[0] = 0;
+    s->coeffs_buf_arm[2] = 0;
+ 
+#ifdef EARLY_MALLOC 
+    int coeffs_in_ctb = 64*64;
+    int coefs_per_row = (2048/64) * coeffs_in_ctb * 3;  // Allow space for chroma
+    printf("Allocated %d\n",coefs_per_row);
+    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
+    s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
+    if (!s->coeffs_buf_arm[0])
+        goto fail;
+    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
+    s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
+    s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
+    if (!s->coeffs_buf_arm[2])
+        goto fail;    
+    s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
+    s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
+    printf("Done\n");
+    //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
+    memclear16(s->coeffs_buf_arm[0], coefs_per_row);
+    //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
+    memclear16(s->coeffs_buf_arm[2], coefs_per_row);
+    //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
+    memclear16(s->coeffs_buf_arm[3], coefs_per_row);
+#endif
+
     s->enable_rpi = 0;
     
-    // A little test program
-    /*{
-      GPU_MEM_PTR_T p;
-      int err = gpu_malloc_cached(16, &p);
-      short *q = (short *)p.arm;
-      int i;
-      int r;
-      printf("Allocated memory %d ARM 0x%x, VC 0x%x, Code 0x%x\n",err,(int)p.arm,p.vc,(int)vpu_get_fn());
-      printf("Allocated memory %d ARM 0x%x, VC 0x%x\n",err,(int)p.arm,p.vc);
-      printf("Preparing data %p\n",q);
-      for(i=0;i<16;i++)
-        q[i] = i;
-      printf("Flush cache\n");
-      gpu_cache_flush(&p);
-      printf("Executing code\n");
-      r = vpu_execute_code( vpu_get_fn(), p.vc, 0, 0, 0, 0, 0);
-      printf("Return value %d (",r);
-      for(i=0;i<16;i++)
-        printf("%d ",q[i]);
-      printf(")\n");
-      gpu_free(&p);
-      goto fail; // Early out
-    }*/
-    
 #endif
 
     s->cabac_state = av_malloc(HEVC_CONTEXTS);
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 9f69412..938e45b 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -857,8 +857,12 @@ typedef struct HEVCContext {
     HEVCMvCmd *unif_mv_cmds;
     HEVCXfmCmd *unif_xfm_cmds;
     HEVCPredCmd *univ_pred_cmds;
-    GPU_MEM_PTR_T coeffs_buf[4];
+    int buf_width;
+    GPU_MEM_PTR_T coeffs_buf_default;
+    GPU_MEM_PTR_T coeffs_buf_accelerated;
     int16_t *coeffs_buf_arm[4];
+    unsigned int coeffs_buf_vc[4];
+    
     int num_coeffs[4];
     int num_xfm_cmds;
     int num_mv_cmds;
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index 85c7384..5ed952a 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1104,9 +1104,13 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
             s->num_coeffs[0] += n;
         }
     }
+    // We now do the memset after transform_add while we know the data is cached.
+    //memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
+#else
+    memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
 #endif
 
-    memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
+    
 
     // Derive QP for dequant
     if (!lc->cu.cu_transquant_bypass_flag) {
@@ -1593,7 +1597,6 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
 #ifdef RPI
     if (s->enable_rpi) {
         HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
-        //memcpy(coeffs2, coeffs, sizeof(int16_t) * trafo_size * trafo_size); // TODO
         cmd->type = RPI_PRED_TRANSFORM_ADD;
         cmd->size = log2_trafo_size;
         cmd->buf = coeffs;
diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
index 6d772d7..4f13622 100644
--- a/libavcodec/rpi_hevc_transform.h
+++ b/libavcodec/rpi_hevc_transform.h
@@ -1,4 +1,10 @@
 unsigned char rpi_hevc_transform [] = {
+21,
+106,
+0,
+144,
+35,
+1,
 169,
 3,
 62,
@@ -577,4 +583,48 @@ unsigned char rpi_hevc_transform [] = {
 0,
 111,
 3,
+4,
+254,
+0,
+128,
+0,
+4,
+0,
+248,
+0,
+0,
+2,
+232,
+32,
+0,
+0,
+0,
+140,
+248,
+32,
+0,
+0,
+0,
+224,
+35,
+0,
+0,
+64,
+232,
+0,
+2,
+0,
+0,
+193,
+232,
+0,
+1,
+0,
+0,
+1,
+106,
+116,
+30,
+90,
+0,
 };
diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
index a660b58..388ceb2 100644
--- a/libavcodec/rpi_hevc_transform.s
+++ b/libavcodec/rpi_hevc_transform.s
@@ -78,8 +78,11 @@
 # num: number of 16x16 transforms to be done
 # coeffs32
 # num32: number of 32x32 transforms
+# command 0 for transform, 1 for memclear16(int16_t *dst,num16)
 #
 hevc_trans_16x16:
+  cmp r5,1
+  beq memclear16
   push r6-r15, lr # TODO cut down number of used registers
   mov r14,r3 # coeffs32
   mov r15,r4 # num32
@@ -266,3 +269,16 @@ trans32:
   add r0,r8,32
   vsth VX(48,32++),(r0+=r6) REP 16
   pop pc
+
+memclear16:
+  # r0 is address
+  # r1 is number of 16bits values to set to 0 (may overrun past end and clear more than specified)
+  vmov HX(0++,0),0 REP 16
+  mov r2,32
+loop:
+  vsth HX(0++,0),(r0+=r2) REP 16
+  add r0,16*16*2
+  sub r1,16*16
+  cmp r1,0
+  bgt loop
+  b lr
-- 
1.9.1


From a3f074c6d9bca3f7de68a36f238b0a66d4cbd619 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 6 May 2015 09:56:43 +0100
Subject: [PATCH 08/77] Prepared inter offload

---
 libavcodec/hevc.c       | 118 +++++++++++++++++++++++++++++++++++++++++++-----
 libavcodec/hevc.h       |  29 +++++++++++-
 libavcodec/hevc_cabac.c |   5 +-
 3 files changed, 138 insertions(+), 14 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 4b3bb44..14909a7 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -43,6 +43,8 @@
 #include "rpi_qpu.h"
 // For some unknown reason, the code seems to crash if I do a late malloc
 #define EARLY_MALLOC
+// Move Inter prediction into separate pass
+//#define RPI_INTER
 #endif
 
 // #define DISABLE_MC
@@ -1404,6 +1406,95 @@ static int hls_pcm_sample(HEVCContext *s, int x0, int y0, int log2_cb_size)
  * @param luma_offset additive offset applied to the luma prediction value
  */
 
+#ifdef RPI_INTER
+#define RPI_REDIRECT(fn) rpi_ ## fn
+static void rpi_luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                        AVFrame *ref, const Mv *mv, int x_off, int y_off,
+                        int block_w, int block_h, int luma_weight, int luma_offset)
+{
+    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
+    cmd->cmd = RPI_CMD_LUMA_UNI;
+    cmd->dst = dst;
+    cmd->dststride = dststride;
+    cmd->src = ref->data[0];
+    cmd->srcstride = ref->linesize[0];
+    cmd->mv = *mv;
+    cmd->x_off = x_off;
+    cmd->y_off = y_off;
+    cmd->block_w = block_w;
+    cmd->block_h = block_h;
+    cmd->weight = luma_weight;
+    cmd->offset = luma_offset;
+} 
+
+static void rpi_luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                       AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
+                       int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)                      
+{  
+    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
+    cmd->cmd = RPI_CMD_LUMA_BI;
+    cmd->dst = dst;
+    cmd->dststride = dststride;
+    cmd->src = ref->data[0];
+    cmd->srcstride = ref->linesize[0];
+    cmd->mv = *mv;
+    cmd->x_off = x_off;
+    cmd->y_off = y_off;
+    cmd->block_w = block_w;
+    cmd->block_h = block_h;
+    cmd->weight = luma_weight;
+    cmd->offset = luma_offset; 
+    cmd->src1 = ref1->data[];
+    cmd->srcstride1 = ref1->linesize[0];
+    cmd->mv1 = *mv1;  
+    cmd->ref_idx[0] = current_mv->ref_idx[0];
+    cmd->ref_idx[1] = current_mv->ref_idx[1];
+}
+
+static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
+                          ptrdiff_t dststride, uint8_t *src0, ptrdiff_t srcstride, int reflist,
+                          int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int chroma_weight, int chroma_offset)
+{
+    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
+    cmd->cmd = RPI_CMD_CHROMA_UNI;
+    cmd->dst = dst0;
+    cmd->dststride = dststride;
+    cmd->src = src0;
+    cmd->srcstride = srcstride;
+    cmd->mv = current_mv->mv[reflist];
+    cmd->x_off = x_off;
+    cmd->y_off = y_off;
+    cmd->block_w = block_w;
+    cmd->block_h = block_h;
+    cmd->weight = chroma_weight;
+    cmd->offset = chroma_offset;
+}
+
+static void chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
+                         int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int cidx)
+{
+    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
+    cmd->cmd = RPI_CMD_CHROMA_BI+cidx;
+    cmd->dst = dst0;
+    cmd->dststride = dststride;
+    cmd->src = ref0->data[cidx+1];
+    cmd->srcstride = ref0->linesize[cidx+1];
+    cmd->mv = current_mv->mv[reflist];
+    cmd->x_off = x_off;
+    cmd->y_off = y_off;
+    cmd->block_w = block_w;
+    cmd->block_h = block_h;
+    cmd->weight = chroma_weight;
+    cmd->offset = chroma_offset;
+    cmd->src = ref1->data[cidx+1];
+    cmd->srcstride1 = ref1->linesize[cidx+1];
+    cmd->ref_idx[0] = current_mv->ref_idx[0];
+    cmd->ref_idx[1] = current_mv->ref_idx[1];
+}
+#else
+#define RPI_REDIRECT(fn) fn
+#endif
+ 
 static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
                         AVFrame *ref, const Mv *mv, int x_off, int y_off,
                         int block_w, int block_h, int luma_weight, int luma_offset)
@@ -1469,7 +1560,7 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
  * @param mv1 motion vector1 (relative to block position) to get pixel data from
  * @param current_mv current motion vector structure
  */
- static void luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+static void luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
                        AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
                        int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)
 {
@@ -1851,16 +1942,16 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int nPbW_c = nPbW >> s->sps->hshift[1];
         int nPbH_c = nPbH >> s->sps->vshift[1];
 
-        luma_mc_uni(s, dst0, s->frame->linesize[0], ref0->frame,
+        RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref0->frame,
                     &current_mv.mv[0], x0, y0, nPbW, nPbH,
                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],
                     s->sh.luma_offset_l0[current_mv.ref_idx[0]]);
 
         if (s->sps->chroma_format_idc) {
-            chroma_mc_uni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],
+            RPI_REDIRECT(chroma_mc_uni)(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],
                           0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);
-            chroma_mc_uni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],
+            RPI_REDIRECT(chroma_mc_uni)(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],
                           0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1]);
         }
@@ -1870,17 +1961,17 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int nPbW_c = nPbW >> s->sps->hshift[1];
         int nPbH_c = nPbH >> s->sps->vshift[1];
 
-        luma_mc_uni(s, dst0, s->frame->linesize[0], ref1->frame,
+        RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref1->frame,
                     &current_mv.mv[1], x0, y0, nPbW, nPbH,
                     s->sh.luma_weight_l1[current_mv.ref_idx[1]],
                     s->sh.luma_offset_l1[current_mv.ref_idx[1]]);
 
         if (s->sps->chroma_format_idc) {
-            chroma_mc_uni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],
+            RPI_REDIRECT(chroma_mc_uni)(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],
                           1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);
 
-            chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],
+            RPI_REDIRECT(chroma_mc_uni)(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],
                           1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]);
         }
@@ -1890,15 +1981,15 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int nPbW_c = nPbW >> s->sps->hshift[1];
         int nPbH_c = nPbH >> s->sps->vshift[1];
 
-        luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame,
+        RPI_REDIRECT(luma_mc_bi)(s, dst0, s->frame->linesize[0], ref0->frame,
                    &current_mv.mv[0], x0, y0, nPbW, nPbH,
                    ref1->frame, &current_mv.mv[1], &current_mv);
 
         if (s->sps->chroma_format_idc) {
-            chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,
+            RPI_REDIRECT(chroma_mc_bi)(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,
                          x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);
 
-            chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,
+            RPI_REDIRECT(chroma_mc_bi)(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,
                          x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1);
         }
     }
@@ -2429,7 +2520,9 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
       } else {
           int trafo_size = 1 << cmd->size;
           s->hevcdsp.transform_add[cmd->size-2](cmd->dst, cmd->buf, cmd->stride);
-          memset(cmd->buf, 0, trafo_size * trafo_size * sizeof(int16_t)); // Clear coefficients here while they are in the cache
+#ifdef RPI_PRECLEAR
+          memset(cmd->buf, 0, trafo_size * trafo_size * sizeof(int16_t)); // Clear coefficients here while they are in the cache    
+#endif
       }
   }
   s->num_pred_cmds = 0;
@@ -3506,6 +3599,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
     s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
     printf("Done\n");
+#ifdef RPI_PRECLEAR
     //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
     memclear16(s->coeffs_buf_arm[0], coefs_per_row);
     //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
@@ -3513,6 +3607,8 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
     memclear16(s->coeffs_buf_arm[3], coefs_per_row);
 #endif
+    
+#endif
 
     s->enable_rpi = 0;
     
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 938e45b..2d7f0f8 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -799,14 +799,39 @@ typedef struct HEVCLocalContext {
 // RPI_MAX_WIDTH is maximum width in pixels supported by the accelerated code
 #define RPI_MAX_WIDTH 2048
 
-// Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane
-#define RPI_MAX_MV_CMDS   (16*3*(RPI_MAX_WIDTH/4))
+// Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane, * 2 for bi
+#define RPI_MAX_MV_CMDS   (2*16*3*(RPI_MAX_WIDTH/4))
 #define RPI_MAX_XFM_CMDS  (16*3*(RPI_MAX_WIDTH/4))
 // Each block can have an intra prediction and a transform_add command
 #define RPI_MAX_PRED_CMDS (2*16*3*(RPI_MAX_WIDTH/4))
 
+#define RPI_CMD_LUMA_UNI 0
+#define RPI_CMD_CHROMA_UNI 1
+#define RPI_CMD_LUMA_BI 2
+#define RPI_CMD_U_BI 3
+#define RPI_CMD_V_BI 4
+
+// RPI_PRECLEAR is not working yet - perhaps clearing on VPUs is flawed?
+// #define RPI_PRECLEAR
+
 // Command for inter prediction
 typedef struct HEVCMvCmd {
+    int cmd;
+    uint8_t *dst;
+    ptrdiff_t dststride;
+    uint8_t *src;
+    ptrdiff_t srcstride;
+    Mv mv;
+    int x_off;
+    int y_off;
+    int block_w;
+    int block_h;
+    int weight;
+    int offset;
+    uint8_t *src1;
+    ptrdiff_t srcstride1;
+    Mv mv1;
+    int8_t ref_idx[2];
 } HEVCMvCmd;
 
 // Command for transform to process a block of coefficients
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index 5ed952a..f2ff50d 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1105,7 +1105,10 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
         }
     }
     // We now do the memset after transform_add while we know the data is cached.
-    //memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
+    #ifdef RPI_PRECLEAR
+    #else
+    memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
+    #endif
 #else
     memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
 #endif
-- 
1.9.1


From 46664008d97b2130db6850503dbf70686b779b44 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 6 May 2015 11:08:50 +0100
Subject: [PATCH 09/77] Inter prediction in separate pass

---
 libavcodec/hevc.c | 93 +++++++++++++++++++++++++++++++++++++++++++++----------
 libavcodec/hevc.h |  2 +-
 2 files changed, 77 insertions(+), 18 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 14909a7..cb08404 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -44,7 +44,7 @@
 // For some unknown reason, the code seems to crash if I do a late malloc
 #define EARLY_MALLOC
 // Move Inter prediction into separate pass
-//#define RPI_INTER
+#define RPI_INTER
 #endif
 
 // #define DISABLE_MC
@@ -1412,7 +1412,7 @@ static void rpi_luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
                         AVFrame *ref, const Mv *mv, int x_off, int y_off,
                         int block_w, int block_h, int luma_weight, int luma_offset)
 {
-    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
+    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
     cmd->cmd = RPI_CMD_LUMA_UNI;
     cmd->dst = dst;
     cmd->dststride = dststride;
@@ -1431,31 +1431,29 @@ static void rpi_luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
                        AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
                        int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)                      
 {  
-    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
+    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
     cmd->cmd = RPI_CMD_LUMA_BI;
     cmd->dst = dst;
     cmd->dststride = dststride;
-    cmd->src = ref->data[0];
-    cmd->srcstride = ref->linesize[0];
-    cmd->mv = *mv;
+    cmd->src = ref0->data[0];
+    cmd->srcstride = ref0->linesize[0];
+    cmd->mv = *mv0;
     cmd->x_off = x_off;
     cmd->y_off = y_off;
     cmd->block_w = block_w;
     cmd->block_h = block_h;
-    cmd->weight = luma_weight;
-    cmd->offset = luma_offset; 
-    cmd->src1 = ref1->data[];
+    cmd->src1 = ref1->data[0];
     cmd->srcstride1 = ref1->linesize[0];
     cmd->mv1 = *mv1;  
     cmd->ref_idx[0] = current_mv->ref_idx[0];
     cmd->ref_idx[1] = current_mv->ref_idx[1];
 }
 
-static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
+static void rpi_chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
                           ptrdiff_t dststride, uint8_t *src0, ptrdiff_t srcstride, int reflist,
                           int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int chroma_weight, int chroma_offset)
 {
-    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
+    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
     cmd->cmd = RPI_CMD_CHROMA_UNI;
     cmd->dst = dst0;
     cmd->dststride = dststride;
@@ -1470,27 +1468,27 @@ static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
     cmd->offset = chroma_offset;
 }
 
-static void chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
+static void rpi_chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
                          int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int cidx)
 {
-    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
+    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
     cmd->cmd = RPI_CMD_CHROMA_BI+cidx;
     cmd->dst = dst0;
     cmd->dststride = dststride;
     cmd->src = ref0->data[cidx+1];
     cmd->srcstride = ref0->linesize[cidx+1];
-    cmd->mv = current_mv->mv[reflist];
+    cmd->mv = current_mv->mv[0];
+    cmd->mv1 = current_mv->mv[1];
     cmd->x_off = x_off;
     cmd->y_off = y_off;
     cmd->block_w = block_w;
     cmd->block_h = block_h;
-    cmd->weight = chroma_weight;
-    cmd->offset = chroma_offset;
-    cmd->src = ref1->data[cidx+1];
+    cmd->src1 = ref1->data[cidx+1];
     cmd->srcstride1 = ref1->linesize[cidx+1];
     cmd->ref_idx[0] = current_mv->ref_idx[0];
     cmd->ref_idx[1] = current_mv->ref_idx[1];
 }
+
 #else
 #define RPI_REDIRECT(fn) fn
 #endif
@@ -2518,7 +2516,9 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
           lc->na.cand_up_right     = (cmd->na >> 0) & 1;
           s->hpc.intra_pred[cmd->size - 2](s, cmd->x, cmd->y, cmd->c_idx);
       } else {
+#ifdef RPI_PRECLEAR      
           int trafo_size = 1 << cmd->size;
+#endif          
           s->hevcdsp.transform_add[cmd->size-2](cmd->dst, cmd->buf, cmd->stride);
 #ifdef RPI_PRECLEAR
           memset(cmd->buf, 0, trafo_size * trafo_size * sizeof(int16_t)); // Clear coefficients here while they are in the cache    
@@ -2527,6 +2527,61 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
   }
   s->num_pred_cmds = 0;
 }
+
+static void rpi_execute_inter_cmds(HEVCContext *s)
+{
+    HEVCMvCmd *cmd = s->unif_mv_cmds;
+    int n,cidx;
+    AVFrame myref;
+    AVFrame myref1;
+    struct MvField mymv;
+    if (s->num_mv_cmds > RPI_MAX_MV_CMDS) { 
+        printf("Overflow inter_cmds\n");
+        exit(-1);
+    }
+    for(n = s->num_mv_cmds; n>0 ; n--, cmd++) {
+        switch(cmd->cmd) {
+        case RPI_CMD_LUMA_UNI:
+            myref.data[0] = cmd->src;
+            myref.linesize[0] = cmd->srcstride;
+            luma_mc_uni(s, cmd->dst, cmd->dststride, &myref, &cmd->mv, cmd->x_off, cmd->y_off, cmd->block_w, cmd->block_h, cmd->weight, cmd->offset);
+            break;
+        case RPI_CMD_LUMA_BI:
+            myref.data[0] = cmd->src;
+            myref.linesize[0] = cmd->srcstride;
+            myref1.data[0] = cmd->src1;
+            myref1.linesize[0] = cmd->srcstride1;
+            mymv.ref_idx[0] = cmd->ref_idx[0];
+            mymv.ref_idx[1] = cmd->ref_idx[1];
+            luma_mc_bi(s, cmd->dst, cmd->dststride,
+                       &myref, &cmd->mv, cmd->x_off, cmd->y_off, cmd->block_w, cmd->block_h,
+                       &myref1, &cmd->mv1, &mymv);
+            break;
+        case RPI_CMD_CHROMA_UNI:
+            mymv.mv[0] = cmd->mv;
+            chroma_mc_uni(s, cmd->dst,
+                          cmd->dststride, cmd->src, cmd->srcstride, 0,
+                          cmd->x_off, cmd->y_off, cmd->block_w, cmd->block_h, &mymv, cmd->weight, cmd->offset);
+            break;
+        case RPI_CMD_CHROMA_BI:
+        case RPI_CMD_CHROMA_BI+1:
+            cidx = cmd->cmd - RPI_CMD_CHROMA_BI;
+            myref.data[cidx+1] = cmd->src;
+            myref.linesize[cidx+1] = cmd->srcstride;
+            myref1.data[cidx+1] = cmd->src1;
+            myref1.linesize[cidx+1] = cmd->srcstride1;
+            mymv.ref_idx[0] = cmd->ref_idx[0];
+            mymv.ref_idx[1] = cmd->ref_idx[1];
+            mymv.mv[0] = cmd->mv;
+            mymv.mv[1] = cmd->mv1;
+            chroma_mc_bi(s, cmd->dst, cmd->dststride, &myref, &myref1,
+                         cmd->x_off, cmd->y_off, cmd->block_w, cmd->block_h, &mymv, cidx);
+            break; 
+        }
+    }
+    s->num_mv_cmds = 0;
+}
+
 #endif
 
 static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
@@ -2575,6 +2630,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 #ifdef RPI
         if (s->enable_rpi && x_ctb + ctb_size >= s->sps->width) {
             int x;
+            // Perform inter prediction
+            rpi_execute_inter_cmds(s);
             // Transform all blocks
             rpi_execute_transform(s);
             // Perform intra prediction and residual reconstruction
@@ -3547,6 +3604,7 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
 }
 
 #ifdef RPI
+#ifdef RPI_PRECLEAR
 static av_cold void memclear16(int16_t *p, int n)
 {
   vpu_execute_code( vpu_get_fn(), p, n, 0, 0, 0, 1);
@@ -3555,6 +3613,7 @@ static av_cold void memclear16(int16_t *p, int n)
   //  p[i] = 0;
 }
 #endif
+#endif
 
 static av_cold int hevc_init_context(AVCodecContext *avctx)
 {
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 2d7f0f8..e7e923b 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -808,7 +808,7 @@ typedef struct HEVCLocalContext {
 #define RPI_CMD_LUMA_UNI 0
 #define RPI_CMD_CHROMA_UNI 1
 #define RPI_CMD_LUMA_BI 2
-#define RPI_CMD_U_BI 3
+#define RPI_CMD_CHROMA_BI 3
 #define RPI_CMD_V_BI 4
 
 // RPI_PRECLEAR is not working yet - perhaps clearing on VPUs is flawed?
-- 
1.9.1


From 244f4611b63312fba60e32efc615db93a2888be0 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 6 May 2015 13:03:50 +0100
Subject: [PATCH 10/77] Added VPU thread

---
 libavcodec/hevc.c    |  11 +++--
 libavcodec/hevc.h    |   1 +
 libavcodec/rpi_qpu.c | 118 +++++++++++++++++++++++++++++++++++++++++++++++++--
 libavcodec/rpi_qpu.h |   2 +
 4 files changed, 126 insertions(+), 6 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index cb08404..16eb48b 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2493,8 +2493,10 @@ static void rpi_execute_transform(HEVCContext *s)
     
     
     gpu_cache_flush(&s->coeffs_buf_accelerated);
-    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
+    s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
+    //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
     //gpu_cache_flush(&s->coeffs_buf_accelerated);
+    //vpu_wait(s->vpu_id);
     
     for(i=0;i<4;i++)
         s->num_coeffs[i] = 0;
@@ -2630,10 +2632,12 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 #ifdef RPI
         if (s->enable_rpi && x_ctb + ctb_size >= s->sps->width) {
             int x;
-            // Perform inter prediction
-            rpi_execute_inter_cmds(s);
             // Transform all blocks
             rpi_execute_transform(s);
+            // Perform inter prediction
+            rpi_execute_inter_cmds(s);
+            // Wait for transform completion
+            vpu_wait(s->vpu_id);
             // Perform intra prediction and residual reconstruction
             rpi_execute_pred_cmds(s);
             // Perform deblocking for CTBs in this row
@@ -3548,6 +3552,7 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
     av_freep(&s->univ_pred_cmds);
     
 #ifdef EARLY_MALLOC
+    printf("hevc_decode_free\n");
     if (s->coeffs_buf_arm[0]) {
       gpu_free(&s->coeffs_buf_default);
       s->coeffs_buf_arm[0] = 0;
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index e7e923b..af1f867 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -892,6 +892,7 @@ typedef struct HEVCContext {
     int num_xfm_cmds;
     int num_mv_cmds;
     int num_pred_cmds;
+    int vpu_id;
 #endif
 
     uint8_t *cabac_state;
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 90f504a..98cacf5 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -1,8 +1,12 @@
-// Use the vcsm device for shared memory
+// define RPI_USE_VCSM to use the vcsm device for shared memory
 // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
 #define RPI_USE_VCSM
-#define RPI_TIME_TOTAL_QPU
-#define RPI_TIME_TOTAL_VPU
+// define RPI_TIME_TOTAL_QPU to print out how much time is spent in the QPU code
+//#define RPI_TIME_TOTAL_QPU
+// define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
+//#define RPI_TIME_TOTAL_VPU
+// define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
+#define RPI_ASYNC
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -110,6 +114,19 @@ static unsigned int Microseconds(void) {
 }
 #endif
 
+#ifdef RPI_ASYNC
+pthread_t vpu_thread;
+static void *vpu_start(void *arg);
+
+#define MAXCMDS 128
+static pthread_cond_t post_cond = PTHREAD_COND_INITIALIZER;
+static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static int vpu_cmds[MAXCMDS][7];
+static volatile int vpu_async_tail=0; // Contains the number of posted jobs
+static volatile int vpu_async_head=0;
+#endif
+
 // Connect to QPU, returns 0 on success.
 static int gpu_init(volatile struct GPU **gpu) {
   int mb = mbox_open();
@@ -161,12 +178,27 @@ static int gpu_init(volatile struct GPU **gpu) {
   // And the transform coefficients
   memcpy((void*)ptr->transMatrix2even, rpi_transMatrix2even, sizeof(rpi_transMatrix2even));
   
+#ifdef RPI_ASYNC
+  {
+    int err;
+    vpu_async_tail = 0;
+    vpu_async_head = 0;
+    err = pthread_create(&vpu_thread, NULL, vpu_start, NULL);
+    //printf("Created thread\n");
+    if (err) {
+        printf("Failed to create vpu thread\n");
+        return -4;
+    }
+  }
+#endif
+  
   return 0;
 }
 
 // Make sure we have exclusive access to the mailbox, and enable qpu if necessary.
 static void gpu_lock(void) {
   pthread_mutex_lock(&gpu_mutex);
+  
   if (gpu==NULL) {
     gpu_init(&gpu);
   }
@@ -261,6 +293,16 @@ static void gpu_term(void)
 	unsigned handle = gpu->vc_handle;
   if (gpu==NULL) 
     return;
+  
+#ifdef RPI_ASYNC
+  {
+    void *res;
+    vpu_post_code(0, 0, 0, 0, 0, 0, -1);
+    pthread_join(vpu_thread, &res);    
+  }
+#endif
+    
+    
 	unmapmem((void*)gpu, sizeof(struct GPU));
 	mem_unlock(mb, handle);
 	mem_free(mb, handle);
@@ -319,6 +361,72 @@ unsigned int vpu_get_constants(void) {
   return gpu->vc + offsetof(struct GPU,transMatrix2even);
 }
 
+#ifdef RPI_ASYNC
+
+static void *vpu_start(void *arg) {
+  while(1) {
+    pthread_mutex_lock(&post_mutex);
+    while( vpu_async_tail - vpu_async_head <= 0)
+    {
+      //printf("Checking number %d %d\n",vpu_async_head,vpu_async_tail);
+      pthread_cond_wait(&post_cond, &post_mutex);
+    }
+    int *p = vpu_cmds[vpu_async_head%MAXCMDS];
+    pthread_mutex_unlock(&post_mutex);
+    
+    if (p[6] == -1) {
+      break; // Last job
+    }
+    vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
+    
+    vpu_async_head++;
+    pthread_cond_broadcast(&post_cond);
+  }
+  
+  return NULL;
+}
+
+// Post a command to the queue
+// Returns an id which we can use to wait for completion
+int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
+{
+  pthread_mutex_lock(&post_mutex);
+  {
+    int id = vpu_async_tail++;
+    int *p = vpu_cmds[id%MAXCMDS];
+    int num = vpu_async_tail - vpu_async_head;
+    if (num>MAXCMDS) {
+      printf("Too many commands submitted\n");
+      exit(-1);
+    }
+    p[0] = code;
+    p[1] = r0;
+    p[2] = r1;
+    p[3] = r2;
+    p[4] = r3;
+    p[5] = r4;
+    p[6] = r5;
+    if (num<=1)
+      pthread_cond_broadcast(&post_cond); // Otherwise the vpu thread must already be awake
+    pthread_mutex_unlock(&post_mutex);
+    return id;
+  }
+}
+
+// Wait for completion of the given command
+void vpu_wait(int id)
+{
+  pthread_mutex_lock(&post_mutex);
+  while( id + 1 - vpu_async_head > 0)
+  {
+    pthread_cond_wait(&post_cond, &post_mutex);
+  }
+  pthread_mutex_unlock(&post_mutex);
+}
+
+#endif
+
+
 unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
 {
   unsigned r;
@@ -331,7 +439,9 @@ unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2,
   static int count=0;
   static long long countr2=0;
 #endif
+#ifndef RPI_ASYNC
   gpu_lock();
+#endif
 #ifdef RPI_TIME_TOTAL_VPU
   start_time = Microseconds();
   if (last_time==0)
@@ -348,7 +458,9 @@ unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2,
   if ((count&0x7f)==0)
     printf("VPU %d %lld On=%dms, Off=%dms\n",count,countr2,(int)(on_time/1000),(int)(off_time/1000));
 #endif
+#ifndef RPI_ASYNC
   gpu_unlock();
+#endif
   return r;
 }
 
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index 814fc3c..7dc661a 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -36,6 +36,8 @@ extern unsigned int qpu_get_fn(int num);
 extern unsigned int vpu_get_fn(void);
 extern unsigned int vpu_get_constants(void);
 extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+extern int vpu_post_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+extern void vpu_wait( int id);
 
 // Simple test of shader code
 extern int rpi_test_shader(void);
-- 
1.9.1


From c693045313bf4367f85b3b12c98032c18fda604f Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 6 May 2015 14:02:38 +0100
Subject: [PATCH 11/77] Corrected movement of head pointer

---
 libavcodec/hevc.c    |  2 +-
 libavcodec/rpi_qpu.c | 13 ++++++++++---
 libavcodec/rpi_qpu.h |  2 +-
 3 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 16eb48b..d368cd6 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2493,7 +2493,7 @@ static void rpi_execute_transform(HEVCContext *s)
     
     
     gpu_cache_flush(&s->coeffs_buf_accelerated);
-    s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
+    s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0, &s->coeffs_buf_accelerated);
     //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
     //gpu_cache_flush(&s->coeffs_buf_accelerated);
     //vpu_wait(s->vpu_id);
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 98cacf5..966a042 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -122,7 +122,7 @@ static void *vpu_start(void *arg);
 static pthread_cond_t post_cond = PTHREAD_COND_INITIALIZER;
 static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-static int vpu_cmds[MAXCMDS][7];
+static int vpu_cmds[MAXCMDS][8];
 static volatile int vpu_async_tail=0; // Contains the number of posted jobs
 static volatile int vpu_async_head=0;
 #endif
@@ -297,7 +297,7 @@ static void gpu_term(void)
 #ifdef RPI_ASYNC
   {
     void *res;
-    vpu_post_code(0, 0, 0, 0, 0, 0, -1);
+    vpu_post_code(0, 0, 0, 0, 0, 0, -1, NULL);
     pthread_join(vpu_thread, &res);    
   }
 #endif
@@ -377,10 +377,16 @@ static void *vpu_start(void *arg) {
     if (p[6] == -1) {
       break; // Last job
     }
+    if (p[7]) {
+        GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
+        //gpu_cache_flush(buf);
+    }
     vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
     
+    pthread_mutex_lock(&post_mutex);
     vpu_async_head++;
     pthread_cond_broadcast(&post_cond);
+    pthread_mutex_unlock(&post_mutex);
   }
   
   return NULL;
@@ -388,7 +394,7 @@ static void *vpu_start(void *arg) {
 
 // Post a command to the queue
 // Returns an id which we can use to wait for completion
-int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
+int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf)
 {
   pthread_mutex_lock(&post_mutex);
   {
@@ -406,6 +412,7 @@ int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned
     p[4] = r3;
     p[5] = r4;
     p[6] = r5;
+    p[7] = (int) buf;
     if (num<=1)
       pthread_cond_broadcast(&post_cond); // Otherwise the vpu thread must already be awake
     pthread_mutex_unlock(&post_mutex);
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index 7dc661a..3526fce 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -36,7 +36,7 @@ extern unsigned int qpu_get_fn(int num);
 extern unsigned int vpu_get_fn(void);
 extern unsigned int vpu_get_constants(void);
 extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
-extern int vpu_post_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+extern int vpu_post_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf);
 extern void vpu_wait( int id);
 
 // Simple test of shader code
-- 
1.9.1


From 3ad41b8017bbe62146332d3fc6fb8727040d88e9 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 6 May 2015 15:03:37 +0100
Subject: [PATCH 12/77] Added different signal when tail moves

---
 libavcodec/rpi_qpu.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 966a042..8e8805c 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -119,7 +119,8 @@ pthread_t vpu_thread;
 static void *vpu_start(void *arg);
 
 #define MAXCMDS 128
-static pthread_cond_t post_cond = PTHREAD_COND_INITIALIZER;
+static pthread_cond_t post_cond_head = PTHREAD_COND_INITIALIZER;
+static pthread_cond_t post_cond_tail = PTHREAD_COND_INITIALIZER;
 static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static int vpu_cmds[MAXCMDS][8];
@@ -369,7 +370,7 @@ static void *vpu_start(void *arg) {
     while( vpu_async_tail - vpu_async_head <= 0)
     {
       //printf("Checking number %d %d\n",vpu_async_head,vpu_async_tail);
-      pthread_cond_wait(&post_cond, &post_mutex);
+      pthread_cond_wait(&post_cond_tail, &post_mutex);
     }
     int *p = vpu_cmds[vpu_async_head%MAXCMDS];
     pthread_mutex_unlock(&post_mutex);
@@ -385,7 +386,7 @@ static void *vpu_start(void *arg) {
     
     pthread_mutex_lock(&post_mutex);
     vpu_async_head++;
-    pthread_cond_broadcast(&post_cond);
+    pthread_cond_broadcast(&post_cond_head);
     pthread_mutex_unlock(&post_mutex);
   }
   
@@ -414,7 +415,7 @@ int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned
     p[6] = r5;
     p[7] = (int) buf;
     if (num<=1)
-      pthread_cond_broadcast(&post_cond); // Otherwise the vpu thread must already be awake
+      pthread_cond_broadcast(&post_cond_tail); // Otherwise the vpu thread must already be awake
     pthread_mutex_unlock(&post_mutex);
     return id;
   }
@@ -426,7 +427,7 @@ void vpu_wait(int id)
   pthread_mutex_lock(&post_mutex);
   while( id + 1 - vpu_async_head > 0)
   {
-    pthread_cond_wait(&post_cond, &post_mutex);
+    pthread_cond_wait(&post_cond_head, &post_mutex);
   }
   pthread_mutex_unlock(&post_mutex);
 }
-- 
1.9.1


From 80314c0b1e9d168d5f6b3d300b568c223470244b Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 7 May 2015 08:57:11 +0100
Subject: [PATCH 13/77] Add option to test for gpu_idle

---
 libavcodec/hevc.c    |  3 ++-
 libavcodec/rpi_qpu.c | 18 ++++++++++++++++++
 2 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index d368cd6..f6fb432 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2491,7 +2491,6 @@ static void rpi_execute_transform(HEVCContext *s)
     //    s->hevcdsp.idct[4-2](coeffs, 16);
     //}
     
-    
     gpu_cache_flush(&s->coeffs_buf_accelerated);
     s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0, &s->coeffs_buf_accelerated);
     //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
@@ -2633,6 +2632,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
         if (s->enable_rpi && x_ctb + ctb_size >= s->sps->width) {
             int x;
             // Transform all blocks
+            //printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+    
             rpi_execute_transform(s);
             // Perform inter prediction
             rpi_execute_inter_cmds(s);
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 8e8805c..1da2edc 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -196,6 +196,17 @@ static int gpu_init(volatile struct GPU **gpu) {
   return 0;
 }
 
+// Returns 1 if the gpu is currently idle
+static int gpu_idle(void)
+{
+  int ret = pthread_mutex_trylock(&gpu_mutex);
+  if (ret==0) {
+    pthread_mutex_unlock(&gpu_mutex);
+    return 1;
+  }
+  return 0;
+}
+
 // Make sure we have exclusive access to the mailbox, and enable qpu if necessary.
 static void gpu_lock(void) {
   pthread_mutex_lock(&gpu_mutex);
@@ -397,6 +408,13 @@ static void *vpu_start(void *arg) {
 // Returns an id which we can use to wait for completion
 int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf)
 {
+  // If the gpu is idle then just run the command immediately
+  // This works, but doesn't seem to give any benefit
+  // if (gpu_idle()) {
+  //   vpu_execute_code( code,  r0,  r1,  r2,  r3,  r4,  r5);
+  //   return -1; // TODO perhaps a wraparound bug here?
+  // }
+    
   pthread_mutex_lock(&post_mutex);
   {
     int id = vpu_async_tail++;
-- 
1.9.1


From 6ab4eb832d9236360138ae54ca599ba5d031d023 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 7 May 2015 11:01:35 +0100
Subject: [PATCH 14/77] Added deblocking pass

---
 libavcodec/hevc.c        | 33 +++++++++++++++++++++++++++------
 libavcodec/hevc.h        |  7 ++++++-
 libavcodec/hevc_filter.c |  6 +++++-
 libavcodec/rpi_qpu.c     |  2 +-
 4 files changed, 39 insertions(+), 9 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index f6fb432..3c3c9e8 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2482,6 +2482,17 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
 }
 
 #ifdef RPI
+static void rpi_execute_dblk_cmds(HEVCContext *s)
+{
+    int n;
+    int ctb_size    = 1 << s->sps->log2_ctb_size;
+    int (*p)[2] = s->dblk_cmds;
+    for(n = s->num_dblk_cmds; n>0 ;n--,p++) {
+        ff_hevc_hls_filters(s, (*p)[0], (*p)[1], ctb_size);
+    }
+    s->num_dblk_cmds = 0;
+}        
+            
 static void rpi_execute_transform(HEVCContext *s)
 {
     int i=2;
@@ -2595,7 +2606,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
 
 #ifdef RPI
-    int start_ctb_x = (s->sh.slice_ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;
     s->enable_rpi = 1; // TODO this should depend on cross component and frame width etc.
 #endif
 
@@ -2629,7 +2639,10 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 
         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);
 #ifdef RPI
-        if (s->enable_rpi && x_ctb + ctb_size >= s->sps->width) {
+        if (s->enable_rpi) {
+          s->dblk_cmds[s->num_dblk_cmds][0] = x_ctb;
+          s->dblk_cmds[s->num_dblk_cmds++][1] = y_ctb;
+          if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->sps->width) {
             int x;
             // Transform all blocks
             //printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
@@ -2642,10 +2655,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
             // Perform intra prediction and residual reconstruction
             rpi_execute_pred_cmds(s);
             // Perform deblocking for CTBs in this row
-            for(x = start_ctb_x; x <= x_ctb; x += ctb_size) {  // TODO this will fail for tiles
-                ff_hevc_hls_filters(s, x, y_ctb, ctb_size);
-            }
-            start_ctb_x = 0;
+            rpi_execute_dblk_cmds(s);
+          }
         }
 #endif
         if (more_data < 0) {
@@ -2662,6 +2673,16 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 #endif
         ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);
     }
+    
+#ifdef RPI
+    if (s->enable_rpi && s->num_dblk_cmds) {
+        rpi_execute_transform(s);
+        rpi_execute_inter_cmds(s);
+        vpu_wait(s->vpu_id);
+        rpi_execute_pred_cmds(s);
+        rpi_execute_dblk_cmds(s);
+    }
+#endif
 
     if (x_ctb + ctb_size >= s->sps->width &&
         y_ctb + ctb_size >= s->sps->height)
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index af1f867..c0e2efd 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -804,6 +804,8 @@ typedef struct HEVCLocalContext {
 #define RPI_MAX_XFM_CMDS  (16*3*(RPI_MAX_WIDTH/4))
 // Each block can have an intra prediction and a transform_add command
 #define RPI_MAX_PRED_CMDS (2*16*3*(RPI_MAX_WIDTH/4))
+// Worst case is 16x16 CTUs
+#define RPI_MAX_DEBLOCK_CMDS (RPI_MAX_WIDTH*4/16)
 
 #define RPI_CMD_LUMA_UNI 0
 #define RPI_CMD_CHROMA_UNI 1
@@ -863,6 +865,9 @@ typedef struct HEVCPredCmd {
 #endif
 
 typedef struct HEVCContext {
+#ifdef RPI
+    int dblk_cmds[RPI_MAX_DEBLOCK_CMDS][2];
+#endif
     const AVClass *c;  // needed by private avoptions
     AVCodecContext *avctx;
 
@@ -887,11 +892,11 @@ typedef struct HEVCContext {
     GPU_MEM_PTR_T coeffs_buf_accelerated;
     int16_t *coeffs_buf_arm[4];
     unsigned int coeffs_buf_vc[4];
-    
     int num_coeffs[4];
     int num_xfm_cmds;
     int num_mv_cmds;
     int num_pred_cmds;
+    int num_dblk_cmds;
     int vpu_id;
 #endif
 
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index c7fbc75..b51400a 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -876,8 +876,12 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
             if (s->threads_type & FF_THREAD_FRAME )
                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
         }
-    } else if (s->threads_type & FF_THREAD_FRAME && x_end)
+    } else if (s->threads_type & FF_THREAD_FRAME && x_end) {
+        int newh = y + ctb_size - 4;
+        //int currh = s->ref->tf.progress->data[0];
+        //if (((y + ctb_size)&63)==0)
         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
+    }
 }
 
 void ff_hevc_hls_filters(HEVCContext *s, int x_ctb, int y_ctb, int ctb_size)
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 1da2edc..2dd2a8e 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -102,7 +102,7 @@ struct GPU
 static pthread_mutex_t gpu_mutex = PTHREAD_MUTEX_INITIALIZER;
 static volatile struct GPU* gpu = NULL;
 
-#ifdef RPI_TIME_TOTAL_QPU
+#if defined(RPI_TIME_TOTAL_QPU) || defined(RPI_TIME_TOTAL_VPU)
 static unsigned int Microseconds(void) {
     struct timespec ts;
     unsigned int x;
-- 
1.9.1


From 08c0c64830cbdb77a75980a4e5dd03a19a18eb37 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 7 May 2015 16:47:47 +0100
Subject: [PATCH 15/77] Added option to disable deblocking for non-ref frames

---
 libavcodec/hevc_filter.c | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index b51400a..c275b0c 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -25,6 +25,8 @@
 //#define DISABLE_SAO
 //#define DISABLE_DEBLOCK
 //#define DISABLE_STRENGTHS
+// define DISABLE_DEBLOCK_NONREF for a 6% speed boost (by skipping deblocking on unimportant frames)
+//#define DISABLE_DEBLOCK_NONREF
 
 #include "libavutil/common.h"
 #include "libavutil/internal.h"
@@ -503,7 +505,14 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
     int pcmf = (s->sps->pcm_enabled_flag &&
                 s->sps->pcm.loop_filter_disable_flag) ||
                s->pps->transquant_bypass_enable_flag;
-               
+#ifdef DISABLE_DEBLOCK_NONREF    
+    if (    s->nal_unit_type == NAL_TRAIL_N ||
+            s->nal_unit_type == NAL_TSA_N   ||
+            s->nal_unit_type == NAL_STSA_N  ||
+            s->nal_unit_type == NAL_RADL_N  ||
+            s->nal_unit_type == NAL_RASL_N )
+      return; // Don't deblock non-reference frames
+#endif
 #ifdef DISABLE_DEBLOCK
     return;
 #endif               
-- 
1.9.1


From ce9dc9925b9850eb8f00dd7e7ebb0549cb488405 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Mon, 11 May 2015 10:00:27 +0100
Subject: [PATCH 16/77] Moved buffers to VPU memory

---
 libavcodec/hevc_filter.c | 15 ++++++++++++-
 libavcodec/utils.c       | 55 ++++++++++++++++++++++++++++++++++++++++++++++++
 libavutil/buffer.c       |  6 ++++++
 libavutil/buffer.h       |  3 +++
 4 files changed, 78 insertions(+), 1 deletion(-)

diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index c275b0c..8e96bbe 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -865,6 +865,11 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
 #undef CB
 #undef CR
 
+static void flush_buffer(AVBufferRef *bref) {
+    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+    gpu_cache_flush(p);
+}
+
 void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
 {
     int x_end = x >= s->sps->width  - ctb_size;
@@ -886,9 +891,17 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
         }
     } else if (s->threads_type & FF_THREAD_FRAME && x_end) {
-        int newh = y + ctb_size - 4;
+        //int newh = y + ctb_size - 4;
         //int currh = s->ref->tf.progress->data[0];
         //if (((y + ctb_size)&63)==0)
+        if (!(  s->nal_unit_type == NAL_TRAIL_N ||
+            s->nal_unit_type == NAL_TSA_N   ||
+            s->nal_unit_type == NAL_STSA_N  ||
+            s->nal_unit_type == NAL_RADL_N  ||
+            s->nal_unit_type == NAL_RASL_N )) {
+            flush_buffer(s->frame->buf[1]);
+            flush_buffer(s->frame->buf[2]);
+        }
         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
     }
 }
diff --git a/libavcodec/utils.c b/libavcodec/utils.c
index 40dde88..58fd4f5 100644
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -24,6 +24,9 @@
  * @file
  * utils.
  */
+ 
+// Move video buffers to GPU memory
+#define RPI_GPU_BUFFERS
 
 #include "config.h"
 #include "libavutil/atomic.h"
@@ -69,6 +72,10 @@
 #include "libavutil/ffversion.h"
 const char av_codec_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
 
+#ifdef RPI_GPU_BUFFERS
+#include "rpi_qpu.h"
+#endif
+
 #if HAVE_PTHREADS || HAVE_W32THREADS || HAVE_OS2THREADS
 static int default_lockmgr_cb(void **arg, enum AVLockOp op)
 {
@@ -507,6 +514,47 @@ int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,
     return ret;
 }
 
+#ifdef RPI_GPU_BUFFERS
+static void rpi_buffer_default_free(void *opaque, uint8_t *data)
+{
+    GPU_MEM_PTR_T *p = opaque;
+    gpu_free(p);
+    av_free(p);
+}
+
+static AVBufferRef *rpi_buffer_alloc(int size)
+{
+    AVBufferRef *ret = NULL;
+    uint8_t    *data = NULL;
+    GPU_MEM_PTR_T *p;
+    
+    static int total=0;
+    total+=size;
+    
+    p = av_malloc(sizeof *p);
+    if (!p)
+        return NULL;
+        
+    if (gpu_malloc_cached(size,p)<0)  // Change this line to choose cached or uncached memory.  The caching here refers to the ARM data cache.
+        return NULL;
+
+    data = p->arm;
+    //printf("Rpi alloc %d/%d ARM=%p VC=%x\n",size,total,p->arm,p->vc);
+    //memset(data, 64, size);
+    
+    if (!data)
+        return NULL;
+
+    ret = av_buffer_create(data, size, rpi_buffer_default_free, p, 0);
+    if (!ret) {
+        gpu_free(p);
+        av_freep(&p);
+    }
+
+    return ret;
+}
+#endif
+
 static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
 {
     FramePool *pool = avctx->internal->pool;
@@ -551,10 +599,17 @@ static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
             av_buffer_pool_uninit(&pool->pools[i]);
             pool->linesize[i] = picture.linesize[i];
             if (size[i]) {
+#ifdef RPI_GPU_BUFFERS
+                pool->pools[i] = av_buffer_pool_init(size[i] + 16 + STRIDE_ALIGN - 1,
+                                                     CONFIG_MEMORY_POISONING ?
+                                                        NULL :
+                                                        rpi_buffer_alloc);
+#else
                 pool->pools[i] = av_buffer_pool_init(size[i] + 16 + STRIDE_ALIGN - 1,
                                                      CONFIG_MEMORY_POISONING ?
                                                         NULL :
                                                         av_buffer_allocz);
+#endif                                                        
                 if (!pool->pools[i]) {
                     ret = AVERROR(ENOMEM);
                     goto fail;
diff --git a/libavutil/buffer.c b/libavutil/buffer.c
index bb112c2..7f8bfab 100644
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -400,3 +400,9 @@ AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
 
     return ret;
 }
+
+// Return the opaque for the underlying frame (gives us a GPU_MEM_PTR_T)
+void *av_buffer_pool_opaque(AVBufferRef *ref) {
+  BufferPoolEntry *buf = av_buffer_get_opaque(ref);
+  return buf->opaque;
+}
diff --git a/libavutil/buffer.h b/libavutil/buffer.h
index b4399fd..0489002 100644
--- a/libavutil/buffer.h
+++ b/libavutil/buffer.h
@@ -267,6 +267,9 @@ void av_buffer_pool_uninit(AVBufferPool **pool);
  */
 AVBufferRef *av_buffer_pool_get(AVBufferPool *pool);
 
+// Return the opaque for the underlying frame
+void *av_buffer_pool_opaque(AVBufferRef *ref);
+
 /**
  * @}
  */
-- 
1.9.1


From 7a6297410b53d11236a209e6e9f7dde3527186eb Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Mon, 11 May 2015 14:04:37 +0100
Subject: [PATCH 17/77] Prepared QPU execute code

---
 libavcodec/hevc.c               | 229 ++++++++++++++++++++++++++++++++++------
 libavcodec/hevc.h               |  22 +++-
 libavcodec/hevc_filter.c        |   7 +-
 libavcodec/rpi_hevc_transform.s |   5 +
 libavcodec/rpi_qpu.c            |  55 +++++++++-
 libavcodec/rpi_qpu.h            |   2 +
 6 files changed, 282 insertions(+), 38 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 3c3c9e8..c7712f3 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -40,17 +40,45 @@
 #include "hevc.h"
 
 #ifdef RPI
-#include "rpi_qpu.h"
-// For some unknown reason, the code seems to crash if I do a late malloc
-#define EARLY_MALLOC
-// Move Inter prediction into separate pass
-#define RPI_INTER
+  #include "rpi_qpu.h"
+  // For some unknown reason, the code seems to crash if I do a late malloc
+  #define EARLY_MALLOC
+  // Move Inter prediction into separate pass
+  #define RPI_INTER
 #endif
 
 // #define DISABLE_MC
 
 const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
 
+
+#ifdef RPI_INTER_QPU
+
+#define RPI_CHROMA_COMMAND_WORDS 12
+// The QPU code for UV blocks only works up to a block width of 8
+#define RPI_CHROMA_BLOCK_WIDTH 8
+
+#define ENCODE_COEFFS(c0, c1, c2, c3) (((-c0) & 0xff) | ((-c1) & 0xff) << 8 | ((-c2) & 0xff) << 16 | ((-c3) & 0xff) << 24)
+
+// TODO Chroma only needs 4 taps
+static uint32_t rpi_filter_coefs[8][2] = {
+        { ENCODE_COEFFS(  0,  0,  0, 128), ENCODE_COEFFS(   0,   0,  0,  0 ) },
+        { ENCODE_COEFFS(  0,  0, -2,  58), ENCODE_COEFFS(  10,  -2,  0,  0 ) }, 
+        { ENCODE_COEFFS(  0,  0, -4,  54), ENCODE_COEFFS(  16,  -2,  0,  0 ) },
+        { ENCODE_COEFFS(  0,  0, -6,  46), ENCODE_COEFFS(  28,  -4,  0,  0 ) },
+        { ENCODE_COEFFS(  0,  0, -4,  36), ENCODE_COEFFS(  36,  -4,  0,  0 ) },
+        { ENCODE_COEFFS(  0,  0, -4,  28), ENCODE_COEFFS(  46,  -6,  0,  0 ) },
+        { ENCODE_COEFFS(  0,  0, -2,  16), ENCODE_COEFFS(  54,  -4,  0,  0 ) },
+        { ENCODE_COEFFS(  0,  0, -2,  10), ENCODE_COEFFS(  58,  -2,  0,  0 ) }
+};
+
+static uint32_t get_vc_address(AVBufferRef *bref) {
+  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+  return p->vc;
+}
+
+#endif
+
 /**
  * NOTE: Each function hls_foo correspond to the function foo in the
  * specification (HLS stands for High Level Syntax).
@@ -64,6 +92,7 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 static void pic_arrays_free(HEVCContext *s)
 {
 #ifdef RPI
+
 #ifdef EARLY_MALLOC
 #else
     printf("pic_arrays_free\n");
@@ -1946,6 +1975,43 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                     s->sh.luma_offset_l0[current_mv.ref_idx[0]]);
 
         if (s->sps->chroma_format_idc) {
+#ifdef RPI_INTER_QPU
+            if (s->enable_rpi) {
+                int reflist = 0;
+                int hshift           = s->sps->hshift[1];
+                int vshift           = s->sps->vshift[1];
+                const Mv *mv         = &current_mv.mv[reflist];
+                intptr_t mx          = av_mod_uintp2(mv->x, 2 + hshift);
+                intptr_t my          = av_mod_uintp2(mv->y, 2 + vshift);
+                intptr_t _mx         = mx << (1 - hshift);
+                intptr_t _my         = my << (1 - vshift); // Fractional part of motion vector 
+
+                int x1_c = x0_c + (mv->x >> (2 + hshift));
+                int y1_c = y0_c + (mv->y >> (2 + hshift));
+                int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+                
+                uint32_t *u = s->u_mvs[chan & 7];      
+                for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
+                  for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
+                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                      *u++ = rpi_filter_coefs[_mx][0];
+                      *u++ = rpi_filter_coefs[_mx][1];
+                      *u++ = rpi_filter_coefs[_my][0];
+                      *u++ = rpi_filter_coefs[_my][1];
+                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                    }
+                }
+                s->u_mvs[chan & 7] = u;
+                return;
+            }
+#endif
             RPI_REDIRECT(chroma_mc_uni)(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],
                           0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);
@@ -2596,6 +2662,54 @@ static void rpi_execute_inter_cmds(HEVCContext *s)
 
 #endif
 
+#ifdef RPI_INTER_QPU
+static void rpi_inter_clear(HEVCContext *s)
+{
+    int i;
+    int pic_width        = s->sps->width >> s->sps->hshift[1];
+    int pic_height       = s->sps->height >> s->sps->vshift[1];
+    for(i=0;i<8;i++) {
+        s->u_mvs[i] = s->mvs_base[i];
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = pic_width;
+        *s->u_mvs[i]++ = pic_height;
+        *s->u_mvs[i]++ = s->frame->linesize[1];
+        *s->u_mvs[i]++ = s->frame->linesize[2];
+        s->u_mvs[i] += 3;  // Padding words
+    }
+}
+
+static void rpi_execute_inter_qpu(HEVCContext *s)
+{
+    int k;
+    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;   
+                    
+    if (s->sh.slice_type == I_SLICE)
+        return;
+    for(k=0;k<8;k++) {
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined                     
+    }
+             
+    s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+
+    qpu_run_shader8(qpu_get_fn(QPU_MC_SETUP_UV),
+      (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
+      );
+}
+#endif
+
 static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 {
     HEVCContext *s  = avctxt->priv_data;
@@ -2621,6 +2735,10 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
             return AVERROR_INVALIDDATA;
         }
     }
+    
+#ifdef RPI_INTER_QPU
+    rpi_inter_clear(s);
+#endif
 
     while (more_data && ctb_addr_ts < s->sps->ctb_size) {
         int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];
@@ -2643,19 +2761,30 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
           s->dblk_cmds[s->num_dblk_cmds][0] = x_ctb;
           s->dblk_cmds[s->num_dblk_cmds++][1] = y_ctb;
           if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->sps->width) {
-            int x;
+#ifdef RPI_INTER_QPU
+            // Kick off inter prediction on QPUs
+            rpi_execute_inter_qpu(s);
+#endif
             // Transform all blocks
             //printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
-    
             rpi_execute_transform(s);
             // Perform inter prediction
             rpi_execute_inter_cmds(s);
             // Wait for transform completion
             vpu_wait(s->vpu_id);
+            
+            // Copy back reconstructed data
+            //memcpy(s->frame->data[0],s->dummy.arm,2048*64);
+            //memcpy(s->frame->data[1],s->dummy.arm,1024*32);
+            //memcpy(s->frame->data[2],s->dummy.arm,1024*32);
+            
             // Perform intra prediction and residual reconstruction
             rpi_execute_pred_cmds(s);
             // Perform deblocking for CTBs in this row
             rpi_execute_dblk_cmds(s);
+#ifdef RPI_INTER_QPU
+            rpi_inter_clear(s);
+#endif
           }
         }
 #endif
@@ -2676,6 +2805,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     
 #ifdef RPI
     if (s->enable_rpi && s->num_dblk_cmds) {
+#ifdef RPI_INTER_QPU
+        rpi_execute_inter_qpu(s);
+#endif
         rpi_execute_transform(s);
         rpi_execute_inter_cmds(s);
         vpu_wait(s->vpu_id);
@@ -3573,6 +3705,14 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
     av_freep(&s->unif_xfm_cmds);
     av_freep(&s->univ_pred_cmds);
     
+#ifdef RPI_INTER_QPU
+    if (s->unif_mvs) {
+        gpu_free( &s->unif_mvs_ptr );
+        s->unif_mvs = 0;
+    }
+#endif
+    //gpu_free(&s->dummy);
+    
 #ifdef EARLY_MALLOC
     printf("hevc_decode_free\n");
     if (s->coeffs_buf_arm[0]) {
@@ -3666,34 +3806,59 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     if (!s->univ_pred_cmds)
         goto fail;
         
-    s->coeffs_buf_arm[0] = 0;
-    s->coeffs_buf_arm[2] = 0;
- 
+#ifdef RPI_INTER_QPU
+    // We divide the image into blocks 256 wide and 64 high
+    // We support up to 2048 widths
+    // We compute the number of chroma motion vector commands for 4:4:4 format and 4x4 chroma blocks - assuming all blocks are B predicted
+    // Also add space for the startup command for each stream.
+    
+    {
+        int uv_commands_per_qpu = (1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS;
+        uint32_t *p;
+        gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
+        s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
+    
+        // Set up initial locations for uniform streams
+        p = s->unif_mvs;
+        for(i = 0; i < 8; i++) {
+            s->mvs_base[i] = p;
+            p += uv_commands_per_qpu;
+        }
+        s->mc_filter_uv = qpu_get_fn(QPU_MC_FILTER_UV);
+        s->mc_filter_uv_b = qpu_get_fn(QPU_MC_FILTER_UV_B);
+        
+    }
+#endif
+    //gpu_malloc_uncached(2048*64,&s->dummy);
+    
 #ifdef EARLY_MALLOC 
-    int coeffs_in_ctb = 64*64;
-    int coefs_per_row = (2048/64) * coeffs_in_ctb * 3;  // Allow space for chroma
-    printf("Allocated %d\n",coefs_per_row);
-    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
-    s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
-    if (!s->coeffs_buf_arm[0])
-        goto fail;
-    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
-    s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
-    s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
-    if (!s->coeffs_buf_arm[2])
-        goto fail;    
-    s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
-    s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
-    printf("Done\n");
+    {
+        int coeffs_in_ctb = 64*64;
+        int coefs_per_row = (2048/64) * coeffs_in_ctb * 3;  // Allow space for chroma
+        s->coeffs_buf_arm[0] = 0;
+        s->coeffs_buf_arm[2] = 0;
+        printf("Allocated %d\n",coefs_per_row);
+        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
+        s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
+        if (!s->coeffs_buf_arm[0])
+            goto fail;
+        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
+        s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
+        s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
+        if (!s->coeffs_buf_arm[2])
+            goto fail;    
+        s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
+        s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
+        printf("Done\n");
 #ifdef RPI_PRECLEAR
-    //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
-    memclear16(s->coeffs_buf_arm[0], coefs_per_row);
-    //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
-    memclear16(s->coeffs_buf_arm[2], coefs_per_row);
-    //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
-    memclear16(s->coeffs_buf_arm[3], coefs_per_row);
+        //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
+        memclear16(s->coeffs_buf_arm[0], coefs_per_row);
+        //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
+        memclear16(s->coeffs_buf_arm[2], coefs_per_row);
+        //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
+        memclear16(s->coeffs_buf_arm[3], coefs_per_row);
 #endif
-    
+    }
 #endif
 
     s->enable_rpi = 0;
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index c0e2efd..56284de 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -40,7 +40,11 @@
 #define RPI
 
 #ifdef RPI
-#include "rpi_qpu.h"
+
+  #include "rpi_qpu.h"
+  // Use QPU for inter prediction
+  //#define RPI_INTER_QPU
+
 #endif
 
 #define MAX_DPB_SIZE 16 // A.4.1
@@ -884,7 +888,7 @@ typedef struct HEVCContext {
 
 #ifdef RPI
     int enable_rpi;
-    HEVCMvCmd *unif_mv_cmds;
+    HEVCMvCmd *unif_mv_cmds;  // TODO rename
     HEVCXfmCmd *unif_xfm_cmds;
     HEVCPredCmd *univ_pred_cmds;
     int buf_width;
@@ -898,6 +902,20 @@ typedef struct HEVCContext {
     int num_pred_cmds;
     int num_dblk_cmds;
     int vpu_id;
+    //GPU_MEM_PTR_T dummy;
+#ifdef RPI_INTER_QPU
+    GPU_MEM_PTR_T unif_mvs_ptr;
+    uint32_t *unif_mvs; // Base of memory for motion vector commands
+    
+    // _base pointers are to the start of the row
+    uint32_t *mvs_base[8];
+    // these pointers are to the next free space
+    uint32_t *u_mvs[8];
+    // Function pointers
+    uint32_t mc_filter_uv;
+    uint32_t mc_filter_uv_b;
+#endif
+    
 #endif
 
     uint8_t *cabac_state;
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 8e96bbe..04f7e88 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -899,8 +899,11 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
             s->nal_unit_type == NAL_STSA_N  ||
             s->nal_unit_type == NAL_RADL_N  ||
             s->nal_unit_type == NAL_RASL_N )) {
-            flush_buffer(s->frame->buf[1]);
-            flush_buffer(s->frame->buf[2]);
+            //flush_buffer(s->frame->buf[1]);
+            //flush_buffer(s->frame->buf[2]);
+            //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
+            //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
+            //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
         }
         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
     }
diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
index 388ceb2..1a4dfb5 100644
--- a/libavcodec/rpi_hevc_transform.s
+++ b/libavcodec/rpi_hevc_transform.s
@@ -282,3 +282,8 @@ loop:
   cmp r1,0
   bgt loop
   b lr
+  
+  
+
+
+
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 2dd2a8e..fc7a958 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -2,7 +2,7 @@
 // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
 #define RPI_USE_VCSM
 // define RPI_TIME_TOTAL_QPU to print out how much time is spent in the QPU code
-//#define RPI_TIME_TOTAL_QPU
+#define RPI_TIME_TOTAL_QPU
 // define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
 //#define RPI_TIME_TOTAL_VPU
 // define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
@@ -27,7 +27,7 @@
 #endif
 
 // On Pi2 there is no way to access the VPU L2 cache
-// GPU_MEM_FLG should be 4 for uncached memory.
+// GPU_MEM_FLG should be 4 for uncached memory.  (Or C for alias to allocate in the VPU L2 cache)
 // However, if using VCSM allocated buffers, need to use C at the moment because VCSM does not allocate uncached memory correctly
 // The QPU crashes if we mix L2 cached and L2 uncached accesses due to a HW bug. 
 #define GPU_MEM_FLG 0xC
@@ -545,6 +545,54 @@ void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int un
 #endif
   gpu_unlock();
 }
+
+// Run a program on 8 QPUs with the given code and uniform stream (given in GPU addresses)
+void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8)
+{
+  int i;
+#ifdef RPI_TIME_TOTAL_QPU
+  static int last_time=0;
+  static long long on_time=0;
+  static long long off_time=0;
+  int start_time;
+  int end_time;
+  static int count=0;
+#endif
+
+  gpu_lock();
+#ifdef RPI_TIME_TOTAL_QPU
+  start_time = Microseconds();
+  if (last_time==0)
+    last_time = start_time;
+  off_time += start_time-last_time;
+#endif
+  for(i=0;i<8;i++) {
+    gpu->mail[i*2 + 1] = code;  
+  }
+  gpu->mail[0 ] = unifs1;
+  gpu->mail[2 ] = unifs2;
+  gpu->mail[4 ] = unifs3;
+  gpu->mail[6 ] = unifs4;
+  gpu->mail[8 ] = unifs5;
+  gpu->mail[10] = unifs6;
+	gpu->mail[12] = unifs7;
+	gpu->mail[14] = unifs8;
+	execute_qpu(
+		gpu->mb,
+		8 /* Number of QPUs */,
+		gpu->vc + offsetof(struct GPU, mail),
+		1 /* no flush */,  // Don't flush VPU L1 cache
+		5000 /* timeout ms */);
+#ifdef RPI_TIME_TOTAL_QPU
+  end_time = Microseconds();
+  last_time = end_time;
+  on_time += end_time - start_time;
+  count++;
+  if ((count&0x7f)==0)
+    printf("On=%dms, Off=%dms\n",(int)(on_time/1000),(int)(off_time/1000));
+#endif
+  gpu_unlock();
+}
   
 unsigned int qpu_get_fn(int num) {
     // Make sure that the gpu is initialized
@@ -582,6 +630,9 @@ unsigned int qpu_get_fn(int num) {
     case QPU_MC_FILTER_UV_B:
       fn = mc_filter_uv_b;
       break;
+    case QPU_MC_INTERRUPT_EXIT8:
+      fn = mc_interrupt_exit8;
+      break;
     case QPU_MC_END:
       fn = mc_end;
       break;
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index 3526fce..2b22d98 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -16,6 +16,7 @@ extern void gpu_free(GPU_MEM_PTR_T *p);
 extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
 
 // QPU specific functions
+extern void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
 extern void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12);
 
 enum {
@@ -28,6 +29,7 @@ enum {
   QPU_MC_SETUP_UV,
   QPU_MC_FILTER_UV,
   QPU_MC_FILTER_UV_B,
+  QPU_MC_INTERRUPT_EXIT8,
   QPU_MC_END
   };
 extern unsigned int qpu_get_fn(int num);
-- 
1.9.1


From e2f8ac723091cebeac65a09e5e5da8c41884554c Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 13 May 2015 11:47:23 +0100
Subject: [PATCH 18/77] Drafted chroma interpolation on QPUs

---
 libavcodec/hevc.c          |   7 ++--
 libavcodec/hevc.h          |   2 +-
 libavcodec/hevc_filter.c   |   6 ++-
 libavcodec/rpi_qpu.c       | 101 +++++++++++++++++++++++++++++++++++++++++++--
 libavcodec/rpi_qpu.h       |   1 +
 libavcodec/rpi_shader.c    |  42 +++++++++----------
 libavcodec/rpi_shader.qasm |  42 +++++++++----------
 7 files changed, 150 insertions(+), 51 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index c7712f3..675d2a4 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -58,11 +58,11 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 // The QPU code for UV blocks only works up to a block width of 8
 #define RPI_CHROMA_BLOCK_WIDTH 8
 
-#define ENCODE_COEFFS(c0, c1, c2, c3) (((-c0) & 0xff) | ((-c1) & 0xff) << 8 | ((-c2) & 0xff) << 16 | ((-c3) & 0xff) << 24)
+#define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
 
 // TODO Chroma only needs 4 taps
 static uint32_t rpi_filter_coefs[8][2] = {
-        { ENCODE_COEFFS(  0,  0,  0, 128), ENCODE_COEFFS(   0,   0,  0,  0 ) },
+        { ENCODE_COEFFS(  0,  0,  0,  64), ENCODE_COEFFS(   0,   0,  0,  0 ) },
         { ENCODE_COEFFS(  0,  0, -2,  58), ENCODE_COEFFS(  10,  -2,  0,  0 ) }, 
         { ENCODE_COEFFS(  0,  0, -4,  54), ENCODE_COEFFS(  16,  -2,  0,  0 ) },
         { ENCODE_COEFFS(  0,  0, -6,  46), ENCODE_COEFFS(  28,  -4,  0,  0 ) },
@@ -2692,7 +2692,8 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
         return;
     for(k=0;k<8;k++) {
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined                     
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP); // Also need a dummy for V        
     }
              
     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 56284de..de0be17 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -43,7 +43,7 @@
 
   #include "rpi_qpu.h"
   // Use QPU for inter prediction
-  //#define RPI_INTER_QPU
+  // #define RPI_INTER_QPU
 
 #endif
 
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 04f7e88..3150cd0 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -899,8 +899,10 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
             s->nal_unit_type == NAL_STSA_N  ||
             s->nal_unit_type == NAL_RADL_N  ||
             s->nal_unit_type == NAL_RASL_N )) {
-            //flush_buffer(s->frame->buf[1]);
-            //flush_buffer(s->frame->buf[2]);
+#ifdef RPI_INTER_QPU            
+            flush_buffer(s->frame->buf[1]);
+            flush_buffer(s->frame->buf[2]);
+#endif
             //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
             //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
             //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index fc7a958..255c13c 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -30,7 +30,8 @@
 // GPU_MEM_FLG should be 4 for uncached memory.  (Or C for alias to allocate in the VPU L2 cache)
 // However, if using VCSM allocated buffers, need to use C at the moment because VCSM does not allocate uncached memory correctly
 // The QPU crashes if we mix L2 cached and L2 uncached accesses due to a HW bug. 
-#define GPU_MEM_FLG 0xC
+#define GPU_MEM_FLG 0x4
+// GPU_MEM_MAP is meaningless on the Pi2 and should be left at 0  (On Pi1 it allows ARM to access VPU L2 cache)
 #define GPU_MEM_MAP 0x0
 
 #define vcos_verify(x) ((x)>=0)
@@ -162,6 +163,8 @@ static int gpu_init(volatile struct GPU **gpu) {
 	ptr->vc_handle = handle;
 	ptr->vc = vc;
   
+  printf("GPU allocated at 0x%x\n",vc);
+  
   *gpu = ptr;
   
   // Now copy over the QPU code into GPU memory
@@ -301,10 +304,13 @@ int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p) {
 
 static void gpu_term(void)
 {
-	int mb = gpu->mb;
-	unsigned handle = gpu->vc_handle;
+	int mb;
+	unsigned handle;
+  
   if (gpu==NULL) 
     return;
+  mb = gpu->mb;
+  handle = gpu->vc_handle;
   
 #ifdef RPI_ASYNC
   {
@@ -645,6 +651,95 @@ unsigned int qpu_get_fn(int num) {
 }
 
 #if 0
+typedef unsigned int uint32_t;
+
+typedef struct mvs_s {
+    GPU_MEM_PTR_T unif_mvs_ptr;
+    uint32_t *unif_mvs; // Base of memory for motion vector commands
+    
+    // _base pointers are to the start of the row
+    uint32_t *mvs_base[8];
+    // these pointers are to the next free space
+    uint32_t *u_mvs[8];
+
+} HEVCContext;
+
+#define RPI_CHROMA_COMMAND_WORDS 12
+
+static void rpi_inter_clear(HEVCContext *s)
+{
+    int i;
+    for(i=0;i<8;i++) {
+        s->u_mvs[i] = s->mvs_base[i];
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 0;
+        *s->u_mvs[i]++ = 128;  // w
+        *s->u_mvs[i]++ = 128;  // h
+        *s->u_mvs[i]++ = 128;  // stride u
+        *s->u_mvs[i]++ = 128;  // stride v
+        s->u_mvs[i] += 3;  // Padding words
+    }
+}
+
+static void rpi_execute_inter_qpu(HEVCContext *s)
+{
+    int k;
+    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;   
+                    
+    for(k=0;k<8;k++) {
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined     
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP); //  dummy location for V    
+    }
+             
+    s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+
+    qpu_run_shader8(qpu_get_fn(QPU_MC_SETUP_UV),
+      (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
+      );
+}
+
+void rpi_test_qpu(void)
+{
+    HEVCContext mvs;
+    HEVCContext *s = &mvs;
+    int i;
+    int uv_commands_per_qpu = (1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS;
+    uint32_t *p;
+    printf("Allocate memory\n");
+    gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
+    s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm;
+
+    // Set up initial locations for uniform streams
+    p = s->unif_mvs;
+    for(i = 0; i < 8; i++) {
+        s->mvs_base[i] = p;
+        p += uv_commands_per_qpu;
+    }
+    // Now run a simple program that should just quit immediately after a single texture fetch
+    rpi_inter_clear(s);
+    for(i=0;i<4;i++) {
+      printf("Launch QPUs\n");
+      rpi_execute_inter_qpu(s);
+      printf("Done\n");
+    }
+    printf("Free memory\n");
+    gpu_free(&s->unif_mvs_ptr);
+    return;
+}
+#endif
+
+#if 0
 
 int32_t hcoeffs[] = {-4, 10, -21, 70, 90, -24, 11, -4};
 //int32_t hcoeffs[] = {1, 1, 1, 1, 1, 1, 1, 1};
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index 2b22d98..f9ad333 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -18,6 +18,7 @@ extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
 // QPU specific functions
 extern void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
 extern void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12);
+extern void rpi_test_qpu(void);
 
 enum {
   QPU_MC_SETUP,
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 41cc2e1..d7ed297 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -152,23 +152,23 @@ unsigned int rpi_shader[] = {
 /* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
 /* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
 /* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000400] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000408] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
-/* [0x00000410] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000400] */ 0x55015fc6, 0x100248a2, // mov r2, rb21         ; mul24 r2, r0, ra0
+/* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
 /* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000420] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000420] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 /* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000430] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000430] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 /* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000440] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000440] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
 /* [0x00000448] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000450] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000450] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
 /* [0x00000458] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000460] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000460] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
 /* [0x00000468] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000470] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000470] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
 /* [0x00000478] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000480] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x00000480] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
 /* [0x00000488] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
 /* [0x00000490] */ 0x15267d80, 0x10020227, // mov ra8, ra9
 /* [0x00000498] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
@@ -179,20 +179,20 @@ unsigned int rpi_shader[] = {
 /* [0x000004c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
 /* [0x000004c8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
 /* [0x000004d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x000004d8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x000004d8] */ 0x8f54e1f6, 0xd0024821, // asr r0, r0, 14          ; mov r1, ra21
 /* [0x000004e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x000004e8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x000004f0] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x000004f8] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000500] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000508] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000510] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000518] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000520] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000528] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x000004e8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x000004f0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x000004f8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000500] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000508] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000510] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000518] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000520] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000528] */ 0x8c9f223f, 0x100a0867, // add.ifnn r1, r1, r0     ; mov -, vw_wait
 /* [0x00000530] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
 /* [0x00000538] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000540] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x00000540] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
 /* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
 /* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
 /* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 2214745..b670b12 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -270,23 +270,23 @@ add t0s, ra_x2_base, r2
 
 mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 
-mov r2, rb21         ; mul24 r3, r0, ra0
-nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+mov r2, rb21         ; mul24 r2, r0, ra0
+nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+nop                  ; mul24      r3, ra1 << 1, r0 << 1
 nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
 nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
 nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
 nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
 nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3
+add r0, r2, r3
 
 mov r3, rb31
 
@@ -302,23 +302,23 @@ sub.setf -, r3, 8 ; mov r1, ra22
 # apply horizontal filter         
 brr.anyn -, r:uvloop
 max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 15          ; mov r1, ra21
+asr r0, r0, 14          ; mov r1, ra21
 min.setf ra15, r0, rb22
  
 # apply vertical filter and write to VPM
 
-nop                     ; mul24 r0, ra14, rb14
-sub r1, r1, r0          ; mul24 r0, ra13, rb13
-sub r1, r1, r0          ; mul24 r0, ra12, rb12
-sub r1, r1, r0          ; mul24 r0, ra11, rb11
-sub r1, r1, r0          ; mul24 r0, ra10, rb10
-sub r1, r1, r0          ; mul24 r0, ra9, rb9
-sub r1, r1, r0          ; mul24 r0, ra8, rb8
-sub r1, r1, r0          ; mul24 r0, ra15, rb15
-sub.ifnn r1, r1, r0     ; mov -, vw_wait
+nop                     ; mul24 r1, ra14, rb14
+nop                     ; mul24 r0, ra13, rb13
+add r1, r1, r0          ; mul24 r0, ra12, rb12
+add r1, r1, r0          ; mul24 r0, ra11, rb11
+add r1, r1, r0          ; mul24 r0, ra10, rb10
+add r1, r1, r0          ; mul24 r0, ra9, rb9
+add r1, r1, r0          ; mul24 r0, ra8, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb15
+add.ifnn r1, r1, r0     ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
 brr.anyn -, r:uvloop 
-asr r1, r1, 15          
+asr r1, r1, 14          
 min r1, r1, rb22        
 max vpm, r1, 0
 
-- 
1.9.1


From b225f764c4e1aabf03cbfbd407d58480c255f14f Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 13 May 2015 13:54:11 +0100
Subject: [PATCH 19/77] Fixed chroma inter prediction

---
 libavcodec/hevc.c          |    8 +-
 libavcodec/hevc.h          |    2 +-
 libavcodec/rpi_shader.c    | 1170 ++++++++++----------
 libavcodec/rpi_shader.h    |   22 +-
 libavcodec/rpi_shader.qasm | 2544 ++++++++++++++++++++++----------------------
 5 files changed, 1877 insertions(+), 1869 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 675d2a4..34035d5 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -55,9 +55,11 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 #ifdef RPI_INTER_QPU
 
 #define RPI_CHROMA_COMMAND_WORDS 12
+#define UV_COMMANDS_PER_QPU ((1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS)       
 // The QPU code for UV blocks only works up to a block width of 8
 #define RPI_CHROMA_BLOCK_WIDTH 8
 
+
 #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
 
 // TODO Chroma only needs 4 taps
@@ -1988,7 +1990,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
 
                 int x1_c = x0_c + (mv->x >> (2 + hshift));
                 int y1_c = y0_c + (mv->y >> (2 + hshift));
-                int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+                //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+                int chan = x0>>8;
                 
                 uint32_t *u = s->u_mvs[chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
@@ -2694,6 +2697,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP); // Also need a dummy for V        
+        assert(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
     }
              
     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
@@ -3814,7 +3818,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     // Also add space for the startup command for each stream.
     
     {
-        int uv_commands_per_qpu = (1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS;
+        int uv_commands_per_qpu = UV_COMMANDS_PER_QPU;
         uint32_t *p;
         gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
         s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index de0be17..05438af 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -43,7 +43,7 @@
 
   #include "rpi_qpu.h"
   // Use QPU for inter prediction
-  // #define RPI_INTER_QPU
+  #define RPI_INTER_QPU
 
 #endif
 
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index d7ed297..831633b 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -33,7 +33,7 @@ unsigned int rpi_shader[] = {
 /* [0x00000040] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
 /* [0x00000048] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
 /* [0x00000050] */ 0x00000001, 0xe0020527, // mov ra20, 1
-/* [0x00000058] */ 0x00000040, 0xe0020567, // mov ra21, 64
+/* [0x00000058] */ 0x00000020, 0xe0020567, // mov ra21, 32
 /* [0x00000060] */ 0x00000100, 0xe00205a7, // mov ra22, 256
 /* [0x00000068] */ 0x00000008, 0xe00205e7, // mov ra23, 8
 /* [0x00000070] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
@@ -152,7 +152,7 @@ unsigned int rpi_shader[] = {
 /* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
 /* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
 /* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000400] */ 0x55015fc6, 0x100248a2, // mov r2, rb21         ; mul24 r2, r0, ra0
+/* [0x00000400] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
 /* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
 /* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
 /* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
@@ -178,9 +178,9 @@ unsigned int rpi_shader[] = {
 /* [0x000004b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
 /* [0x000004c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
 /* [0x000004c8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x000004d8] */ 0x8f54e1f6, 0xd0024821, // asr r0, r0, 14          ; mov r1, ra21
-/* [0x000004e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x000004d0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x000004d8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x000004e0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
 /* [0x000004e8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
 /* [0x000004f0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
 /* [0x000004f8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
@@ -189,400 +189,400 @@ unsigned int rpi_shader[] = {
 /* [0x00000510] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
 /* [0x00000518] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
 /* [0x00000520] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000528] */ 0x8c9f223f, 0x100a0867, // add.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x00000528] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
 /* [0x00000530] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000538] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000540] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000560] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000568] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000570] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000578] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000580] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000588] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000590] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000598] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000538] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000540] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x00000548] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000550] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x00000558] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000560] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000568] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000570] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000578] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000580] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000588] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000590] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000598] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000005a0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000005a8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter
-/* [0x000005a0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000005a8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000005b0] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
-/* [0x000005b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000005c0] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
-/* [0x000005c8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000005d0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
-/* [0x000005d8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000005e0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
-/* [0x000005e8] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
-/* [0x000005f0] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
-/* [0x000005f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000600] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
-/* [0x00000608] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000610] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
-/* [0x00000618] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000620] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000628] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000630] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000638] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000640] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000648] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000650] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000658] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000660] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000668] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000670] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000678] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000680] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000688] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000690] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000698] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000006b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000006d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000006f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000700] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000708] */ 0x000001d0, 0xf07809e7, // brr.anynn -, r:fast_path
-/* [0x00000710] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000718] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000720] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000728] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000005b0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000005b8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000005c0] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+/* [0x000005c8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000005d0] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+/* [0x000005d8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000005e0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+/* [0x000005e8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000005f0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+/* [0x000005f8] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+/* [0x00000600] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+/* [0x00000608] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000610] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+/* [0x00000618] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000620] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+/* [0x00000628] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000630] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000638] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000640] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000648] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000650] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000658] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000660] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000668] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000670] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000678] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000680] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000688] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000690] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000698] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000006a0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006a8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006b0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006b8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000006c0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006c8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006d0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006d8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000006e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000700] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000708] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000710] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000718] */ 0x000001d0, 0xf07809e7, // brr.anynn -, r:fast_path
+/* [0x00000720] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000728] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000730] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000738] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :loop
-/* [0x00000730] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000738] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000740] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000748] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000750] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
-/* [0x00000758] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000760] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000768] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000770] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000778] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000780] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000788] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000790] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000798] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000007a0] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000007a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000007b0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000007b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000007c0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x000007c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x000007d0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x000007d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x000007e0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x000007e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x000007f0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x000007f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000800] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
-/* [0x00000808] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000810] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000818] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000820] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000828] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000830] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000838] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000840] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000848] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:loop
-/* [0x00000850] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x00000858] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x00000860] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x00000868] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x00000870] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x00000878] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000880] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000888] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000890] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000898] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x000008a0] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x000008a8] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
-/* [0x000008b0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000008b8] */ 0xfffffe58, 0xf06809e7, // brr.anyn -, r:loop
-/* [0x000008c0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
-/* [0x000008c8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000008d0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000008d8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000008e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000008e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000008f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000740] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000748] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000750] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000758] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000760] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+/* [0x00000768] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000770] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000778] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000780] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000788] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000790] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000798] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x000007a0] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000007a8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000007b0] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000007b8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000007c0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000007c8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000007d0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x000007d8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x000007e0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x000007e8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x000007f0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x000007f8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000800] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000808] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000810] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x00000818] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000820] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000828] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000830] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000838] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000840] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000848] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000850] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000858] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:loop
+/* [0x00000860] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x00000868] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x00000870] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x00000878] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x00000880] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x00000888] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000890] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000898] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x000008a0] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x000008a8] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x000008b0] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x000008b8] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x000008c0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000008c8] */ 0xfffffe58, 0xf06809e7, // brr.anyn -, r:loop
+/* [0x000008d0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x000008d8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000008e0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000008e8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000008f0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000008f8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000900] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // :fast_path
-/* [0x000008f8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000908] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :fast_loop
-/* [0x00000900] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000908] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000910] */ 0x95727d9b, 0x1004475f, // mov.ifz ra_y, ra_y_next   ; mov rb31, r3
-/* [0x00000918] */ 0x95690dbf, 0x10044623, // mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
-/* [0x00000920] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000928] */ 0x929de5e4, 0x100248a1, // min r2, r2, rb_frame_height_minus_1 ; mov r1, r4
-/* [0x00000930] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000938] */ 0xec414c87, 0x10024e20, // add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
-/* [0x00000940] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000948] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000950] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
-/* [0x00000958] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
-/* [0x00000960] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
-/* [0x00000968] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
-/* [0x00000970] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
-/* [0x00000978] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
-/* [0x00000980] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
-/* [0x00000988] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
-/* [0x00000990] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000998] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x000009a0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x000009a8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x000009b0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x000009b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000009c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8       ; mov r1, ra22
-/* [0x000009c8] */ 0xffffff18, 0xf06809e7, // brr.anyn -, r:fast_loop
-/* [0x000009d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x000009d8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x000009e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x000009e8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x000009f0] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x000009f8] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000a00] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000a08] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000a10] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000a18] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000a20] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000a28] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
-/* [0x00000a30] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000a38] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:fast_loop
-/* [0x00000a40] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
-/* [0x00000a48] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000a50] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000a60] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000910] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000918] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000920] */ 0x95727d9b, 0x1004475f, // mov.ifz ra_y, ra_y_next   ; mov rb31, r3
+/* [0x00000928] */ 0x95690dbf, 0x10044623, // mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
+/* [0x00000930] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000938] */ 0x929de5e4, 0x100248a1, // min r2, r2, rb_frame_height_minus_1 ; mov r1, r4
+/* [0x00000940] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000948] */ 0xec414c87, 0x10024e20, // add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
+/* [0x00000950] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000958] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000960] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
+/* [0x00000968] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
+/* [0x00000970] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
+/* [0x00000978] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
+/* [0x00000980] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
+/* [0x00000988] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
+/* [0x00000990] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
+/* [0x00000998] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
+/* [0x000009a0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x000009a8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x000009b0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x000009b8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x000009c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x000009c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000009d0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8       ; mov r1, ra22
+/* [0x000009d8] */ 0xffffff18, 0xf06809e7, // brr.anyn -, r:fast_loop
+/* [0x000009e0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x000009e8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x000009f0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x000009f8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x00000a00] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x00000a08] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000a10] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000a18] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000a20] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000a28] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000a30] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000a38] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x00000a40] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000a48] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:fast_loop
+/* [0x00000a50] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x00000a58] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000a60] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000a68] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000a70] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000a78] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a80] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_b
-/* [0x00000a78] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000a80] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000a88] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
-/* [0x00000a90] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000a98] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
-/* [0x00000aa0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000aa8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
-/* [0x00000ab0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000ab8] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
-/* [0x00000ac0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
-/* [0x00000ac8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
-/* [0x00000ad0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000ad8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
-/* [0x00000ae0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000ae8] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
-/* [0x00000af0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000af8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000b00] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000b08] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000b10] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000b18] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000b20] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000b28] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000b30] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000b38] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000b40] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000b48] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000b50] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000b58] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000b60] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000b68] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000b70] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
-/* [0x00000b78] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000b80] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000b88] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000b90] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000b98] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000ba0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ba8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000bb0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000bb8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000bc0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000bc8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000bd0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000bd8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000be0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000be8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000bf0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000bf8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000c00] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000c08] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000c10] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000a88] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000a90] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000a98] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+/* [0x00000aa0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000aa8] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+/* [0x00000ab0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000ab8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+/* [0x00000ac0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000ac8] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+/* [0x00000ad0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+/* [0x00000ad8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+/* [0x00000ae0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000ae8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+/* [0x00000af0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000af8] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+/* [0x00000b00] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000b08] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000b10] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000b18] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000b20] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000b28] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000b30] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000b38] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000b40] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000b48] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000b50] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000b58] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000b60] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000b68] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000b70] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000b78] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000b80] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+/* [0x00000b88] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000b90] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000b98] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ba0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ba8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000bb0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000bb8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000bc0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000bc8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000bd0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000bd8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000be0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000be8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000bf0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000bf8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000c00] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000c08] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000c10] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000c18] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000c20] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :bloop
-/* [0x00000c18] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000c20] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000c28] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000c30] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000c38] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
-/* [0x00000c40] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000c48] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000c50] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000c58] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000c60] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000c68] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000c70] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000c78] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000c80] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000c88] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000c90] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000c98] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000ca0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000ca8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000cb0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000cb8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000cc0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000cc8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000cd0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000cd8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000ce0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000ce8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
-/* [0x00000cf0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000cf8] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000d00] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000d08] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000d10] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000d18] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000d20] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000d28] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000d30] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:bloop
-/* [0x00000d38] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x00000d40] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x00000d48] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x00000d50] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x00000d58] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x00000d60] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000d68] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000d70] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000d78] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000d80] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000d88] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000d90] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
-/* [0x00000d98] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000da0] */ 0x8fc8f3f6, 0xd0020867, // asr r1, r1, 15          ; mov -, vr_wait
-/* [0x00000da8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000db0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
-/* [0x00000db8] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:bloop
-/* [0x00000dc0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x00000dc8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x00000dd0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
-/* [0x00000dd8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000de0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000de8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000df0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000c28] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000c30] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000c38] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000c40] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000c48] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+/* [0x00000c50] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000c58] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000c60] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000c68] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000c70] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000c78] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000c80] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000c88] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000c90] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000c98] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000ca0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000ca8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000cb0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000cb8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000cc0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000cc8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000cd0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000cd8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000ce0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000ce8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000cf0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000cf8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x00000d00] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000d08] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000d10] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000d18] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000d20] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000d28] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000d30] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000d38] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000d40] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:bloop
+/* [0x00000d48] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x00000d50] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x00000d58] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x00000d60] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x00000d68] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x00000d70] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000d78] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000d80] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000d88] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000d90] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000d98] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000da0] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x00000da8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000db0] */ 0x8fc8f3f6, 0xd0020867, // asr r1, r1, 15          ; mov -, vr_wait
+/* [0x00000db8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000dc0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+/* [0x00000dc8] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:bloop
+/* [0x00000dd0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000dd8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x00000de0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+/* [0x00000de8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000df0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000df8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000e00] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_honly
-/* [0x00000df8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000e00] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000e08] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
-/* [0x00000e10] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000e18] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
-/* [0x00000e20] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000e28] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
-/* [0x00000e30] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000e38] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
-/* [0x00000e40] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
-/* [0x00000e48] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
-/* [0x00000e50] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000e58] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
-/* [0x00000e60] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000e68] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
-/* [0x00000e70] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000e78] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000e80] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000e88] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000e90] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000e98] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000ea0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000ea8] */ 0x0c9de1c0, 0xd0021467, // add rb17, r0, -2
-/* [0x00000eb0] */ 0x919c71c0, 0xd0024812, // shl r0, r0, 7 ; mov rb18,r0
-/* [0x00000eb8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000ec0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000ec8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000ed0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000ed8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ee0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ee8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ef0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000ef8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f00] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f08] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f10] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000f18] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000f20] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000f28] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000f30] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000e08] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000e10] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000e18] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+/* [0x00000e20] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000e28] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+/* [0x00000e30] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000e38] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+/* [0x00000e40] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000e48] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+/* [0x00000e50] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+/* [0x00000e58] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+/* [0x00000e60] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000e68] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+/* [0x00000e70] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000e78] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+/* [0x00000e80] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000e88] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000e90] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000e98] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000ea0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000ea8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000eb0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000eb8] */ 0x0c9de1c0, 0xd0021467, // add rb17, r0, -2
+/* [0x00000ec0] */ 0x919c71c0, 0xd0024812, // shl r0, r0, 7 ; mov rb18,r0
+/* [0x00000ec8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000ed0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000ed8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000ee0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000ee8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ef0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ef8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f00] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000f08] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f10] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f18] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f20] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000f28] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000f30] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000f38] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000f40] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :loop_honly
-/* [0x00000f38] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000f40] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000f48] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000f50] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000f58] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
-/* [0x00000f60] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000f68] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000f70] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000f78] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000f80] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000f88] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000f90] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000f98] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000fa0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000fa8] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000fb0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000fb8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000fc0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000fc8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000fd0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000fd8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000fe0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000fe8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000ff0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000ff8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00001000] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00001008] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
-/* [0x00001010] */ 0x8d5927f6, 0x100269e1, // sub.setf -, r3, rb18 ; mov r1, ra22
-/* [0x00001018] */ 0x559f2fc1, 0x100049e0, // mov -, vw_wait   ; mul24 r0, r0, r1
-/* [0x00001020] */ 0xfffffef8, 0xf06809e7, // brr.anyn -, r:loop_honly
-/* [0x00001028] */ 0x0f9cf1c0, 0xd0020827, // asr r0, r0, 15
-/* [0x00001030] */ 0x129d61c0, 0x10020827, // min r0, r0, rb22
-/* [0x00001038] */ 0x139c01c0, 0xd0020c27, // max vpm, r0, 0
-/* [0x00001040] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001048] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00001050] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00001058] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000f48] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000f50] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000f58] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000f60] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000f68] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+/* [0x00000f70] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000f78] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000f80] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000f88] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000f90] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000f98] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000fa0] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000fa8] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000fb0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000fb8] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000fc0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000fc8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000fd0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000fd8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000fe0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000fe8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000ff0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000ff8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00001000] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00001008] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00001010] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00001018] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
+/* [0x00001020] */ 0x8d5927f6, 0x100269e1, // sub.setf -, r3, rb18 ; mov r1, ra22
+/* [0x00001028] */ 0x559f2fc1, 0x100049e0, // mov -, vw_wait   ; mul24 r0, r0, r1
+/* [0x00001030] */ 0xfffffef8, 0xf06809e7, // brr.anyn -, r:loop_honly
+/* [0x00001038] */ 0x0f9cf1c0, 0xd0020827, // asr r0, r0, 15
+/* [0x00001040] */ 0x129d61c0, 0x10020827, // min r0, r0, rb22
+/* [0x00001048] */ 0x139c01c0, 0xd0020c27, // max vpm, r0, 0
+/* [0x00001050] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001058] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00001060] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001068] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00001060] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00001068] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00001070] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001078] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001070] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00001078] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
 /* [0x00001080] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00001088] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001090] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00001098] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x000010a0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00001090] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001098] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010a0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000010a8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x000010b0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_exit1
-/* [0x000010a8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x000010b0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000010b8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010b8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
 /* [0x000010c0] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x000010c8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000010d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000010d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x000010e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x000010d0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010d8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010e0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000010e8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000010f0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit
-/* [0x000010e8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x000010f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000010f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000010f8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
 /* [0x00001100] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00001108] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001110] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001118] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001110] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001118] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00001120] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001128] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001130] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
@@ -592,225 +592,227 @@ unsigned int rpi_shader[] = {
 /* [0x00001150] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001158] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001160] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001168] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00001170] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00001178] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00001168] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001170] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001178] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00001180] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00001188] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit4
-/* [0x00001180] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00001188] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001190] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001190] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
 /* [0x00001198] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x000011a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000011a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000011b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000011a8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000011b0] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x000011b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000011c0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000011c8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x000011d0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x000011c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000011c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000011d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000011d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000011e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x000011d8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x000011e0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000011e8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000011e8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
 /* [0x000011f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x000011f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001200] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001208] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001200] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001208] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00001210] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001218] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001220] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001228] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001230] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001238] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00001240] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00001248] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00001238] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001240] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001248] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00001250] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00001258] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_setup_uv
-/* [0x00001250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00001258] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
-/* [0x00001260] */ 0x15827d80, 0x10020767, // mov ra_y, unif
-/* [0x00001268] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
-/* [0x00001270] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00001278] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
-/* [0x00001280] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
-/* [0x00001288] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
-/* [0x00001290] */ 0x15827d80, 0x10021427, // mov rb16, unif
-/* [0x00001298] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000012a0] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
-/* [0x000012a8] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
-/* [0x000012b0] */ 0x00000001, 0xe0020527, // mov ra20, 1
-/* [0x000012b8] */ 0x00000040, 0xe0020567, // mov ra21, 64
-/* [0x000012c0] */ 0x00000100, 0xe00205a7, // mov ra22, 256
-/* [0x000012c8] */ 0x00000008, 0xe00205e7, // mov ra23, 8
-/* [0x000012d0] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
-/* [0x000012d8] */ 0x00000040, 0xe0021567, // mov rb21, 64
-/* [0x000012e0] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
-/* [0x000012e8] */ 0x00000018, 0xe00215e7, // mov rb23, 24
-/* [0x000012f0] */ 0x00000000, 0xe0020227, // mov ra8, 0
-/* [0x000012f8] */ 0x00000000, 0xe0020267, // mov ra9, 0
-/* [0x00001300] */ 0x00000000, 0xe00202a7, // mov ra10, 0
-/* [0x00001308] */ 0x00000000, 0xe00202e7, // mov ra11, 0
-/* [0x00001310] */ 0x00000000, 0xe0020327, // mov ra12, 0
-/* [0x00001318] */ 0x00000000, 0xe0020367, // mov ra13, 0
-/* [0x00001320] */ 0x00000000, 0xe00203a7, // mov ra14, 0
-/* [0x00001328] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x00001330] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00001338] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00001340] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00001348] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00001350] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00001358] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00001360] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00001368] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00001370] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
-/* [0x00001378] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
-/* [0x00001380] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00001388] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00001390] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00001398] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x000013a0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x000013a8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x000013b0] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x000013b8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x000013c0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000013c8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x000013d0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x000013d8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
-/* [0x000013e0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
-/* [0x000013e8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
-/* [0x000013f0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-/* [0x000013f8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x00001400] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00001408] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00001410] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
-/* [0x00001418] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00001420] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-/* [0x00001428] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
-/* [0x00001430] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x00001438] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001440] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00001268] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
+/* [0x00001270] */ 0x15827d80, 0x10020767, // mov ra_y, unif
+/* [0x00001278] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
+/* [0x00001280] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00001288] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
+/* [0x00001290] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+/* [0x00001298] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+/* [0x000012a0] */ 0x15827d80, 0x10021427, // mov rb16, unif
+/* [0x000012a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000012b0] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+/* [0x000012b8] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+/* [0x000012c0] */ 0x00000001, 0xe0020527, // mov ra20, 1
+/* [0x000012c8] */ 0x00000020, 0xe0020567, // mov ra21, 32
+/* [0x000012d0] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+/* [0x000012d8] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+/* [0x000012e0] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x000012e8] */ 0x00000040, 0xe0021567, // mov rb21, 64
+/* [0x000012f0] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x000012f8] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x00001300] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x00001308] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x00001310] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x00001318] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x00001320] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x00001328] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x00001330] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x00001338] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x00001340] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00001348] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00001350] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00001358] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00001360] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00001368] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00001370] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00001378] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00001380] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00001388] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00001390] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00001398] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x000013a0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x000013a8] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x000013b0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x000013b8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x000013c0] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x000013c8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x000013d0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000013d8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x000013e0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x000013e8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+/* [0x000013f0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x000013f8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+/* [0x00001400] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+/* [0x00001408] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x00001410] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00001418] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00001420] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+/* [0x00001428] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00001430] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+/* [0x00001438] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+/* [0x00001440] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
 /* [0x00001448] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001450] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00001458] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00001460] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00001468] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001470] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00001478] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
-/* [0x00001480] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+/* [0x00001450] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001458] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001460] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00001468] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00001470] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00001478] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001480] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00001488] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+/* [0x00001490] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
 // ::mc_filter_uv_b
-/* [0x00001488] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00001490] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00001498] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000014a0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000014a8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000014b0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000014b8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000014c0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000014c8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000014d0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000014d8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000014e0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000014e8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000014f0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000014f8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00001500] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00001508] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00001510] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00001518] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00001520] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00001528] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00001530] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00001538] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00001540] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00001548] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00001550] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00001558] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
-/* [0x00001560] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00001568] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001570] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001578] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001580] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001588] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00001590] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001598] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000015a0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000015a8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000015b0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015b8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015c0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000015c8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000015d0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015d8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015e0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015e8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x000015f0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000015f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00001600] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00001498] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000014a0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000014a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000014b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000014b8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000014c0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000014c8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000014d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000014d8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000014e0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000014e8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000014f0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000014f8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00001500] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001508] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00001510] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00001518] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00001520] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00001528] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00001530] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00001538] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00001540] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00001548] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00001550] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00001558] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00001560] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00001568] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+/* [0x00001570] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00001578] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001580] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001588] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001590] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001598] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000015a0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000015a8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000015b0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000015b8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000015c0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015c8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015d0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000015d8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000015e0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015e8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015f0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000015f8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00001600] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00001608] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00001610] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x00001608] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00001610] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00001618] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00001620] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00001628] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00001630] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00001638] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00001640] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00001648] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00001650] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00001658] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00001660] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00001668] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
-/* [0x00001670] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00001678] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00001680] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00001688] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00001690] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00001698] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000016a0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x000016a8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x000016b0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x000016b8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x000016c0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x000016c8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x000016d0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x000016d8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x000016e0] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
-/* [0x000016e8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x000016f0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x000016f8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00001700] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00001708] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00001710] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00001718] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00001720] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00001728] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00001730] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x00001738] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x00001740] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x00001748] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x00001750] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x00001758] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00001760] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00001768] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00001770] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00001778] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00001780] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00001788] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
-/* [0x00001790] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00001798] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
-/* [0x000017a0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000017a8] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
-/* [0x000017b0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000017b8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x000017c0] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x000017c8] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
-/* [0x000017d0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000017d8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000017e0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000017e8] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000017f0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000017f8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001800] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00001808] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00001810] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00001618] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00001620] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00001628] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00001630] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00001638] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00001640] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00001648] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00001650] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00001658] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00001660] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00001668] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00001670] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00001678] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+/* [0x00001680] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00001688] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00001690] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00001698] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000016a0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000016a8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000016b0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x000016b8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x000016c0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x000016c8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x000016d0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x000016d8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x000016e0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x000016e8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x000016f0] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x000016f8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00001700] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00001708] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00001710] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00001718] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00001720] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00001728] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00001730] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00001738] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00001740] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x00001748] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x00001750] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x00001758] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x00001760] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x00001768] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00001770] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00001778] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00001780] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00001788] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00001790] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00001798] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x000017a0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000017a8] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x000017b0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000017b8] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+/* [0x000017c0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000017c8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x000017d0] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x000017d8] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+/* [0x000017e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000017e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000017f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000017f8] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00001800] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00001808] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001810] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00001818] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001820] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index db971f4..3464cdb 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -5,16 +5,16 @@ extern unsigned int rpi_shader[];
 
 #define mc_setup (rpi_shader + 0)
 #define mc_filter_uv (rpi_shader + 146)
-#define mc_filter (rpi_shader + 360)
-#define mc_filter_b (rpi_shader + 670)
-#define mc_filter_honly (rpi_shader + 894)
-#define mc_exit (rpi_shader + 1048)
-#define mc_exit1 (rpi_shader + 1066)
-#define mc_interrupt_exit (rpi_shader + 1082)
-#define mc_interrupt_exit4 (rpi_shader + 1120)
-#define mc_interrupt_exit8 (rpi_shader + 1142)
-#define mc_setup_uv (rpi_shader + 1172)
-#define mc_filter_uv_b (rpi_shader + 1314)
-#define mc_end (rpi_shader + 1542)
+#define mc_filter (rpi_shader + 364)
+#define mc_filter_b (rpi_shader + 674)
+#define mc_filter_honly (rpi_shader + 898)
+#define mc_exit (rpi_shader + 1052)
+#define mc_exit1 (rpi_shader + 1070)
+#define mc_interrupt_exit (rpi_shader + 1086)
+#define mc_interrupt_exit4 (rpi_shader + 1124)
+#define mc_interrupt_exit8 (rpi_shader + 1146)
+#define mc_setup_uv (rpi_shader + 1176)
+#define mc_filter_uv_b (rpi_shader + 1318)
+#define mc_end (rpi_shader + 1546)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index b670b12..e28f54e 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -1,608 +1,610 @@
-# register allocation
-#
-# ra0...ra7                                     eight horizontal filter coefficients
-#
-# rb1...rb7                                     seven shifted copies of the current unfiltered row
-#
-# ra8...ra15                                    eight filtered rows of context (rb15 == most recent)
-#
-#                                               (ra15 isn't clamped to zero - this happens during the
-#                                                copy to ra14, and during its use in the vertical filter)
-#
-# rb8...rb15                                    eight vertical filter coefficients
-#
-# ra16                                          clipped(row start address+elem_num)&~3
-# ra17                                          per-channel shifts
-# ra19                                          next ra17
-#
-# rb16                                          pitch
-# rb17                                          height + 5
-# rb18                                          height + 7
-# rb19                                          next ra16
-#
-# ra20                                          1
-# ra21                                          64
-# ra22                                          256
-# ra23                                          8
-#
-# rb20                                          0xffffff00
-# rb21                                          64
-# rb22                                          255
-# rb23                                          24
-#
-# rb24                                          vdw_setup_1(dst_pitch) 
-# rb25                                          frame width-1
-# rb26                                          height<<23 + width<<16 + vdw_setup_0
-# rb27                                          vdw_setup_0 (depends on QPU number)
-# rb28                                          vpm_setup (depends on QPU number)
-# rb29                                          vdw_setup_1(dst_pitch-width)
-# rb30                                          frame height-1
-# rb31                                          used as temp to count loop iterations
-#
-# ra24...ra30                                   15, 14, 13, 12, 11, 10, 9
-# ra24                                          clipped(row start address+8+elem_num)&~3
-# ra25                                          per-channel shifts 2
-# ra26                                          next ra24
-# ra27                                          next ra25
-# ra28                                          next y
-# ra29                                          y for next texture access
-#
-# ra31                                          next kernel address
-
-.set rb_frame_width_minus_1,       rb25
-.set rb_frame_height_minus_1,      rb30
-.set rb_pitch,                     rb16
-.set ra_x_base,                    ra16
-.set rb_x_base_next,               rb19
-.set ra_x2_base,                   ra24
-.set ra_x2_base_next,              ra26
-.set ra_xshift,                    ra17
-
-.set ra_x2shift,                   ra25
-.set ra_u2v_ref_offset,            ra25
-
-.set ra_xshift_next,               ra19
-
-.set ra_x2shift_next,              ra27
-.set ra_u2v_dst_offset,            ra27
-
-.set ra_y_next,                    ra28
-.set ra_y,                         ra29
-
-.set rb_const_64,                  rb21
-
-# mc_setup(next_kernel, x, y, ref_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1)
-::mc_setup
-
-# Read starting kernel
-mov ra31, unif
-
-# Load first request location
-add ra_x_base, unif, elem_num # Store x
-mov ra_y, unif # Store y
-mov ra_x2_base, unif # Store frame base
-
-# Read image dimensions
-sub rb25,unif,1
-sub rb30,unif,1
-
-# get source pitch
-mov rb16, unif
-
-# get destination pitch
-mov r0, unif
-mov r1, vdw_setup_1(0)
-add rb24, r1, r0
-
-# load constants
-
-mov ra20, 1
-mov ra21, 64
-mov ra22, 256
-mov ra23, 8
-
-mov rb20, 0xffffff00
-mov rb21, 64
-mov rb22, 255
-mov rb23, 24
-
-# touch vertical context to keep simulator happy
-
-mov ra8, 0
-mov ra9, 0
-mov ra10, 0    
-mov ra11, 0
-mov ra12, 0    
-mov ra13, 0
-mov ra14, 0    
-mov ra15, 0
-
-# Compute part of VPM to use for DMA output
-mov r2, qpu_num
-and r2, r2, 15
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
-shl r0, r0, 5
-add rb27, r0, r1
-
-# Compute part of VPM to save data into
-mov r2, qpu_num
-and r2, r2, 15
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vpm_setup(0, 4, h8p(0, 0))
-add rb28, r0, r1 
-
-# Compute base address for first and second access
-#add r0, unif, elem_num     # x
-mov r0, ra_x_base           # Load x
-add r2, r0, 8               # x+8
-max r0, r0, 0; mov r1, ra_y # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
-shl ra_xshift_next, r0, 3
-max r2, r2, 0
-add ra_y, r1, 1
-min r2, r2, rb_frame_width_minus_1
-shl ra_x2shift_next, r2, 3
-max r1, r1, 0  # y
-min r1, r1, rb_frame_height_minus_1
-add r0, r0, r3; mul24 r1, r1, rb_pitch
-add r2, r2, r3
-and r0, r0, ~3
-and r2, r2, ~3; mov ra_x_base, r0
-# submit texture requests for first line
-add t0s, r0, r1 ; mov ra_x2_base, r2
-add t0s, r2, r1
-
-# Dump padding words
-mov r0, unif
-mov r0, unif
-
-# submit texture requests for second line
-max r1, ra_y, 0
-min r1, r1, rb_frame_height_minus_1
-add ra_y, ra_y, 1
-bra -, ra31
-nop ; mul24 r1, r1, rb_pitch
-add t0s, r1, ra_x_base
-add t0s, r1, ra_x2_base
-
-################################################################################
-
-# mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
-
-# At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
-::mc_filter_uv
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num    # x
-max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
-shl ra_xshift_next, r0, 3
-sub r2, unif, r3 # compute offset from frame base u to frame base v
-add r0, r0, r3
-and rb_x_base_next, r0, ~3 
-mov ra_y_next, r1
-add ra_x2_base_next, rb_x_base_next, r2
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
-shl r0, r0, 7
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-
-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
-
-# get filter coefficients
-
-mov r0, unif
-asr ra3, r0, rb23;      mul24 r0, r0, ra22
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-asr rb11, r0, rb23;     mul24 r0, r0, ra22
-asr rb10, r0, rb23;     mul24 r0, r0, ra22
-asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-asr rb12, r0, rb23  
-
-# r2 is elem_num
-# r3 is loop counter
-
-mov r5rep, -8 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-mov r3, 0
-
-:uvloop
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-mov r2, rb21         ; mul24 r2, r0, ra0
-nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-nop                  ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-add r0, r2, r3
-
-mov r3, rb31
-
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-mov ra13, ra14
-
-sub.setf -, r3, 8 ; mov r1, ra22
-
-# apply horizontal filter         
-brr.anyn -, r:uvloop
-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 14          ; mov r1, ra21
-min.setf ra15, r0, rb22
- 
-# apply vertical filter and write to VPM
-
-nop                     ; mul24 r1, ra14, rb14
-nop                     ; mul24 r0, ra13, rb13
-add r1, r1, r0          ; mul24 r0, ra12, rb12
-add r1, r1, r0          ; mul24 r0, ra11, rb11
-add r1, r1, r0          ; mul24 r0, ra10, rb10
-add r1, r1, r0          ; mul24 r0, ra9, rb9
-add r1, r1, r0          ; mul24 r0, ra8, rb8
-add r1, r1, r0          ; mul24 r0, ra15, rb15
-add.ifnn r1, r1, r0     ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-brr.anyn -, r:uvloop 
-asr r1, r1, 14          
-min r1, r1, rb22        
-max vpm, r1, 0
-
-# DMA out for U
-
-mov vw_setup, rb26 # VDW setup 0
-mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW
-
-# DMA out for V
-# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
-# Could potentially push this write into the start of the next pipeline stage.
-mov r0, 16
-mov -, vw_wait
-
-bra -, ra31
-add vw_setup, rb26, r0 # VDW setup 0
-mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW
-
-################################################################################
-
-
-# mc_filter(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
-
-# At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
-::mc_filter
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-mov ra_x2shift, ra_x2shift_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num    # x
-add r2, r0, 8 # x+8
-max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
-shl ra_xshift_next, r0, 3
-max r2, r2, 0
-min r2, r2, rb_frame_width_minus_1
-shl ra_x2shift_next, r2, 3
-add r0, r0, r3
-add r2, r2, r3
-and rb_x_base_next, r0, ~3 
-and ra_x2_base_next, r2, ~3
-mov ra_y_next, r1
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
-shl r0, r0, 7
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-
-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
-
-# get filter coefficients
-
-mov r0, unif
-asr ra3, r0, rb23;      mul24 r0, r0, ra22
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-asr rb11, r0, rb23;     mul24 r0, r0, ra22
-asr rb10, r0, rb23;     mul24 r0, r0, ra22
-asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-brr.anynn -, r:fast_path
-asr rb12, r0, rb23  # delay slot 1
-
-# r2 is elem_num
-# r3 is loop counter
-
-mov r5rep, -8 # delay slot 2
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
-
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-## nop                                                                 ; ldtmu0     # loop counter increment
-## shr r0, r4, ra17                                                    ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21         ; mul24 r3, r0, ra0
-## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15                  
-## sub r2, r2, r3                                                    ; ldtmu0
-## 
-## mov r0, ra22
-## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # apply horizontal filter
-## 
-## asr r2, r2, 15    ; mul24 r3, r0, ra0
-## min r2, r2, rb22
-## max ra13, r2, 0
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21         
-## sub r2, r2, r3 ; mul24      r3, ra1 << 1, r0 << 1
-## nop            ; mul24.ifnz r3, ra1 << 9, r1 << 9
-## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
-## nop            ; mul24.ifnz r3, ra2 << 10, r1 << 10
-## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
-## nop            ; mul24.ifnz r3, ra3 << 11, r1 << 11
-## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
-## nop            ; mul24.ifnz r3, ra4 << 12, r1 << 12
-## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
-## nop            ; mul24.ifnz r3, ra5 << 13, r1 << 13
-## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
-## nop            ; mul24.ifnz r3, ra6 << 14, r1 << 14
-## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
-## nop            ; mul24.ifnz r3, ra7 << 15, r1 << 15
-## sub r0, r2, r3
-## 
-## # apply horizontal filter
-## 
-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
-## asr r0, r0, 15
-## min r0, r0, rb22
-## max ra14, r0, 0
-## 
-## 
-## 
-## 
-## nop                                                                 ; ldtmu0     # loop counter increment
-## shr r0, r4, ra17                                                    ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21         ; mul24 r3, r0, ra0
-## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-## sub r0, r2, r3
-## 
-## # apply horizontal filter
-## 
-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
-## asr r0, r0, 15
-## min r0, r0, rb22
-## max ra15, r0, 0
-
-
-
-
-mov r3, 0
-
-:loop
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-mov r2, rb21         ; mul24 r3, r0, ra0
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3
-
-mov r3, rb31
-
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-mov ra13, ra14
-
-sub.setf -, r3, 8 ; mov r1, ra22
-
-# apply horizontal filter         
-brr.anyn -, r:loop
-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 15          ; mov r1, ra21
-min.setf ra15, r0, rb22
- 
-# apply vertical filter and write to VPM
-
-nop                     ; mul24 r0, ra14, rb14
-sub r1, r1, r0          ; mul24 r0, ra13, rb13
-sub r1, r1, r0          ; mul24 r0, ra12, rb12
-sub r1, r1, r0          ; mul24 r0, ra11, rb11
-sub r1, r1, r0          ; mul24 r0, ra10, rb10
-sub r1, r1, r0          ; mul24 r0, ra9, rb9
-sub r1, r1, r0          ; mul24 r0, ra8, rb8
-sub r1, r1, r0          ; mul24 r0, ra15, rb15
-sub.ifnn r1, r1, r0     ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-brr.anyn -, r:loop 
-asr r1, r1, 15          
-min r1, r1, rb22        
-max vpm, r1, 0
-
-# DMA out
-
-bra -, ra31
-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
-mov vw_setup, rb29
-mov vw_addr, unif # start the VDW
-
+# register allocation
+#
+# ra0...ra7                                     eight horizontal filter coefficients
+#
+# rb1...rb7                                     seven shifted copies of the current unfiltered row
+#
+# ra8...ra15                                    eight filtered rows of context (rb15 == most recent)
+#
+#                                               (ra15 isn't clamped to zero - this happens during the
+#                                                copy to ra14, and during its use in the vertical filter)
+#
+# rb8...rb15                                    eight vertical filter coefficients
+#
+# ra16                                          clipped(row start address+elem_num)&~3
+# ra17                                          per-channel shifts
+# ra19                                          next ra17
+#
+# rb16                                          pitch
+# rb17                                          height + 5
+# rb18                                          height + 7
+# rb19                                          next ra16
+#
+# ra20                                          1
+# ra21                                          32
+# ra22                                          256
+# ra23                                          8
+#
+# rb20                                          0xffffff00
+# rb21                                          64
+# rb22                                          255
+# rb23                                          24
+#
+# rb24                                          vdw_setup_1(dst_pitch) 
+# rb25                                          frame width-1
+# rb26                                          height<<23 + width<<16 + vdw_setup_0
+# rb27                                          vdw_setup_0 (depends on QPU number)
+# rb28                                          vpm_setup (depends on QPU number)
+# rb29                                          vdw_setup_1(dst_pitch-width)
+# rb30                                          frame height-1
+# rb31                                          used as temp to count loop iterations
+#
+# ra24...ra30                                   15, 14, 13, 12, 11, 10, 9
+# ra24                                          clipped(row start address+8+elem_num)&~3
+# ra25                                          per-channel shifts 2
+# ra26                                          next ra24
+# ra27                                          next ra25
+# ra28                                          next y
+# ra29                                          y for next texture access
+#
+# ra31                                          next kernel address
+
+.set rb_frame_width_minus_1,       rb25
+.set rb_frame_height_minus_1,      rb30
+.set rb_pitch,                     rb16
+.set ra_x_base,                    ra16
+.set rb_x_base_next,               rb19
+.set ra_x2_base,                   ra24
+.set ra_x2_base_next,              ra26
+.set ra_xshift,                    ra17
+
+.set ra_x2shift,                   ra25
+.set ra_u2v_ref_offset,            ra25
+
+.set ra_xshift_next,               ra19
+
+.set ra_x2shift_next,              ra27
+.set ra_u2v_dst_offset,            ra27
+
+.set ra_y_next,                    ra28
+.set ra_y,                         ra29
+
+.set rb_const_64,                  rb21
+
+# mc_setup(next_kernel, x, y, ref_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1)
+::mc_setup
+
+# Read starting kernel
+mov ra31, unif
+
+# Load first request location
+add ra_x_base, unif, elem_num # Store x
+mov ra_y, unif # Store y
+mov ra_x2_base, unif # Store frame base
+
+# Read image dimensions
+sub rb25,unif,1
+sub rb30,unif,1
+
+# get source pitch
+mov rb16, unif
+
+# get destination pitch
+mov r0, unif
+mov r1, vdw_setup_1(0)
+add rb24, r1, r0
+
+# load constants
+
+mov ra20, 1
+mov ra21, 32
+mov ra22, 256
+mov ra23, 8
+
+mov rb20, 0xffffff00
+mov rb21, 64
+mov rb22, 255
+mov rb23, 24
+
+# touch vertical context to keep simulator happy
+
+mov ra8, 0
+mov ra9, 0
+mov ra10, 0    
+mov ra11, 0
+mov ra12, 0    
+mov ra13, 0
+mov ra14, 0    
+mov ra15, 0
+
+# Compute part of VPM to use for DMA output
+mov r2, qpu_num
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+shl r0, r0, 5
+add rb27, r0, r1
+
+# Compute part of VPM to save data into
+mov r2, qpu_num
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vpm_setup(0, 4, h8p(0, 0))
+add rb28, r0, r1 
+
+# Compute base address for first and second access
+#add r0, unif, elem_num     # x
+mov r0, ra_x_base           # Load x
+add r2, r0, 8               # x+8
+max r0, r0, 0; mov r1, ra_y # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
+shl ra_xshift_next, r0, 3
+max r2, r2, 0
+add ra_y, r1, 1
+min r2, r2, rb_frame_width_minus_1
+shl ra_x2shift_next, r2, 3
+max r1, r1, 0  # y
+min r1, r1, rb_frame_height_minus_1
+add r0, r0, r3; mul24 r1, r1, rb_pitch
+add r2, r2, r3
+and r0, r0, ~3
+and r2, r2, ~3; mov ra_x_base, r0
+# submit texture requests for first line
+add t0s, r0, r1 ; mov ra_x2_base, r2
+add t0s, r2, r1
+
+# Dump padding words
+mov r0, unif
+mov r0, unif
+
+# submit texture requests for second line
+max r1, ra_y, 0
+min r1, r1, rb_frame_height_minus_1
+add ra_y, ra_y, 1
+bra -, ra31
+nop ; mul24 r1, r1, rb_pitch
+add t0s, r1, ra_x_base
+add t0s, r1, ra_x2_base
+
+################################################################################
+
+# mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter_uv
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+shl ra_xshift_next, r0, 3
+sub r2, unif, r3 # compute offset from frame base u to frame base v
+add r0, r0, r3
+and rb_x_base_next, r0, ~3 
+mov ra_y_next, r1
+add ra_x2_base_next, rb_x_base_next, r2
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+asr rb12, r0, rb23  
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+mov r3, 0
+
+:uvloop
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+nop                  ; mul24 r2, r0, ra0
+nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+nop                  ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+add r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:uvloop
+mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
+asr ra15, r0, 8         ; nop
+nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r1, ra14, rb14
+nop                     ; mul24 r0, ra13, rb13
+add r1, r1, r0          ; mul24 r0, ra12, rb12
+add r1, r1, r0          ; mul24 r0, ra11, rb11
+add r1, r1, r0          ; mul24 r0, ra10, rb10
+add r1, r1, r0          ; mul24 r0, ra9, rb9
+add r1, r1, r0          ; mul24 r0, ra8, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb15
+add r1, r1, r0          ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+asr r1, r1, 14
+add r1, r1, ra21
+brr.anyn -, r:uvloop 
+asr r1, r1, 6          # Delay 1
+min r1, r1, rb22       # Delay 2
+max vpm, r1, 0         # Delay 3
+
+# DMA out for U
+
+mov vw_setup, rb26 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+# DMA out for V
+# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+# Could potentially push this write into the start of the next pipeline stage.
+mov r0, 16
+mov -, vw_wait
+
+bra -, ra31
+add vw_setup, rb26, r0 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+################################################################################
+
+
+# mc_filter(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+mov ra_x2shift, ra_x2shift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+add r2, r0, 8 # x+8
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+shl ra_xshift_next, r0, 3
+max r2, r2, 0
+min r2, r2, rb_frame_width_minus_1
+shl ra_x2shift_next, r2, 3
+add r0, r0, r3
+add r2, r2, r3
+and rb_x_base_next, r0, ~3 
+and ra_x2_base_next, r2, ~3
+mov ra_y_next, r1
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+brr.anynn -, r:fast_path
+asr rb12, r0, rb23  # delay slot 1
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 # delay slot 2
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+## nop                                                                 ; ldtmu0     # loop counter increment
+## shr r0, r4, ra17                                                    ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21         ; mul24 r3, r0, ra0
+## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15                  
+## sub r2, r2, r3                                                    ; ldtmu0
+## 
+## mov r0, ra22
+## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # apply horizontal filter
+## 
+## asr r2, r2, 15    ; mul24 r3, r0, ra0
+## min r2, r2, rb22
+## max ra13, r2, 0
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21         
+## sub r2, r2, r3 ; mul24      r3, ra1 << 1, r0 << 1
+## nop            ; mul24.ifnz r3, ra1 << 9, r1 << 9
+## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
+## nop            ; mul24.ifnz r3, ra2 << 10, r1 << 10
+## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
+## nop            ; mul24.ifnz r3, ra3 << 11, r1 << 11
+## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
+## nop            ; mul24.ifnz r3, ra4 << 12, r1 << 12
+## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
+## nop            ; mul24.ifnz r3, ra5 << 13, r1 << 13
+## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
+## nop            ; mul24.ifnz r3, ra6 << 14, r1 << 14
+## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
+## nop            ; mul24.ifnz r3, ra7 << 15, r1 << 15
+## sub r0, r2, r3
+## 
+## # apply horizontal filter
+## 
+## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+## asr r0, r0, 15
+## min r0, r0, rb22
+## max ra14, r0, 0
+## 
+## 
+## 
+## 
+## nop                                                                 ; ldtmu0     # loop counter increment
+## shr r0, r4, ra17                                                    ; ldtmu0         
+## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+## add ra16, ra16, rb16 ; mov t0s, ra16
+## 
+## # generate seven shifted versions
+## # interleave with scroll of vertical context
+## 
+## mov r2, rb21         ; mul24 r3, r0, ra0
+## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+## sub r0, r2, r3
+## 
+## # apply horizontal filter
+## 
+## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+## asr r0, r0, 15
+## min r0, r0, rb22
+## max ra15, r0, 0
+
+
+
+
+mov r3, 0
+
+:loop
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:loop
+max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr r0, r0, 15          ; mov r1, ra21
+min.setf ra15, r0, rb22
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r0, ra14, rb14
+sub r1, r1, r0          ; mul24 r0, ra13, rb13
+sub r1, r1, r0          ; mul24 r0, ra12, rb12
+sub r1, r1, r0          ; mul24 r0, ra11, rb11
+sub r1, r1, r0          ; mul24 r0, ra10, rb10
+sub r1, r1, r0          ; mul24 r0, ra9, rb9
+sub r1, r1, r0          ; mul24 r0, ra8, rb8
+sub r1, r1, r0          ; mul24 r0, ra15, rb15
+sub.ifnn r1, r1, r0     ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+brr.anyn -, r:loop 
+asr r1, r1, 15          
+min r1, r1, rb22        
+max vpm, r1, 0
+
+# DMA out
+
+bra -, ra31
+mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+mov vw_setup, rb29
+mov vw_addr, unif # start the VDW
+
 ####################################################
 
 :fast_path
@@ -691,18 +693,18 @@ mov r3, 0  # This signifies the amount of unrolling
 
 :fast_loop
 # retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-# Due to pipelining we can only skip second pipeline instructions related to the fetched pixels
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_y, ra_y_next   ; mov rb31, r3
-mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch   
-
-max r2, ra_y, 0           
-min r2, r2, rb_frame_height_minus_1 ; mov r1, r4  # discard texture read
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20                                     
+# then submit two more texture requests
+
+# Due to pipelining we can only skip second pipeline instructions related to the fetched pixels
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_y, ra_y_next   ; mov rb31, r3
+mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch   
+
+max r2, ra_y, 0           
+min r2, r2, rb_frame_height_minus_1 ; mov r1, r4  # discard texture read
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20                                     
 add t0s, ra_x2_base, r2   
 
 # generate seven shifted versions
@@ -726,7 +728,7 @@ mov ra12, ra13
 mov ra13, ra14
 
 sub.setf -, r3, 8       ; mov r1, ra22
-
+
 # apply horizontal filter                   
                     
 brr.anyn -, r:fast_loop
@@ -758,656 +760,656 @@ mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
 mov vw_setup, rb29
 mov vw_addr, unif # start the VDW
 
-################################################################################
-
-# mc_filter_b(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
-
-# At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
-::mc_filter_b
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-mov ra_x2shift, ra_x2shift_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num    # x
-add r2, r0, 8 # x+8
-max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
-shl ra_xshift_next, r0, 3
-max r2, r2, 0
-min r2, r2, rb_frame_width_minus_1
-shl ra_x2shift_next, r2, 3
-add r0, r0, r3
-add r2, r2, r3
-and rb_x_base_next, r0, ~3 
-and ra_x2_base_next, r2, ~3
-mov ra_y_next, r1
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
-shl r0, r0, 7
-# r0 is currently height<<7
-# For vr_setup we want height<<20 (so 20-7=13 additional bits)
-shl r3, r0, 13 
-shl r3, r3, 8 # Mask off top 8 bits
-shr r3, r3, 8
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-# In a B frame, so also set up VPM read
-add vr_setup, r3, rb28
-
-# get filter coefficients
-
-mov r0, unif
-asr ra3, r0, rb23;      mul24 r0, r0, ra22
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-asr rb11, r0, rb23;     mul24 r0, r0, ra22
-asr rb10, r0, rb23;     mul24 r0, r0, ra22
-asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-asr rb12, r0, rb23
-
-# r2 is elem_num
-# r3 is loop counter
-
-mov r5rep, -8 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  
-mov r3, 0
-
-:bloop
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-mov r2, rb21         ; mul24 r3, r0, ra0
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3
-
-mov r3, rb31
-
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-mov ra13, ra14
-
-sub.setf -, r3, 8 ; mov r1, ra22
-
-# apply horizontal filter         
-brr.anyn -, r:bloop
-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 15          ; mov r1, ra21
-min.setf ra15, r0, rb22
- 
-# apply vertical filter and write to VPM
-
-nop                     ; mul24 r0, ra14, rb14
-sub r1, r1, r0          ; mul24 r0, ra13, rb13
-sub r1, r1, r0          ; mul24 r0, ra12, rb12
-sub r1, r1, r0          ; mul24 r0, ra11, rb11
-sub r1, r1, r0          ; mul24 r0, ra10, rb10
-sub r1, r1, r0          ; mul24 r0, ra9, rb9
-sub r1, r1, r0          ; mul24 r0, ra8, rb8
-sub r1, r1, r0          ; mul24 r0, ra15, rb15
-sub.ifnn r1, r1, r0     ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 15          ; mov -, vr_wait         
-min r1, r1, rb22        
-add r0, vpm, 1          # Blend in previous VPM contents at this location
-brr.anyn -, r:bloop 
-max r1, r1, 0
-add r1, r1, r0
-shr vpm, r1, 1
-
-# DMA out
-
-bra -, ra31
-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
-mov vw_setup, rb29
-mov vw_addr, unif # start the VDW
-
-################################################################################
-
-# mc_filter_honly(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
-# This filter only does horizontal filtering.
-# It is assumed that the region to fetch does not include extra rows above.
-
-# At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
-::mc_filter_honly
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-mov ra_x2shift, ra_x2shift_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num    # x
-add r2, r0, 8 # x+8
-max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
-shl ra_xshift_next, r0, 3
-max r2, r2, 0
-min r2, r2, rb_frame_width_minus_1
-shl ra_x2shift_next, r2, 3
-add r0, r0, r3
-add r2, r2, r3
-and rb_x_base_next, r0, ~3 
-and ra_x2_base_next, r2, ~3
-mov ra_y_next, r1
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, -2 # Pipelining means we move data across 2 iterations early
-shl r0, r0, 7 ; mov rb18,r0
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-
-# get filter coefficients
-
-mov r0, unif
-asr ra3, r0, rb23;      mul24 r0, r0, ra22
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-mov r0, unif
-
-# r2 is elem_num
-# r3 is loop counter
-mov r5rep, -8 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
-mov r3, 0
-
-:loop_honly
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-mov r2, rb21         ; mul24 r3, r0, ra0
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3       ; mov r3, rb31
-
-sub.setf -, r3, rb18 ; mov r1, ra22
-
-mov -, vw_wait   ; mul24 r0, r0, r1  
-brr.anyn -, r:loop_honly     
-asr r0, r0, 15          # delay 1     
-min r0, r0, rb22        # delay 2
-max vpm, r0, 0          # delay 3
- 
-# DMA out
-bra -, ra31
-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
-mov vw_setup, rb29
-mov vw_addr, unif # start the VDW
-
-
-################################################################################
-
-# mc_exit()
-
-::mc_exit
-mov  -, vw_wait # wait on the VDW
-
-mov -,srel(0)
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-nop        ; nop ; thrend
-nop        ; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-::mc_exit1 
-mov  -, vw_wait # wait on the VDW
-
-#mov -,srel(1)
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-nop        ; nop ; thrend
-mov interrupt, 1; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-# mc_interrupt_exit()
-::mc_interrupt_exit 
-mov  -, vw_wait # wait on the VDW
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-mov -,sacq(0) # 1 
-mov -,sacq(0) # 2 
-mov -,sacq(0) # 3 
-mov -,sacq(0) # 4 
-mov -,sacq(0) # 5 
-mov -,sacq(0) # 6 
-mov -,sacq(0) # 7 
-mov -,sacq(0) # 8 
-mov -,sacq(0) # 9 
-mov -,sacq(0) # 10
-mov -,sacq(0) # 11
-
-nop        ; nop ; thrend
-mov interrupt, 1; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-# mc_interrupt_exit4()
-::mc_interrupt_exit4 
-mov  -, vw_wait # wait on the VDW
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-mov -,sacq(0) # 1 
-mov -,sacq(0) # 2 
-mov -,sacq(0) # 3 
-
-nop        ; nop ; thrend
-mov interrupt, 1; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-# mc_interrupt_exit8()
-::mc_interrupt_exit8 
-mov  -, vw_wait # wait on the VDW
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-mov -,sacq(0) # 1 
-mov -,sacq(0) # 2 
-mov -,sacq(0) # 3 
-mov -,sacq(0) # 4 
-mov -,sacq(0) # 5 
-mov -,sacq(0) # 6 
-mov -,sacq(0) # 7 
-
-nop        ; nop ; thrend
-mov interrupt, 1; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-################################################################################
-# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
-::mc_setup_uv
-
-# Read starting kernel
-mov ra31, unif
-
-# Load first request location
-add ra_x_base, unif, elem_num # Store x
-mov ra_y, unif # Store y
-mov ra_x2_base, unif # Store frame u base
-nop
-sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
-
-# Read image dimensions
-sub rb25,unif,1
-sub rb30,unif,1
-
-# get source pitch
-mov rb16, unif
-
-# get destination pitch
-mov r0, unif
-mov r1, vdw_setup_1(0)
-add rb24, r1, r0
-
-# load constants
-
-mov ra20, 1
-mov ra21, 64
-mov ra22, 256
-mov ra23, 8
-
-mov rb20, 0xffffff00
-mov rb21, 64
-mov rb22, 255
-mov rb23, 24
-
-# touch vertical context to keep simulator happy
-
-mov ra8, 0
-mov ra9, 0
-mov ra10, 0    
-mov ra11, 0
-mov ra12, 0    
-mov ra13, 0
-mov ra14, 0    
-mov ra15, 0
-
-# Compute part of VPM to use for DMA output
-mov r2, qpu_num
-and r2, r2, 15
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
-shl r0, r0, 5
-add rb27, r0, r1
-
-# Compute part of VPM to save data into
-mov r2, qpu_num
-and r2, r2, 15
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vpm_setup(0, 4, h8p(0, 0))
-add rb28, r0, r1 
-
-# Compute base address for first and second access
-mov r0, ra_x_base           # Load x
-max r0, r0, 0; mov r1, ra_y # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
-shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-add ra_y, r1, 1
-add r0, r0, r3
-and r0, r0, ~3
-max r1, r1, 0 ; mov ra_x_base, r0 # y
-min r1, r1, rb_frame_height_minus_1
-# submit texture requests for first line
-add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-add t0s, r0, r1 ; mov ra_x2_base, r2
-add t0s, r2, r1
-
-# Dump padding words
-mov r0, unif
-mov r0, unif
-mov r0, unif
-
-# submit texture requests for second line
-max r1, ra_y, 0
-min r1, r1, rb_frame_height_minus_1
-add ra_y, ra_y, 1
-bra -, ra31
-nop ; mul24 r1, r1, rb_pitch
-add t0s, r1, ra_x_base
-add t0s, r1, ra_x2_base
-
-
-
-################################################################################
-
-::mc_filter_uv_b
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num    # x
-max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
-shl ra_xshift_next, r0, 3
-sub r2, unif, r3 # compute offset from frame base u to frame base v
-add r0, r0, r3
-and rb_x_base_next, r0, ~3 
-mov ra_y_next, r1
-add ra_x2_base_next, rb_x_base_next, r2
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
-shl r0, r0, 7
-
-# r0 is currently height<<7
-# For vr_setup we want height<<20 (so 20-7=13 additional bits)
-shl r3, r0, 13 
-shl r3, r3, 8 # Mask off top 8 bits
-shr r3, r3, 8
-
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-
-# In a B frame, so also set up VPM read
-add vr_setup, r3, rb28
-
-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
-
-# get filter coefficients
-
-mov r0, unif
-asr ra3, r0, rb23;      mul24 r0, r0, ra22
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-asr rb11, r0, rb23;     mul24 r0, r0, ra22
-asr rb10, r0, rb23;     mul24 r0, r0, ra22
-asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-asr rb12, r0, rb23  
-
-# r2 is elem_num
-# r3 is loop counter
-
-mov r5rep, -8 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-mov r3, 0
-
-:uvloop_b
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-mov r2, rb21         ; mul24 r3, r0, ra0
-nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3
-
-mov r3, rb31
-
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-mov ra13, ra14
-
-sub.setf -, r3, 8 ; mov r1, ra22
-
-# apply horizontal filter         
-brr.anyn -, r:uvloop_b
-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 15          ; mov r1, ra21
-min.setf ra15, r0, rb22
- 
-# apply vertical filter and write to VPM
-
-nop                     ; mul24 r0, ra14, rb14
-sub r1, r1, r0          ; mul24 r0, ra13, rb13
-sub r1, r1, r0          ; mul24 r0, ra12, rb12
-sub r1, r1, r0          ; mul24 r0, ra11, rb11
-sub r1, r1, r0          ; mul24 r0, ra10, rb10
-sub r1, r1, r0          ; mul24 r0, ra9, rb9
-sub r1, r1, r0          ; mul24 r0, ra8, rb8
-sub r1, r1, r0          ; mul24 r0, ra15, rb15
-sub.ifnn r1, r1, r0     ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 15          
-min r1, r1, rb22        
-add r0, vpm, 1          # Blend in previous VPM contents at this location
-brr.anyn -, r:uvloop_b
-max r1, r1, 0
-add r1, r1, r0
-shr vpm, r1, 1
-
-
-# DMA out for U
-
-mov vw_setup, rb26 # VDW setup 0
-mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW
-
-# DMA out for V
-# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
-# Could potentially push this write into the start of the next pipeline stage.
-mov r0, 16
-mov -, vw_wait
-
-bra -, ra31
-add vw_setup, rb26, r0 # VDW setup 0
-mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW
-
-::mc_end
+################################################################################
+
+# mc_filter_b(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter_b
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+mov ra_x2shift, ra_x2shift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+add r2, r0, 8 # x+8
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+shl ra_xshift_next, r0, 3
+max r2, r2, 0
+min r2, r2, rb_frame_width_minus_1
+shl ra_x2shift_next, r2, 3
+add r0, r0, r3
+add r2, r2, r3
+and rb_x_base_next, r0, ~3 
+and ra_x2_base_next, r2, ~3
+mov ra_y_next, r1
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+# r0 is currently height<<7
+# For vr_setup we want height<<20 (so 20-7=13 additional bits)
+shl r3, r0, 13 
+shl r3, r3, 8 # Mask off top 8 bits
+shr r3, r3, 8
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+# In a B frame, so also set up VPM read
+add vr_setup, r3, rb28
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+asr rb12, r0, rb23
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  
+mov r3, 0
+
+:bloop
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:bloop
+max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr r0, r0, 15          ; mov r1, ra21
+min.setf ra15, r0, rb22
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r0, ra14, rb14
+sub r1, r1, r0          ; mul24 r0, ra13, rb13
+sub r1, r1, r0          ; mul24 r0, ra12, rb12
+sub r1, r1, r0          ; mul24 r0, ra11, rb11
+sub r1, r1, r0          ; mul24 r0, ra10, rb10
+sub r1, r1, r0          ; mul24 r0, ra9, rb9
+sub r1, r1, r0          ; mul24 r0, ra8, rb8
+sub r1, r1, r0          ; mul24 r0, ra15, rb15
+sub.ifnn r1, r1, r0     ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+asr r1, r1, 15          ; mov -, vr_wait         
+min r1, r1, rb22        
+add r0, vpm, 1          # Blend in previous VPM contents at this location
+brr.anyn -, r:bloop 
+max r1, r1, 0
+add r1, r1, r0
+shr vpm, r1, 1
+
+# DMA out
+
+bra -, ra31
+mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+mov vw_setup, rb29
+mov vw_addr, unif # start the VDW
+
+################################################################################
+
+# mc_filter_honly(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+# This filter only does horizontal filtering.
+# It is assumed that the region to fetch does not include extra rows above.
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter_honly
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+mov ra_x2shift, ra_x2shift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+add r2, r0, 8 # x+8
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+shl ra_xshift_next, r0, 3
+max r2, r2, 0
+min r2, r2, rb_frame_width_minus_1
+shl ra_x2shift_next, r2, 3
+add r0, r0, r3
+add r2, r2, r3
+and rb_x_base_next, r0, ~3 
+and ra_x2_base_next, r2, ~3
+mov ra_y_next, r1
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, -2 # Pipelining means we move data across 2 iterations early
+shl r0, r0, 7 ; mov rb18,r0
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+mov r0, unif
+
+# r2 is elem_num
+# r3 is loop counter
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
+mov r3, 0
+
+:loop_honly
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3       ; mov r3, rb31
+
+sub.setf -, r3, rb18 ; mov r1, ra22
+
+mov -, vw_wait   ; mul24 r0, r0, r1  
+brr.anyn -, r:loop_honly     
+asr r0, r0, 15          # delay 1     
+min r0, r0, rb22        # delay 2
+max vpm, r0, 0          # delay 3
+ 
+# DMA out
+bra -, ra31
+mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+mov vw_setup, rb29
+mov vw_addr, unif # start the VDW
+
+
+################################################################################
+
+# mc_exit()
+
+::mc_exit
+mov  -, vw_wait # wait on the VDW
+
+mov -,srel(0)
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+nop        ; nop ; thrend
+nop        ; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+::mc_exit1 
+mov  -, vw_wait # wait on the VDW
+
+#mov -,srel(1)
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+# mc_interrupt_exit()
+::mc_interrupt_exit 
+mov  -, vw_wait # wait on the VDW
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+mov -,sacq(0) # 1 
+mov -,sacq(0) # 2 
+mov -,sacq(0) # 3 
+mov -,sacq(0) # 4 
+mov -,sacq(0) # 5 
+mov -,sacq(0) # 6 
+mov -,sacq(0) # 7 
+mov -,sacq(0) # 8 
+mov -,sacq(0) # 9 
+mov -,sacq(0) # 10
+mov -,sacq(0) # 11
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+# mc_interrupt_exit4()
+::mc_interrupt_exit4 
+mov  -, vw_wait # wait on the VDW
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+mov -,sacq(0) # 1 
+mov -,sacq(0) # 2 
+mov -,sacq(0) # 3 
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+# mc_interrupt_exit8()
+::mc_interrupt_exit8 
+mov  -, vw_wait # wait on the VDW
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+mov -,sacq(0) # 1 
+mov -,sacq(0) # 2 
+mov -,sacq(0) # 3 
+mov -,sacq(0) # 4 
+mov -,sacq(0) # 5 
+mov -,sacq(0) # 6 
+mov -,sacq(0) # 7 
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+################################################################################
+# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
+::mc_setup_uv
+
+# Read starting kernel
+mov ra31, unif
+
+# Load first request location
+add ra_x_base, unif, elem_num # Store x
+mov ra_y, unif # Store y
+mov ra_x2_base, unif # Store frame u base
+nop
+sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
+
+# Read image dimensions
+sub rb25,unif,1
+sub rb30,unif,1
+
+# get source pitch
+mov rb16, unif
+
+# get destination pitch
+mov r0, unif
+mov r1, vdw_setup_1(0)
+add rb24, r1, r0
+
+# load constants
+
+mov ra20, 1
+mov ra21, 32
+mov ra22, 256
+mov ra23, 8
+
+mov rb20, 0xffffff00
+mov rb21, 64
+mov rb22, 255
+mov rb23, 24
+
+# touch vertical context to keep simulator happy
+
+mov ra8, 0
+mov ra9, 0
+mov ra10, 0    
+mov ra11, 0
+mov ra12, 0    
+mov ra13, 0
+mov ra14, 0    
+mov ra15, 0
+
+# Compute part of VPM to use for DMA output
+mov r2, qpu_num
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+shl r0, r0, 5
+add rb27, r0, r1
+
+# Compute part of VPM to save data into
+mov r2, qpu_num
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vpm_setup(0, 4, h8p(0, 0))
+add rb28, r0, r1 
+
+# Compute base address for first and second access
+mov r0, ra_x_base           # Load x
+max r0, r0, 0; mov r1, ra_y # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
+shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+add ra_y, r1, 1
+add r0, r0, r3
+and r0, r0, ~3
+max r1, r1, 0 ; mov ra_x_base, r0 # y
+min r1, r1, rb_frame_height_minus_1
+# submit texture requests for first line
+add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+add t0s, r0, r1 ; mov ra_x2_base, r2
+add t0s, r2, r1
+
+# Dump padding words
+mov r0, unif
+mov r0, unif
+mov r0, unif
+
+# submit texture requests for second line
+max r1, ra_y, 0
+min r1, r1, rb_frame_height_minus_1
+add ra_y, ra_y, 1
+bra -, ra31
+nop ; mul24 r1, r1, rb_pitch
+add t0s, r1, ra_x_base
+add t0s, r1, ra_x2_base
+
+
+
+################################################################################
+
+::mc_filter_uv_b
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+shl ra_xshift_next, r0, 3
+sub r2, unif, r3 # compute offset from frame base u to frame base v
+add r0, r0, r3
+and rb_x_base_next, r0, ~3 
+mov ra_y_next, r1
+add ra_x2_base_next, rb_x_base_next, r2
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+
+# r0 is currently height<<7
+# For vr_setup we want height<<20 (so 20-7=13 additional bits)
+shl r3, r0, 13 
+shl r3, r3, 8 # Mask off top 8 bits
+shr r3, r3, 8
+
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+# In a B frame, so also set up VPM read
+add vr_setup, r3, rb28
+
+sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+asr rb12, r0, rb23  
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+mov r3, 0
+
+:uvloop_b
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r2, rb21         ; mul24 r3, r0, ra0
+nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+sub r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:uvloop_b
+max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr r0, r0, 15          ; mov r1, ra21
+min.setf ra15, r0, rb22
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r0, ra14, rb14
+sub r1, r1, r0          ; mul24 r0, ra13, rb13
+sub r1, r1, r0          ; mul24 r0, ra12, rb12
+sub r1, r1, r0          ; mul24 r0, ra11, rb11
+sub r1, r1, r0          ; mul24 r0, ra10, rb10
+sub r1, r1, r0          ; mul24 r0, ra9, rb9
+sub r1, r1, r0          ; mul24 r0, ra8, rb8
+sub r1, r1, r0          ; mul24 r0, ra15, rb15
+sub.ifnn r1, r1, r0     ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+asr r1, r1, 15          
+min r1, r1, rb22        
+add r0, vpm, 1          # Blend in previous VPM contents at this location
+brr.anyn -, r:uvloop_b
+max r1, r1, 0
+add r1, r1, r0
+shr vpm, r1, 1
+
+
+# DMA out for U
+
+mov vw_setup, rb26 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+# DMA out for V
+# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+# Could potentially push this write into the start of the next pipeline stage.
+mov r0, 16
+mov -, vw_wait
+
+bra -, ra31
+add vw_setup, rb26, r0 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+::mc_end
-- 
1.9.1


From 584ebff01ed6173a640165e456130d179d14741a Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 13 May 2015 14:37:32 +0100
Subject: [PATCH 20/77] Removed unused luma functions

---
 libavcodec/hevc.c          |    4 +-
 libavcodec/rpi_qpu.c       |   32 +-
 libavcodec/rpi_shader.c    | 1097 +++++++++++++-------------------------------
 libavcodec/rpi_shader.h    |   19 +-
 libavcodec/rpi_shader.qasm | 1014 ++++------------------------------------
 5 files changed, 418 insertions(+), 1748 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 34035d5..f34c4f9 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2695,8 +2695,8 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
         return;
     for(k=0;k<8;k++) {
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP); // Also need a dummy for V        
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
+        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for V        
         assert(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
     }
              
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 255c13c..a814443 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -169,7 +169,7 @@ static int gpu_init(volatile struct GPU **gpu) {
   
   // Now copy over the QPU code into GPU memory
   {
-    int num_bytes = qpu_get_fn(QPU_MC_END) - qpu_get_fn(QPU_MC_SETUP);
+    int num_bytes = qpu_get_fn(QPU_MC_END) - qpu_get_fn(QPU_MC_SETUP_UV);
     assert(num_bytes<=QPU_CODE_SIZE*sizeof(unsigned int));
     memcpy((void*)ptr->qpu_code, rpi_shader, num_bytes);
   }
@@ -609,24 +609,24 @@ unsigned int qpu_get_fn(int num) {
       gpu_unlock();
     }
     switch(num) {
-    case QPU_MC_SETUP:
-      fn = mc_setup;
-      break;
-    case QPU_MC_FILTER:
-      fn = mc_filter;
-      break;
+    //case QPU_MC_SETUP:
+    //  fn = mc_setup;
+    //  break;
+    //case QPU_MC_FILTER:
+    //  fn = mc_filter;
+    //  break;
     case QPU_MC_EXIT:
       fn = mc_exit;
       break;
-    case QPU_MC_INTERRUPT_EXIT:
-      fn = mc_interrupt_exit;
-      break;
-    case QPU_MC_FILTER_B:
-      fn = mc_filter_b;
-      break;
-    case QPU_MC_FILTER_HONLY:
-      fn = mc_filter_honly;
-      break;
+    //case QPU_MC_INTERRUPT_EXIT:
+    //  fn = mc_interrupt_exit;
+    //  break;
+    //case QPU_MC_FILTER_B:
+    //  fn = mc_filter_b;
+    //  break;
+    //case QPU_MC_FILTER_HONLY:
+    //  fn = mc_filter_honly;
+    //  break;
     case QPU_MC_SETUP_UV:
       fn = mc_setup_uv;
       break;
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 831633b..170e8ac 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -21,798 +21,331 @@ __declspec(align(8))
 __attribute__((aligned(8)))
 #endif
 unsigned int rpi_shader[] = {
-// ::mc_setup
+// ::mc_setup_uv
 /* [0x00000000] */ 0x15827d80, 0x100207e7, // mov ra31, unif
 /* [0x00000008] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
 /* [0x00000010] */ 0x15827d80, 0x10020767, // mov ra_y, unif
 /* [0x00000018] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
-/* [0x00000020] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
-/* [0x00000028] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
-/* [0x00000030] */ 0x15827d80, 0x10021427, // mov rb16, unif
-/* [0x00000038] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000040] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
-/* [0x00000048] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
-/* [0x00000050] */ 0x00000001, 0xe0020527, // mov ra20, 1
-/* [0x00000058] */ 0x00000020, 0xe0020567, // mov ra21, 32
-/* [0x00000060] */ 0x00000100, 0xe00205a7, // mov ra22, 256
-/* [0x00000068] */ 0x00000008, 0xe00205e7, // mov ra23, 8
-/* [0x00000070] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
-/* [0x00000078] */ 0x00000040, 0xe0021567, // mov rb21, 64
-/* [0x00000080] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
-/* [0x00000088] */ 0x00000018, 0xe00215e7, // mov rb23, 24
-/* [0x00000090] */ 0x00000000, 0xe0020227, // mov ra8, 0
-/* [0x00000098] */ 0x00000000, 0xe0020267, // mov ra9, 0
-/* [0x000000a0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
-/* [0x000000a8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
-/* [0x000000b0] */ 0x00000000, 0xe0020327, // mov ra12, 0
-/* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
-/* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
-/* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x000000d0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x000000d8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x000000e0] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x000000e8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x000000f0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x000000f8] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000100] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000108] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000110] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
-/* [0x00000118] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
-/* [0x00000120] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00000128] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000130] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00000138] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000140] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000148] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000150] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000158] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000160] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000168] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x00000170] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x00000178] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
-/* [0x00000180] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
-/* [0x00000188] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
-/* [0x00000190] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
-/* [0x00000198] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000001a0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+/* [0x00000020] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000028] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
+/* [0x00000030] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+/* [0x00000038] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+/* [0x00000040] */ 0x15827d80, 0x10021427, // mov rb16, unif
+/* [0x00000048] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000050] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+/* [0x00000058] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+/* [0x00000060] */ 0x00000001, 0xe0020527, // mov ra20, 1
+/* [0x00000068] */ 0x00000020, 0xe0020567, // mov ra21, 32
+/* [0x00000070] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+/* [0x00000078] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+/* [0x00000080] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x00000088] */ 0x00000040, 0xe0021567, // mov rb21, 64
+/* [0x00000090] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x00000098] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x000000a0] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x000000a8] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x000000b0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x000000b8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x000000c0] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x000000c8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x000000d0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x000000d8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x000000e0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x000000e8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x000000f0] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x000000f8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000100] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000108] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000110] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000118] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000120] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00000128] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00000130] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00000138] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000140] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00000148] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000150] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000158] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000160] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000168] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000170] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000178] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000180] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000188] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+/* [0x00000190] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x00000198] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+/* [0x000001a0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
 /* [0x000001a8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x000001b0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
-/* [0x000001b8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
-/* [0x000001c0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x000001b0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000001b8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000001c0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
 /* [0x000001c8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x000001d0] */ 0x4c9d00cf, 0x10024821, // add r0, r0, r3; mul24 r1, r1, rb_pitch
-/* [0x000001d8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
-/* [0x000001e0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000001e8] */ 0x949dc5c0, 0xd0025890, // and r2, r2, ~3; mov ra_x_base, r0
-/* [0x000001f0] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
-/* [0x000001f8] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x00000200] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000208] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000210] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000218] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000220] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000228] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000230] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000238] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
-/* [0x00000240] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+/* [0x000001d0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+/* [0x000001d8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+/* [0x000001e0] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+/* [0x000001e8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000001f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000001f8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000200] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000208] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000210] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000218] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000220] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000228] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+/* [0x00000230] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
 // ::mc_filter_uv
-/* [0x00000248] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000250] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000258] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000260] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000268] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000270] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000278] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000280] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000288] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000290] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000298] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000002a0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000002a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000002b0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000002b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000002c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000002c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002d0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x000002d8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x000002e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000002e8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000002f0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000002f8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000300] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000330] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000338] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000340] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000348] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000350] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000358] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000360] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000368] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000370] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000378] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000380] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000388] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000390] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000398] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000003a0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000238] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000240] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000248] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000250] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000258] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000260] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000268] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000270] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000278] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000280] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000288] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000290] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000298] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000002a0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002a8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000002b0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000002b8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000002c0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x000002c8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x000002d0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000002d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000002e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000002e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000002f0] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x000002f8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000300] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000308] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000310] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000318] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000320] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000328] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000330] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000338] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000340] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000348] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000350] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000358] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000360] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000368] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000370] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000378] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000380] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000388] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000390] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x000003a8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000003b0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000003b8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000003c0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003c8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003d0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003d8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003e0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000400] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000420] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000430] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000440] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000448] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000450] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000458] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000460] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000468] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000470] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000478] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000480] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000488] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000490] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000498] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x000004a0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x000004a8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x000004b0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x000004b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000004c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x000004c8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004d0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x000004d8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x000004e0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x000004e8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x000004f0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x000004f8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000500] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000508] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000510] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000518] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000520] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000528] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000530] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000538] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000540] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x00000548] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000550] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x00000558] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000560] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000568] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000570] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000578] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000580] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000588] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000590] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000598] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x000005a0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000005a8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-// ::mc_filter
-/* [0x000005b0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000005b8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000005c0] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
-/* [0x000005c8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000005d0] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
-/* [0x000005d8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000005e0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
-/* [0x000005e8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000005f0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
-/* [0x000005f8] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
-/* [0x00000600] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
-/* [0x00000608] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000610] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
-/* [0x00000618] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000620] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
-/* [0x00000628] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000630] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000638] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000640] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000648] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000650] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000658] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000660] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000668] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000670] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000678] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000680] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000688] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000690] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000698] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000006a0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006a8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006b0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006b8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000006c0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006c8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006d0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006d8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000006e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000700] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000708] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000710] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000718] */ 0x000001d0, 0xf07809e7, // brr.anynn -, r:fast_path
-/* [0x00000720] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000728] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000730] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000738] */ 0x00000000, 0xe00208e7, // mov r3, 0
-// :loop
-/* [0x00000740] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000748] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000750] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000758] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000760] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
-/* [0x00000768] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000770] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000778] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000780] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000788] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000790] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000798] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x000007a0] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000007a8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000007b0] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000007b8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000007c0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000007c8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000007d0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x000007d8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x000007e0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x000007e8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x000007f0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x000007f8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000800] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000808] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000810] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
-/* [0x00000818] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000820] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000828] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000830] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000838] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000840] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000848] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000850] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000858] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:loop
-/* [0x00000860] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x00000868] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x00000870] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x00000878] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x00000880] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x00000888] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000890] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000898] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x000008a0] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x000008a8] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x000008b0] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x000008b8] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
-/* [0x000008c0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000008c8] */ 0xfffffe58, 0xf06809e7, // brr.anyn -, r:loop
-/* [0x000008d0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
-/* [0x000008d8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000008e0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000008e8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000008f0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000008f8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000900] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-// :fast_path
-/* [0x00000908] */ 0x00000000, 0xe00208e7, // mov r3, 0
-// :fast_loop
-/* [0x00000910] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000918] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000920] */ 0x95727d9b, 0x1004475f, // mov.ifz ra_y, ra_y_next   ; mov rb31, r3
-/* [0x00000928] */ 0x95690dbf, 0x10044623, // mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
-/* [0x00000930] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000938] */ 0x929de5e4, 0x100248a1, // min r2, r2, rb_frame_height_minus_1 ; mov r1, r4
-/* [0x00000940] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000948] */ 0xec414c87, 0x10024e20, // add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
-/* [0x00000950] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000958] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000960] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
-/* [0x00000968] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
-/* [0x00000970] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
-/* [0x00000978] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
-/* [0x00000980] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
-/* [0x00000988] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
-/* [0x00000990] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
-/* [0x00000998] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
-/* [0x000009a0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x000009a8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x000009b0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x000009b8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x000009c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x000009c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000009d0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8       ; mov r1, ra22
-/* [0x000009d8] */ 0xffffff18, 0xf06809e7, // brr.anyn -, r:fast_loop
-/* [0x000009e0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x000009e8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x000009f0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x000009f8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x00000a00] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x00000a08] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000a10] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000a18] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000a20] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000a28] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000a30] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000a38] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
-/* [0x00000a40] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000a48] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:fast_loop
-/* [0x00000a50] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
-/* [0x00000a58] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000a60] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000a68] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000a70] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000a78] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a80] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-// ::mc_filter_b
-/* [0x00000a88] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000a90] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000a98] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
-/* [0x00000aa0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000aa8] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
-/* [0x00000ab0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000ab8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
-/* [0x00000ac0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000ac8] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
-/* [0x00000ad0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
-/* [0x00000ad8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
-/* [0x00000ae0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000ae8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
-/* [0x00000af0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000af8] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
-/* [0x00000b00] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000b08] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000b10] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000b18] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000b20] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000b28] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000b30] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000b38] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000b40] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000b48] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000b50] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000b58] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000b60] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000b68] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000b70] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000b78] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000b80] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
-/* [0x00000b88] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000b90] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000b98] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ba0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ba8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000bb0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000bb8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000bc0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000bc8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000bd0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000bd8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000be0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000be8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000bf0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000bf8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000c00] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000c08] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000c10] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000c18] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000c20] */ 0x00000000, 0xe00208e7, // mov r3, 0
-// :bloop
-/* [0x00000c28] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000c30] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000c38] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000c40] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000c48] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
-/* [0x00000c50] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000c58] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000c60] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000c68] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000c70] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000c78] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000c80] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000c88] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000c90] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000c98] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000ca0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000ca8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000cb0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000cb8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000cc0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000cc8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000cd0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000cd8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000ce0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000ce8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000cf0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000cf8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
-/* [0x00000d00] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000d08] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000d10] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000d18] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000d20] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000d28] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000d30] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000d38] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000d40] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:bloop
-/* [0x00000d48] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x00000d50] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x00000d58] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x00000d60] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x00000d68] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x00000d70] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000d78] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000d80] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000d88] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000d90] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000d98] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000da0] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
-/* [0x00000da8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000db0] */ 0x8fc8f3f6, 0xd0020867, // asr r1, r1, 15          ; mov -, vr_wait
-/* [0x00000db8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000dc0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
-/* [0x00000dc8] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:bloop
-/* [0x00000dd0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x00000dd8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x00000de0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
-/* [0x00000de8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000df0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000df8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000e00] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-// ::mc_filter_honly
-/* [0x00000e08] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000e10] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000e18] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
-/* [0x00000e20] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000e28] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
-/* [0x00000e30] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000e38] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
-/* [0x00000e40] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000e48] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
-/* [0x00000e50] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
-/* [0x00000e58] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
-/* [0x00000e60] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000e68] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
-/* [0x00000e70] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000e78] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
-/* [0x00000e80] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000e88] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000e90] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000e98] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000ea0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000ea8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000eb0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000eb8] */ 0x0c9de1c0, 0xd0021467, // add rb17, r0, -2
-/* [0x00000ec0] */ 0x919c71c0, 0xd0024812, // shl r0, r0, 7 ; mov rb18,r0
-/* [0x00000ec8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000ed0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000ed8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000ee0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000ee8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ef0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ef8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f00] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000f08] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f10] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f18] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f20] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000f28] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000f30] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000f38] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000f40] */ 0x00000000, 0xe00208e7, // mov r3, 0
-// :loop_honly
-/* [0x00000f48] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000f50] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000f58] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000f60] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000f68] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
-/* [0x00000f70] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000f78] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000f80] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000f88] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000f90] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000f98] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000fa0] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000fa8] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000fb0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000fb8] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000fc0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000fc8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000fd0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000fd8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000fe0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000fe8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000ff0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000ff8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00001000] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00001008] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00001010] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00001018] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
-/* [0x00001020] */ 0x8d5927f6, 0x100269e1, // sub.setf -, r3, rb18 ; mov r1, ra22
-/* [0x00001028] */ 0x559f2fc1, 0x100049e0, // mov -, vw_wait   ; mul24 r0, r0, r1
-/* [0x00001030] */ 0xfffffef8, 0xf06809e7, // brr.anyn -, r:loop_honly
-/* [0x00001038] */ 0x0f9cf1c0, 0xd0020827, // asr r0, r0, 15
-/* [0x00001040] */ 0x129d61c0, 0x10020827, // min r0, r0, rb22
-/* [0x00001048] */ 0x139c01c0, 0xd0020c27, // max vpm, r0, 0
-/* [0x00001050] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001058] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00001060] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00001068] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-// ::mc_exit
-/* [0x00001070] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00001078] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00001080] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001088] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001090] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001098] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000010a0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000010a8] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x000010b0] */ 0x009e7000, 0x100009e7, // nop        ; nop
-// ::mc_exit1
-/* [0x000010b8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x000010c0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000010c8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000010d0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000010d8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000010e0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000010e8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x000010f0] */ 0x009e7000, 0x100009e7, // nop        ; nop
-// ::mc_interrupt_exit
-/* [0x000010f8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00001100] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001108] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001110] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001118] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001120] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001128] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001130] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001138] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001140] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001148] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001150] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001158] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001160] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001168] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001170] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001178] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00001180] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00001188] */ 0x009e7000, 0x100009e7, // nop        ; nop
-// ::mc_interrupt_exit4
-/* [0x00001190] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00001198] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000011a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000011a8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000011b0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000011b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000011c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000011c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000011d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000011d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x000011e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
-// ::mc_interrupt_exit8
-/* [0x000011e8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x000011f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000011f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001200] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001208] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001210] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001218] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001220] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001228] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001230] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001238] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001240] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001248] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00001250] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00001258] */ 0x009e7000, 0x100009e7, // nop        ; nop
-// ::mc_setup_uv
-/* [0x00001260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00001268] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
-/* [0x00001270] */ 0x15827d80, 0x10020767, // mov ra_y, unif
-/* [0x00001278] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
-/* [0x00001280] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00001288] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
-/* [0x00001290] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
-/* [0x00001298] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
-/* [0x000012a0] */ 0x15827d80, 0x10021427, // mov rb16, unif
-/* [0x000012a8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000012b0] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
-/* [0x000012b8] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
-/* [0x000012c0] */ 0x00000001, 0xe0020527, // mov ra20, 1
-/* [0x000012c8] */ 0x00000020, 0xe0020567, // mov ra21, 32
-/* [0x000012d0] */ 0x00000100, 0xe00205a7, // mov ra22, 256
-/* [0x000012d8] */ 0x00000008, 0xe00205e7, // mov ra23, 8
-/* [0x000012e0] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
-/* [0x000012e8] */ 0x00000040, 0xe0021567, // mov rb21, 64
-/* [0x000012f0] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
-/* [0x000012f8] */ 0x00000018, 0xe00215e7, // mov rb23, 24
-/* [0x00001300] */ 0x00000000, 0xe0020227, // mov ra8, 0
-/* [0x00001308] */ 0x00000000, 0xe0020267, // mov ra9, 0
-/* [0x00001310] */ 0x00000000, 0xe00202a7, // mov ra10, 0
-/* [0x00001318] */ 0x00000000, 0xe00202e7, // mov ra11, 0
-/* [0x00001320] */ 0x00000000, 0xe0020327, // mov ra12, 0
-/* [0x00001328] */ 0x00000000, 0xe0020367, // mov ra13, 0
-/* [0x00001330] */ 0x00000000, 0xe00203a7, // mov ra14, 0
-/* [0x00001338] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x00001340] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00001348] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00001350] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00001358] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00001360] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00001368] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00001370] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00001378] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00001380] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
-/* [0x00001388] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
-/* [0x00001390] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00001398] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x000013a0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x000013a8] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x000013b0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x000013b8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x000013c0] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x000013c8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x000013d0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000013d8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x000013e0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x000013e8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
-/* [0x000013f0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
-/* [0x000013f8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
-/* [0x00001400] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-/* [0x00001408] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x00001410] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00001418] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00001420] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
-/* [0x00001428] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00001430] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-/* [0x00001438] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
-/* [0x00001440] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x00001448] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001450] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001458] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001460] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00001468] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00001470] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00001478] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001480] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00001488] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
-/* [0x00001490] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+/* [0x00000398] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000003a0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000003a8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000003b0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003b8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003c0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003c8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003d0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003d8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000003e0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000003e8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003f0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000003f8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000400] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000408] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000410] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000418] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000420] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000428] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000430] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000438] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000440] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000448] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000450] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000458] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000460] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000468] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000470] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000478] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000480] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000488] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000490] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000498] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x000004a0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x000004a8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000004b0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x000004b8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000004c0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x000004c8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x000004d0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x000004d8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x000004e0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x000004e8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x000004f0] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x000004f8] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000500] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000508] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000510] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000518] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000520] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000528] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000530] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x00000538] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000540] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000560] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000568] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000570] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000578] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000580] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000588] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000590] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000598] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b
-/* [0x00001498] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000014a0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000014a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000014b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000014b8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000014c0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000014c8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000014d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000014d8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000014e0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000014e8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000014f0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000014f8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00001500] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001508] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00001510] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00001518] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00001520] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00001528] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00001530] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00001538] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00001540] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00001548] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00001550] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00001558] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00001560] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00001568] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
-/* [0x00001570] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00001578] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001580] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001588] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001590] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001598] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000015a0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000015a8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000015b0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000015b8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000015c0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015c8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015d0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000015d8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000015e0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015e8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015f0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000015f8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00001600] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00001608] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00001610] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000005a0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000005a8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000005b0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000005b8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000005c0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000005c8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000005d0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000005d8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000005e0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000005e8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000005f0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000005f8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000600] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000608] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000610] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000618] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000620] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000628] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000630] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000638] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000640] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000648] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000650] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000658] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000660] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000668] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000670] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+/* [0x00000678] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000680] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000688] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000690] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000698] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000006a8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006b0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006b8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006c0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000006c8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006d0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006d8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006e0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000006e8] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006f0] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006f8] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000700] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000708] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000710] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000718] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x00001618] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00001620] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00001628] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00001630] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00001638] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00001640] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00001648] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00001650] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00001658] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00001660] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00001668] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00001670] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00001678] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
-/* [0x00001680] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00001688] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00001690] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00001698] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000016a0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000016a8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000016b0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x000016b8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x000016c0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x000016c8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x000016d0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x000016d8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x000016e0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x000016e8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x000016f0] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
-/* [0x000016f8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00001700] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00001708] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00001710] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00001718] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00001720] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00001728] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00001730] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00001738] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00001740] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x00001748] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x00001750] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x00001758] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x00001760] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x00001768] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00001770] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00001778] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00001780] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00001788] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00001790] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00001798] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
-/* [0x000017a0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000017a8] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
-/* [0x000017b0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000017b8] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
-/* [0x000017c0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000017c8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x000017d0] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x000017d8] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
-/* [0x000017e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000017e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000017f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000017f8] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00001800] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00001808] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001810] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00001818] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00001820] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000720] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000728] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000730] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000738] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000740] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000748] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000750] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000758] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000760] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000768] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000770] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000778] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+/* [0x00000780] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+/* [0x00000788] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000790] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000798] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000007a0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000007a8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000007b0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000007b8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x000007c0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x000007c8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x000007d0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x000007d8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x000007e0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x000007e8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x000007f0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x000007f8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x00000800] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000808] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000810] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000818] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000820] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000828] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000830] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000838] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000848] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+/* [0x00000850] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+/* [0x00000858] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+/* [0x00000860] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+/* [0x00000868] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+/* [0x00000870] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000878] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000880] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000888] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000890] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000898] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x000008a0] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x000008a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000008b0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x000008b8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000008c0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+/* [0x000008c8] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000008d0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x000008d8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x000008e0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+/* [0x000008e8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000008f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000008f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000900] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000908] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000910] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000918] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000920] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000928] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_exit
+/* [0x00000930] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000938] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000940] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000948] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000950] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000958] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000960] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000968] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000970] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_interrupt_exit8
+/* [0x00000978] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000980] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000988] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000990] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000998] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000009a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009d0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009d8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000009e0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000009e8] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 3464cdb..9de4535 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -3,18 +3,11 @@
 
 extern unsigned int rpi_shader[];
 
-#define mc_setup (rpi_shader + 0)
-#define mc_filter_uv (rpi_shader + 146)
-#define mc_filter (rpi_shader + 364)
-#define mc_filter_b (rpi_shader + 674)
-#define mc_filter_honly (rpi_shader + 898)
-#define mc_exit (rpi_shader + 1052)
-#define mc_exit1 (rpi_shader + 1070)
-#define mc_interrupt_exit (rpi_shader + 1086)
-#define mc_interrupt_exit4 (rpi_shader + 1124)
-#define mc_interrupt_exit8 (rpi_shader + 1146)
-#define mc_setup_uv (rpi_shader + 1176)
-#define mc_filter_uv_b (rpi_shader + 1318)
-#define mc_end (rpi_shader + 1546)
+#define mc_setup_uv (rpi_shader + 0)
+#define mc_filter_uv (rpi_shader + 142)
+#define mc_filter_uv_b (rpi_shader + 360)
+#define mc_exit (rpi_shader + 588)
+#define mc_interrupt_exit8 (rpi_shader + 606)
+#define mc_end (rpi_shader + 636)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index e28f54e..7f08c25 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -71,8 +71,10 @@
 
 .set rb_const_64,                  rb21
 
-# mc_setup(next_kernel, x, y, ref_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1)
-::mc_setup
+
+################################################################################
+# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
+::mc_setup_uv
 
 # Read starting kernel
 mov ra31, unif
@@ -80,7 +82,9 @@ mov ra31, unif
 # Load first request location
 add ra_x_base, unif, elem_num # Store x
 mov ra_y, unif # Store y
-mov ra_x2_base, unif # Store frame base
+mov ra_x2_base, unif # Store frame u base
+nop
+sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
 
 # Read image dimensions
 sub rb25,unif,1
@@ -143,29 +147,24 @@ mov r1, vpm_setup(0, 4, h8p(0, 0))
 add rb28, r0, r1 
 
 # Compute base address for first and second access
-#add r0, unif, elem_num     # x
 mov r0, ra_x_base           # Load x
-add r2, r0, 8               # x+8
 max r0, r0, 0; mov r1, ra_y # Load y
 min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
-shl ra_xshift_next, r0, 3
-max r2, r2, 0
+shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
 add ra_y, r1, 1
-min r2, r2, rb_frame_width_minus_1
-shl ra_x2shift_next, r2, 3
-max r1, r1, 0  # y
-min r1, r1, rb_frame_height_minus_1
-add r0, r0, r3; mul24 r1, r1, rb_pitch
-add r2, r2, r3
+add r0, r0, r3
 and r0, r0, ~3
-and r2, r2, ~3; mov ra_x_base, r0
+max r1, r1, 0 ; mov ra_x_base, r0 # y
+min r1, r1, rb_frame_height_minus_1
 # submit texture requests for first line
+add r2, r2, r0 ; mul24 r1, r1, rb_pitch
 add t0s, r0, r1 ; mov ra_x2_base, r2
 add t0s, r2, r1
 
 # Dump padding words
 mov r0, unif
 mov r0, unif
+mov r0, unif
 
 # submit texture requests for second line
 max r1, ra_y, 0
@@ -176,6 +175,8 @@ nop ; mul24 r1, r1, rb_pitch
 add t0s, r1, ra_x_base
 add t0s, r1, ra_x2_base
 
+
+
 ################################################################################
 
 # mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
@@ -341,35 +342,26 @@ add vw_setup, rb26, r0 # VDW setup 0
 mov vw_setup, rb29 # Stride
 mov vw_addr, unif # start the VDW
 
-################################################################################
-
 
-# mc_filter(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+################################################################################
 
-# At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
-::mc_filter
+::mc_filter_uv_b
 mov ra31, unif
 
 # per-channel shifts were calculated on the *previous* invocation
 
 mov ra_xshift, ra_xshift_next
-mov ra_x2shift, ra_x2shift_next
 
 # get base addresses and per-channel shifts for *next* invocation
 add r0, unif, elem_num    # x
-add r2, r0, 8 # x+8
 max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
 shl ra_xshift_next, r0, 3
-max r2, r2, 0
-min r2, r2, rb_frame_width_minus_1
-shl ra_x2shift_next, r2, 3
+sub r2, unif, r3 # compute offset from frame base u to frame base v
 add r0, r0, r3
-add r2, r2, r3
 and rb_x_base_next, r0, ~3 
-and ra_x2_base_next, r2, ~3
 mov ra_y_next, r1
+add ra_x2_base_next, rb_x_base_next, r2
 
 # set up VPM write
 mov vw_setup, rb28
@@ -383,10 +375,20 @@ and r0, r0, rb22 # Extract height
 add rb17, r0, 5
 add rb18, r0, 7
 shl r0, r0, 7
+
+# r0 is currently height<<7
+# For vr_setup we want height<<20 (so 20-7=13 additional bits)
+shl r3, r0, 13 
+shl r3, r3, 8 # Mask off top 8 bits
+shr r3, r3, 8
+
 add r0, r0, r1 # Combine width and height of destination area
 shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
 add rb26, r0, rb27
 
+# In a B frame, so also set up VPM read
+add vr_setup, r3, rb28
+
 sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
 
 # get filter coefficients
@@ -407,126 +409,20 @@ asr rb8, r0, rb23;      mov r0, unif
 asr rb15, r0, rb23;     mul24 r0, r0, ra22
 asr rb14, r0, rb23;     mul24 r0, r0, ra22
 asr rb13, r0, rb23;     mul24 r0, r0, ra22
-brr.anynn -, r:fast_path
-asr rb12, r0, rb23  # delay slot 1
+asr rb12, r0, rb23  
 
 # r2 is elem_num
 # r3 is loop counter
 
-mov r5rep, -8 # delay slot 2
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 
 # retrieve texture results and pick out bytes
 # then submit two more texture requests
 
-## nop                                                                 ; ldtmu0     # loop counter increment
-## shr r0, r4, ra17                                                    ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21         ; mul24 r3, r0, ra0
-## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15                  
-## sub r2, r2, r3                                                    ; ldtmu0
-## 
-## mov r0, ra22
-## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # apply horizontal filter
-## 
-## asr r2, r2, 15    ; mul24 r3, r0, ra0
-## min r2, r2, rb22
-## max ra13, r2, 0
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21         
-## sub r2, r2, r3 ; mul24      r3, ra1 << 1, r0 << 1
-## nop            ; mul24.ifnz r3, ra1 << 9, r1 << 9
-## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
-## nop            ; mul24.ifnz r3, ra2 << 10, r1 << 10
-## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
-## nop            ; mul24.ifnz r3, ra3 << 11, r1 << 11
-## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
-## nop            ; mul24.ifnz r3, ra4 << 12, r1 << 12
-## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
-## nop            ; mul24.ifnz r3, ra5 << 13, r1 << 13
-## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
-## nop            ; mul24.ifnz r3, ra6 << 14, r1 << 14
-## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
-## nop            ; mul24.ifnz r3, ra7 << 15, r1 << 15
-## sub r0, r2, r3
-## 
-## # apply horizontal filter
-## 
-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
-## asr r0, r0, 15
-## min r0, r0, rb22
-## max ra14, r0, 0
-## 
-## 
-## 
-## 
-## nop                                                                 ; ldtmu0     # loop counter increment
-## shr r0, r4, ra17                                                    ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21         ; mul24 r3, r0, ra0
-## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-## sub r0, r2, r3
-## 
-## # apply horizontal filter
-## 
-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
-## asr r0, r0, 15
-## min r0, r0, rb22
-## max ra15, r0, 0
-
-
-
-
 mov r3, 0
 
-:loop
+:uvloop_b
 # retrieve texture results and pick out bytes
 # then submit two more texture requests
 
@@ -534,7 +430,7 @@ sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
 shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
 mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
 mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
 
 max r2, ra_y, 0  # y
 min r2, r2, rb_frame_height_minus_1
@@ -548,6 +444,7 @@ add t0s, ra_x2_base, r2
 mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 
 mov r2, rb21         ; mul24 r3, r0, ra0
+nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
 sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
 nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
 sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
@@ -576,7 +473,7 @@ mov ra13, ra14
 sub.setf -, r3, 8 ; mov r1, ra22
 
 # apply horizontal filter         
-brr.anyn -, r:loop
+brr.anyn -, r:uvloop_b
 max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
 asr r0, r0, 15          ; mov r1, ra21
 min.setf ra15, r0, rb22
@@ -593,823 +490,70 @@ sub r1, r1, r0          ; mul24 r0, ra8, rb8
 sub r1, r1, r0          ; mul24 r0, ra15, rb15
 sub.ifnn r1, r1, r0     ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-brr.anyn -, r:loop 
 asr r1, r1, 15          
 min r1, r1, rb22        
-max vpm, r1, 0
-
-# DMA out
-
-bra -, ra31
-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
-mov vw_setup, rb29
-mov vw_addr, unif # start the VDW
-
-####################################################
-
-:fast_path
-## nop                                                                 ; ldtmu0     # loop counter increment
-## shr r0, r4, ra17                                                    ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21         ; mul24 r3, r0, ra0
-## sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
-## sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
-## sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
-## sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
-## sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
-## sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
-## sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
-## sub r2, r2, r3                                                    ; ldtmu0
-## 
-## mov r0, ra22
-## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # apply horizontal filter
-## 
-## asr r2, r2, 15    ; mul24 r3, r0, ra0
-## min r2, r2, rb22
-## max ra13, r2, 0
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21         
-## sub r2, r2, r3 ; mul24    r3, ra1 << 1, r0 << 1
-## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
-## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
-## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
-## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
-## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
-## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
-## sub r0, r2, r3
-## 
-## # apply horizontal filter
-## 
-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
-## asr r0, r0, 15
-## min r0, r0, rb22
-## max ra14, r0, 0
-## 
-## 
-## 
-## 
-## nop                                                                 ; ldtmu0     # loop counter increment
-## shr r0, r4, ra17                                                    ; ldtmu0         
-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
-## add ra16, ra16, rb16 ; mov t0s, ra16
-## 
-## # generate seven shifted versions
-## # interleave with scroll of vertical context
-## 
-## mov r2, rb21   ; mul24    r3, r0, ra0
-## sub r2, r2, r3 ; mul24    r3, ra1 << 1, r0 << 1
-## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
-## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
-## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
-## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
-## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
-## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
-## sub r0, r2, r3
-## 
-## # apply horizontal filter
-## 
-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
-## asr r0, r0, 15
-## min r0, r0, rb22
-## max ra15, r0, 0
-
-
-mov r3, 0  # This signifies the amount of unrolling
-
-:fast_loop
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-# Due to pipelining we can only skip second pipeline instructions related to the fetched pixels
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_y, ra_y_next   ; mov rb31, r3
-mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch   
-
-max r2, ra_y, 0           
-min r2, r2, rb_frame_height_minus_1 ; mov r1, r4  # discard texture read
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20                                     
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
-
-mov r2, rb21         ; mul24 r3, r0, ra0
-sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
-sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
-sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
-sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
-sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
-sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
-sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
-sub r0, r2, r3       ; mov r3, rb31
-
-mov ra8, ra9         
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-mov ra13, ra14
+add r0, vpm, 1          # Blend in previous VPM contents at this location
+brr.anyn -, r:uvloop_b
+max r1, r1, 0
+add r1, r1, r0
+shr vpm, r1, 1
 
-sub.setf -, r3, 8       ; mov r1, ra22
 
-# apply horizontal filter                   
-                    
-brr.anyn -, r:fast_loop
-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 15          ; mov r1, ra21
-min.setf ra15, r0, rb22
- 
-# apply vertical filter and write to VPM
+# DMA out for U
 
-nop                     ; mul24 r0, ra14, rb14
-sub r1, r1, r0          ; mul24 r0, ra13, rb13
-sub r1, r1, r0          ; mul24 r0, ra12, rb12
-sub r1, r1, r0          ; mul24 r0, ra11, rb11
-sub r1, r1, r0          ; mul24 r0, ra10, rb10
-sub r1, r1, r0          ; mul24 r0, ra9, rb9
-sub r1, r1, r0          ; mul24 r0, ra8, rb8
-sub r1, r1, r0          ; mul24 r0, ra15, rb15
-sub.ifnn r1, r1, r0     ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-brr.anyn -, r:fast_loop 
-asr r1, r1, 15          
-min r1, r1, rb22        
-max vpm, r1, 0
+mov vw_setup, rb26 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
 
-# DMA out
+# DMA out for V
+# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+# Could potentially push this write into the start of the next pipeline stage.
+mov r0, 16
+mov -, vw_wait
 
 bra -, ra31
-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
-mov vw_setup, rb29
+add vw_setup, rb26, r0 # VDW setup 0
+mov vw_setup, rb29 # Stride
 mov vw_addr, unif # start the VDW
 
 ################################################################################
 
-# mc_filter_b(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
-
-# At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
-::mc_filter_b
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-mov ra_x2shift, ra_x2shift_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num    # x
-add r2, r0, 8 # x+8
-max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
-shl ra_xshift_next, r0, 3
-max r2, r2, 0
-min r2, r2, rb_frame_width_minus_1
-shl ra_x2shift_next, r2, 3
-add r0, r0, r3
-add r2, r2, r3
-and rb_x_base_next, r0, ~3 
-and ra_x2_base_next, r2, ~3
-mov ra_y_next, r1
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
-shl r0, r0, 7
-# r0 is currently height<<7
-# For vr_setup we want height<<20 (so 20-7=13 additional bits)
-shl r3, r0, 13 
-shl r3, r3, 8 # Mask off top 8 bits
-shr r3, r3, 8
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-# In a B frame, so also set up VPM read
-add vr_setup, r3, rb28
-
-# get filter coefficients
-
-mov r0, unif
-asr ra3, r0, rb23;      mul24 r0, r0, ra22
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-asr rb11, r0, rb23;     mul24 r0, r0, ra22
-asr rb10, r0, rb23;     mul24 r0, r0, ra22
-asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-asr rb12, r0, rb23
-
-# r2 is elem_num
-# r3 is loop counter
-
-mov r5rep, -8 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  
-mov r3, 0
-
-:bloop
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
+# mc_exit()
 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+::mc_exit
+mov  -, vw_wait # wait on the VDW
 
-mov r2, rb21         ; mul24 r3, r0, ra0
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3
+mov -,srel(0)
 
-mov r3, rb31
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
 
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-mov ra13, ra14
+nop        ; nop ; thrend
+nop        ; nop # delay slot 1
+nop        ; nop # delay slot 2
 
-sub.setf -, r3, 8 ; mov r1, ra22
+# mc_interrupt_exit8()
+::mc_interrupt_exit8 
+mov  -, vw_wait # wait on the VDW
 
-# apply horizontal filter         
-brr.anyn -, r:bloop
-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 15          ; mov r1, ra21
-min.setf ra15, r0, rb22
- 
-# apply vertical filter and write to VPM
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
 
-nop                     ; mul24 r0, ra14, rb14
-sub r1, r1, r0          ; mul24 r0, ra13, rb13
-sub r1, r1, r0          ; mul24 r0, ra12, rb12
-sub r1, r1, r0          ; mul24 r0, ra11, rb11
-sub r1, r1, r0          ; mul24 r0, ra10, rb10
-sub r1, r1, r0          ; mul24 r0, ra9, rb9
-sub r1, r1, r0          ; mul24 r0, ra8, rb8
-sub r1, r1, r0          ; mul24 r0, ra15, rb15
-sub.ifnn r1, r1, r0     ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 15          ; mov -, vr_wait         
-min r1, r1, rb22        
-add r0, vpm, 1          # Blend in previous VPM contents at this location
-brr.anyn -, r:bloop 
-max r1, r1, 0
-add r1, r1, r0
-shr vpm, r1, 1
-
-# DMA out
-
-bra -, ra31
-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
-mov vw_setup, rb29
-mov vw_addr, unif # start the VDW
-
-################################################################################
-
-# mc_filter_honly(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
-# This filter only does horizontal filtering.
-# It is assumed that the region to fetch does not include extra rows above.
-
-# At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
-::mc_filter_honly
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-mov ra_x2shift, ra_x2shift_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num    # x
-add r2, r0, 8 # x+8
-max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
-shl ra_xshift_next, r0, 3
-max r2, r2, 0
-min r2, r2, rb_frame_width_minus_1
-shl ra_x2shift_next, r2, 3
-add r0, r0, r3
-add r2, r2, r3
-and rb_x_base_next, r0, ~3 
-and ra_x2_base_next, r2, ~3
-mov ra_y_next, r1
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, -2 # Pipelining means we move data across 2 iterations early
-shl r0, r0, 7 ; mov rb18,r0
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-
-# get filter coefficients
-
-mov r0, unif
-asr ra3, r0, rb23;      mul24 r0, r0, ra22
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-mov r0, unif
-
-# r2 is elem_num
-# r3 is loop counter
-mov r5rep, -8 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
-mov r3, 0
-
-:loop_honly
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-mov r2, rb21         ; mul24 r3, r0, ra0
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3       ; mov r3, rb31
-
-sub.setf -, r3, rb18 ; mov r1, ra22
-
-mov -, vw_wait   ; mul24 r0, r0, r1  
-brr.anyn -, r:loop_honly     
-asr r0, r0, 15          # delay 1     
-min r0, r0, rb22        # delay 2
-max vpm, r0, 0          # delay 3
- 
-# DMA out
-bra -, ra31
-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
-mov vw_setup, rb29
-mov vw_addr, unif # start the VDW
-
-
-################################################################################
-
-# mc_exit()
-
-::mc_exit
-mov  -, vw_wait # wait on the VDW
-
-mov -,srel(0)
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-nop        ; nop ; thrend
-nop        ; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-::mc_exit1 
-mov  -, vw_wait # wait on the VDW
-
-#mov -,srel(1)
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
+mov -,sacq(0) # 1 
+mov -,sacq(0) # 2 
+mov -,sacq(0) # 3 
+mov -,sacq(0) # 4 
+mov -,sacq(0) # 5 
+mov -,sacq(0) # 6 
+mov -,sacq(0) # 7 
 
 nop        ; nop ; thrend
 mov interrupt, 1; nop # delay slot 1
 nop        ; nop # delay slot 2
 
-# mc_interrupt_exit()
-::mc_interrupt_exit 
-mov  -, vw_wait # wait on the VDW
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-mov -,sacq(0) # 1 
-mov -,sacq(0) # 2 
-mov -,sacq(0) # 3 
-mov -,sacq(0) # 4 
-mov -,sacq(0) # 5 
-mov -,sacq(0) # 6 
-mov -,sacq(0) # 7 
-mov -,sacq(0) # 8 
-mov -,sacq(0) # 9 
-mov -,sacq(0) # 10
-mov -,sacq(0) # 11
-
-nop        ; nop ; thrend
-mov interrupt, 1; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-# mc_interrupt_exit4()
-::mc_interrupt_exit4 
-mov  -, vw_wait # wait on the VDW
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-mov -,sacq(0) # 1 
-mov -,sacq(0) # 2 
-mov -,sacq(0) # 3 
-
-nop        ; nop ; thrend
-mov interrupt, 1; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-# mc_interrupt_exit8()
-::mc_interrupt_exit8 
-mov  -, vw_wait # wait on the VDW
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-mov -,sacq(0) # 1 
-mov -,sacq(0) # 2 
-mov -,sacq(0) # 3 
-mov -,sacq(0) # 4 
-mov -,sacq(0) # 5 
-mov -,sacq(0) # 6 
-mov -,sacq(0) # 7 
-
-nop        ; nop ; thrend
-mov interrupt, 1; nop # delay slot 1
-nop        ; nop # delay slot 2
-
-################################################################################
-# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
-::mc_setup_uv
-
-# Read starting kernel
-mov ra31, unif
-
-# Load first request location
-add ra_x_base, unif, elem_num # Store x
-mov ra_y, unif # Store y
-mov ra_x2_base, unif # Store frame u base
-nop
-sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
-
-# Read image dimensions
-sub rb25,unif,1
-sub rb30,unif,1
-
-# get source pitch
-mov rb16, unif
-
-# get destination pitch
-mov r0, unif
-mov r1, vdw_setup_1(0)
-add rb24, r1, r0
-
-# load constants
-
-mov ra20, 1
-mov ra21, 32
-mov ra22, 256
-mov ra23, 8
-
-mov rb20, 0xffffff00
-mov rb21, 64
-mov rb22, 255
-mov rb23, 24
-
-# touch vertical context to keep simulator happy
-
-mov ra8, 0
-mov ra9, 0
-mov ra10, 0    
-mov ra11, 0
-mov ra12, 0    
-mov ra13, 0
-mov ra14, 0    
-mov ra15, 0
-
-# Compute part of VPM to use for DMA output
-mov r2, qpu_num
-and r2, r2, 15
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
-shl r0, r0, 5
-add rb27, r0, r1
-
-# Compute part of VPM to save data into
-mov r2, qpu_num
-and r2, r2, 15
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vpm_setup(0, 4, h8p(0, 0))
-add rb28, r0, r1 
-
-# Compute base address for first and second access
-mov r0, ra_x_base           # Load x
-max r0, r0, 0; mov r1, ra_y # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
-shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-add ra_y, r1, 1
-add r0, r0, r3
-and r0, r0, ~3
-max r1, r1, 0 ; mov ra_x_base, r0 # y
-min r1, r1, rb_frame_height_minus_1
-# submit texture requests for first line
-add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-add t0s, r0, r1 ; mov ra_x2_base, r2
-add t0s, r2, r1
-
-# Dump padding words
-mov r0, unif
-mov r0, unif
-mov r0, unif
-
-# submit texture requests for second line
-max r1, ra_y, 0
-min r1, r1, rb_frame_height_minus_1
-add ra_y, ra_y, 1
-bra -, ra31
-nop ; mul24 r1, r1, rb_pitch
-add t0s, r1, ra_x_base
-add t0s, r1, ra_x2_base
-
-
-
-################################################################################
-
-::mc_filter_uv_b
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num    # x
-max r0, r0, 0; mov r1, unif # y
-min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
-shl ra_xshift_next, r0, 3
-sub r2, unif, r3 # compute offset from frame base u to frame base v
-add r0, r0, r3
-and rb_x_base_next, r0, ~3 
-mov ra_y_next, r1
-add ra_x2_base_next, rb_x_base_next, r2
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
-shl r0, r0, 7
-
-# r0 is currently height<<7
-# For vr_setup we want height<<20 (so 20-7=13 additional bits)
-shl r3, r0, 13 
-shl r3, r3, 8 # Mask off top 8 bits
-shr r3, r3, 8
-
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-
-# In a B frame, so also set up VPM read
-add vr_setup, r3, rb28
-
-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
-
-# get filter coefficients
-
-mov r0, unif
-asr ra3, r0, rb23;      mul24 r0, r0, ra22
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-asr rb11, r0, rb23;     mul24 r0, r0, ra22
-asr rb10, r0, rb23;     mul24 r0, r0, ra22
-asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-asr rb12, r0, rb23  
-
-# r2 is elem_num
-# r3 is loop counter
-
-mov r5rep, -8 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-mov r3, 0
-
-:uvloop_b
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
-
-# generate seven shifted versions
-# interleave with scroll of vertical context
-
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-
-mov r2, rb21         ; mul24 r3, r0, ra0
-nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3
-
-mov r3, rb31
-
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-mov ra13, ra14
-
-sub.setf -, r3, 8 ; mov r1, ra22
-
-# apply horizontal filter         
-brr.anyn -, r:uvloop_b
-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 15          ; mov r1, ra21
-min.setf ra15, r0, rb22
- 
-# apply vertical filter and write to VPM
-
-nop                     ; mul24 r0, ra14, rb14
-sub r1, r1, r0          ; mul24 r0, ra13, rb13
-sub r1, r1, r0          ; mul24 r0, ra12, rb12
-sub r1, r1, r0          ; mul24 r0, ra11, rb11
-sub r1, r1, r0          ; mul24 r0, ra10, rb10
-sub r1, r1, r0          ; mul24 r0, ra9, rb9
-sub r1, r1, r0          ; mul24 r0, ra8, rb8
-sub r1, r1, r0          ; mul24 r0, ra15, rb15
-sub.ifnn r1, r1, r0     ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 15          
-min r1, r1, rb22        
-add r0, vpm, 1          # Blend in previous VPM contents at this location
-brr.anyn -, r:uvloop_b
-max r1, r1, 0
-add r1, r1, r0
-shr vpm, r1, 1
-
-
-# DMA out for U
-
-mov vw_setup, rb26 # VDW setup 0
-mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW
-
-# DMA out for V
-# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
-# Could potentially push this write into the start of the next pipeline stage.
-mov r0, 16
-mov -, vw_wait
-
-bra -, ra31
-add vw_setup, rb26, r0 # VDW setup 0
-mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW
-
 ::mc_end
+# Do not add code here because mc_end must appear after all other code.
-- 
1.9.1


From 5d5012ac639e311451107eec8a065d9f061962ee Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 13 May 2015 14:54:25 +0100
Subject: [PATCH 21/77] Moved chroma P1 to QPUs

---
 libavcodec/hevc.c | 38 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index f34c4f9..8ded17f 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2034,6 +2034,44 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                     s->sh.luma_offset_l1[current_mv.ref_idx[1]]);
 
         if (s->sps->chroma_format_idc) {
+#ifdef RPI_INTER_QPU
+            if (s->enable_rpi) {
+                int reflist = 1;
+                int hshift           = s->sps->hshift[1];
+                int vshift           = s->sps->vshift[1];
+                const Mv *mv         = &current_mv.mv[reflist];
+                intptr_t mx          = av_mod_uintp2(mv->x, 2 + hshift);
+                intptr_t my          = av_mod_uintp2(mv->y, 2 + vshift);
+                intptr_t _mx         = mx << (1 - hshift);
+                intptr_t _my         = my << (1 - vshift); // Fractional part of motion vector 
+
+                int x1_c = x0_c + (mv->x >> (2 + hshift));
+                int y1_c = y0_c + (mv->y >> (2 + hshift));
+                //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+                int chan = x0>>8;
+                
+                uint32_t *u = s->u_mvs[chan & 7];      
+                for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
+                  for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
+                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                      *u++ = rpi_filter_coefs[_mx][0];
+                      *u++ = rpi_filter_coefs[_mx][1];
+                      *u++ = rpi_filter_coefs[_my][0];
+                      *u++ = rpi_filter_coefs[_my][1];
+                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                    }
+                }
+                s->u_mvs[chan & 7] = u;
+                return;
+            }
+#endif
             RPI_REDIRECT(chroma_mc_uni)(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],
                           1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);
-- 
1.9.1


From ec4252c14ee6901de9fff97fce48b7601834bd6e Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 13 May 2015 15:13:47 +0100
Subject: [PATCH 22/77] Added B prediction - not quite right

---
 libavcodec/hevc.c          |  58 ++++++++++++++++++++++++
 libavcodec/rpi_shader.c    | 108 +++++++++++++++++++++++----------------------
 libavcodec/rpi_shader.h    |   6 +--
 libavcodec/rpi_shader.qasm |  48 ++++++++++----------
 4 files changed, 141 insertions(+), 79 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 8ded17f..8358707 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2091,6 +2091,64 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                    ref1->frame, &current_mv.mv[1], &current_mv);
 
         if (s->sps->chroma_format_idc) {
+#ifdef RPI_INTER_QPU
+            if (s->enable_rpi) {
+                int hshift           = s->sps->hshift[1];
+                int vshift           = s->sps->vshift[1];
+                const Mv *mv         = &current_mv.mv[0];
+                intptr_t mx          = av_mod_uintp2(mv->x, 2 + hshift);
+                intptr_t my          = av_mod_uintp2(mv->y, 2 + vshift);
+                intptr_t _mx         = mx << (1 - hshift);
+                intptr_t _my         = my << (1 - vshift); // Fractional part of motion vector 
+                int x1_c = x0_c + (mv->x >> (2 + hshift));
+                int y1_c = y0_c + (mv->y >> (2 + hshift));
+                
+                const Mv *mv2         = &current_mv.mv[1];
+                intptr_t mx2          = av_mod_uintp2(mv2->x, 2 + hshift);
+                intptr_t my2          = av_mod_uintp2(mv2->y, 2 + vshift);
+                intptr_t _mx2         = mx2 << (1 - hshift);
+                intptr_t _my2         = my2 << (1 - vshift); // Fractional part of motion vector 
+
+                int x2_c = x0_c + (mv2->x >> (2 + hshift));
+                int y2_c = y0_c + (mv2->y >> (2 + hshift));
+                
+                int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+
+                uint32_t *u = s->u_mvs[chan & 7];      
+                for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
+                  for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);  
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
+                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                      *u++ = rpi_filter_coefs[_mx][0];
+                      *u++ = rpi_filter_coefs[_mx][1];
+                      *u++ = rpi_filter_coefs[_my][0];
+                      *u++ = rpi_filter_coefs[_my][1];
+                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]); // TODO this will become unused once we have a dedicated pass0 filter
+                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                      
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 3 + start_x;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 3 + start_y;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
+                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                      *u++ = rpi_filter_coefs[_mx2][0];
+                      *u++ = rpi_filter_coefs[_mx2][1];
+                      *u++ = rpi_filter_coefs[_my2][0];
+                      *u++ = rpi_filter_coefs[_my2][1];
+                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                    }
+                }
+                s->u_mvs[chan & 7] = u;
+                return;
+            }
+#endif
             RPI_REDIRECT(chroma_mc_bi)(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,
                          x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);
 
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 170e8ac..5d00cb2 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -265,23 +265,23 @@ unsigned int rpi_shader[] = {
 /* [0x00000760] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
 /* [0x00000768] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
 /* [0x00000770] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000778] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
-/* [0x00000780] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
-/* [0x00000788] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000778] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000780] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000788] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
 /* [0x00000790] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000798] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000798] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 /* [0x000007a0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000007a8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000007a8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 /* [0x000007b0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000007b8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x000007b8] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
 /* [0x000007c0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x000007c8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x000007c8] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
 /* [0x000007d0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x000007d8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x000007d8] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
 /* [0x000007e0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x000007e8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x000007e8] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
 /* [0x000007f0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x000007f8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+/* [0x000007f8] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
 /* [0x00000800] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
 /* [0x00000808] */ 0x15267d80, 0x10020227, // mov ra8, ra9
 /* [0x00000810] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
@@ -291,61 +291,63 @@ unsigned int rpi_shader[] = {
 /* [0x00000830] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
 /* [0x00000838] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
 /* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000848] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
-/* [0x00000850] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
-/* [0x00000858] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
-/* [0x00000860] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
-/* [0x00000868] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
-/* [0x00000870] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000878] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000880] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000888] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000890] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000898] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x000008a0] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+/* [0x00000848] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x00000850] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x00000858] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000860] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x00000868] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x00000870] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000878] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000880] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000888] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000890] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000898] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x000008a0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
 /* [0x000008a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000008b0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
-/* [0x000008b8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000008c0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
-/* [0x000008c8] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000008d0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x000008d8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x000008e0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
-/* [0x000008e8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000008f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000008f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000900] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000908] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000910] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000918] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000920] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000928] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000008b8] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x000008c0] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x000008c8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000008d0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+/* [0x000008d8] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000008e0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x000008e8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x000008f0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+/* [0x000008f8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000900] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000908] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000910] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000918] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000920] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000928] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000930] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000938] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000930] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000938] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000940] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000948] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000940] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000948] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
 /* [0x00000950] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000958] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000960] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000968] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000970] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000960] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000968] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000970] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000978] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000980] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000978] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000980] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000988] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000988] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
 /* [0x00000990] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000998] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000009a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000009a8] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x000009b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x000009b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x000009c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x000009c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x000009d0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009d8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000009e0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x000009e8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x000009d8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009e0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000009e8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000009f0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000009f8] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 9de4535..e36c4ae 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -6,8 +6,8 @@ extern unsigned int rpi_shader[];
 #define mc_setup_uv (rpi_shader + 0)
 #define mc_filter_uv (rpi_shader + 142)
 #define mc_filter_uv_b (rpi_shader + 360)
-#define mc_exit (rpi_shader + 588)
-#define mc_interrupt_exit8 (rpi_shader + 606)
-#define mc_end (rpi_shader + 636)
+#define mc_exit (rpi_shader + 592)
+#define mc_interrupt_exit8 (rpi_shader + 610)
+#define mc_end (rpi_shader + 640)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 7f08c25..fa14313 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -443,23 +443,23 @@ add t0s, ra_x2_base, r2
 
 mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 
-mov r2, rb21         ; mul24 r3, r0, ra0
-nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24 r2, r0, ra0
+nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+nop                  ; mul24      r3, ra1 << 1, r0 << 1
 nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
 nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
 nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
 nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
 nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-sub r0, r2, r3
+add r0, r2, r3
 
 mov r3, rb31
 
@@ -474,23 +474,25 @@ sub.setf -, r3, 8 ; mov r1, ra22
 
 # apply horizontal filter         
 brr.anyn -, r:uvloop_b
-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr r0, r0, 15          ; mov r1, ra21
-min.setf ra15, r0, rb22
+mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+asr ra15, r0, 8         ; nop
+nop                     ; nop
  
 # apply vertical filter and write to VPM
 
-nop                     ; mul24 r0, ra14, rb14
-sub r1, r1, r0          ; mul24 r0, ra13, rb13
-sub r1, r1, r0          ; mul24 r0, ra12, rb12
-sub r1, r1, r0          ; mul24 r0, ra11, rb11
-sub r1, r1, r0          ; mul24 r0, ra10, rb10
-sub r1, r1, r0          ; mul24 r0, ra9, rb9
-sub r1, r1, r0          ; mul24 r0, ra8, rb8
-sub r1, r1, r0          ; mul24 r0, ra15, rb15
-sub.ifnn r1, r1, r0     ; mov -, vw_wait
+nop                     ; mul24 r1, ra14, rb14
+nop                     ; mul24 r0, ra13, rb13
+add r1, r1, r0          ; mul24 r0, ra12, rb12
+add r1, r1, r0          ; mul24 r0, ra11, rb11
+add r1, r1, r0          ; mul24 r0, ra10, rb10
+add r1, r1, r0          ; mul24 r0, ra9, rb9
+add r1, r1, r0          ; mul24 r0, ra8, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb15
+add r1, r1, r0          ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 15          
+asr r1, r1, 14
+add r1, r1, ra21
+asr r1, r1, 6          
 min r1, r1, rb22        
 add r0, vpm, 1          # Blend in previous VPM contents at this location
 brr.anyn -, r:uvloop_b
-- 
1.9.1


From 1638183f5c3cd437b46b5f89143616798853f23b Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 13 May 2015 16:12:58 +0100
Subject: [PATCH 23/77] Round up display size

---
 ffmpeg.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/ffmpeg.c b/ffmpeg.c
index 3daa2f4..53e32da 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -220,6 +220,8 @@ static void display_cb_input(MMAL_PORT_T *port,MMAL_BUFFER_HEADER_T *buffer) {
 static MMAL_COMPONENT_T* display_init(size_t x, size_t y, size_t w, size_t h)
 {
     MMAL_COMPONENT_T* display; 
+    int w2 = (w+31)&~31;
+    int h2 = (h+15)&~15;
     MMAL_DISPLAYREGION_T region =
     {
         {MMAL_PARAMETER_DISPLAYREGION, sizeof(region)},
@@ -236,17 +238,17 @@ static MMAL_COMPONENT_T* display_init(size_t x, size_t y, size_t w, size_t h)
     
     MMAL_ES_FORMAT_T* format = display->input[0]->format;
     format->encoding = MMAL_ENCODING_I420;
-    format->es->video.width = w;
-    format->es->video.height = h;
+    format->es->video.width = w2;
+    format->es->video.height = h2;
     format->es->video.crop.x = 0;
     format->es->video.crop.y = 0;
-    format->es->video.crop.width = w;
-    format->es->video.crop.height = h;
+    format->es->video.crop.width = w2;
+    format->es->video.crop.height = h2;
     mmal_port_format_commit(display->input[0]);
     
     mmal_component_enable(display);
     
-    rpi_pool = display_alloc_pool(display->input[0], w, h);
+    rpi_pool = display_alloc_pool(display->input[0], w2, h2);
     
     mmal_port_enable(display->input[0],display_cb_input);
     mmal_port_enable(display->control,display_cb_input);
-- 
1.9.1


From 63545a3c3734f7779e99d5e1f4d385095f02fa12 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 08:15:55 +0100
Subject: [PATCH 24/77] Added flush for SAO

---
 libavcodec/hevc.c        |  2 +-
 libavcodec/hevc_filter.c | 43 +++++++++++++++++++++++++++++--------------
 2 files changed, 30 insertions(+), 15 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 8358707..fa0aa24 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2867,7 +2867,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
             rpi_execute_inter_qpu(s);
 #endif
             // Transform all blocks
-            //printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+            // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
             rpi_execute_transform(s);
             // Perform inter prediction
             rpi_execute_inter_cmds(s);
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 3150cd0..b2b665d 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -870,6 +870,23 @@ static void flush_buffer(AVBufferRef *bref) {
     gpu_cache_flush(p);
 }
 
+#ifdef RPI_INTER_QPU
+void ff_hevc_flush_chroma(HEVCContext *s)
+{
+    if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
+            s->nal_unit_type == NAL_TSA_N   ||
+            s->nal_unit_type == NAL_STSA_N  ||
+            s->nal_unit_type == NAL_RADL_N  ||
+            s->nal_unit_type == NAL_RASL_N )) {           
+        flush_buffer(s->frame->buf[1]);
+        flush_buffer(s->frame->buf[2]);
+        //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
+        //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
+        //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
+    }
+}
+#endif
+
 void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
 {
     int x_end = x >= s->sps->width  - ctb_size;
@@ -882,31 +899,29 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
             sao_filter_CTB(s, x - ctb_size, y);
         if (y && x_end) {
             sao_filter_CTB(s, x, y - ctb_size);
-            if (s->threads_type & FF_THREAD_FRAME )
+            if (s->threads_type & FF_THREAD_FRAME ) {
+#ifdef RPI_INTER_QPU
+                ff_hevc_flush_chroma(s);
+#endif
                 ff_thread_report_progress(&s->ref->tf, y, 0);
+            }
         }
         if (x_end && y_end) {
             sao_filter_CTB(s, x , y);
-            if (s->threads_type & FF_THREAD_FRAME )
+            if (s->threads_type & FF_THREAD_FRAME ) {
+#ifdef RPI_INTER_QPU
+                ff_hevc_flush_chroma(s);
+#endif
                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
+            }
         }
     } else if (s->threads_type & FF_THREAD_FRAME && x_end) {
         //int newh = y + ctb_size - 4;
         //int currh = s->ref->tf.progress->data[0];
         //if (((y + ctb_size)&63)==0)
-        if (!(  s->nal_unit_type == NAL_TRAIL_N ||
-            s->nal_unit_type == NAL_TSA_N   ||
-            s->nal_unit_type == NAL_STSA_N  ||
-            s->nal_unit_type == NAL_RADL_N  ||
-            s->nal_unit_type == NAL_RASL_N )) {
-#ifdef RPI_INTER_QPU            
-            flush_buffer(s->frame->buf[1]);
-            flush_buffer(s->frame->buf[2]);
+#ifdef RPI_INTER_QPU
+        ff_hevc_flush_chroma(s);
 #endif
-            //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
-            //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
-            //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
-        }
         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
     }
 }
-- 
1.9.1


From 565c5bd1840feb55730a0d24f42ba51ebc37f64e Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 08:16:33 +0100
Subject: [PATCH 25/77] Fixed compilation bug

---
 libavcodec/hevc_filter.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index b2b665d..9fb08bc 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -871,7 +871,7 @@ static void flush_buffer(AVBufferRef *bref) {
 }
 
 #ifdef RPI_INTER_QPU
-void ff_hevc_flush_chroma(HEVCContext *s)
+static void ff_hevc_flush_chroma(HEVCContext *s)
 {
     if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
             s->nal_unit_type == NAL_TSA_N   ||
-- 
1.9.1


From 4caf7535365a2323e6e6b485d9dfa9cb5726d645 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 09:17:28 +0100
Subject: [PATCH 26/77] Stopped using acceleration in unsupported cases

---
 libavcodec/hevc.c       | 15 +++++++--------
 libavcodec/hevc_cabac.c |  4 ++--
 2 files changed, 9 insertions(+), 10 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index fa0aa24..d420f55 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -1116,15 +1116,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                         for (i = 0; i < (size * size); i++) {
                             coeffs[i] = ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
                         }
-                        printf("Cross component not supported\n"); // TODO
-                        exit(-1);
                         s->hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
                     }
             }
 
-            if (lc->tu.cross_pf) {
-                printf("Cross component not supported\n"); // TODO
-                exit(-1);        
+            if (lc->tu.cross_pf) {       
                 hls_cross_component_pred(s, 1);
             }
             for (i = 0; i < (s->sps->chroma_format_idc == 2 ? 2 : 1); i++) {
@@ -1153,8 +1149,6 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                         for (i = 0; i < (size * size); i++) {
                             coeffs[i] = ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
                         }
-                        printf("Cross component not supported\n"); // TODO
-                        exit(-1);
                         s->hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
                     }
             }
@@ -2821,7 +2815,12 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
 
 #ifdef RPI
-    s->enable_rpi = 1; // TODO this should depend on cross component and frame width etc.
+    s->enable_rpi = s->sps->width <= RPI_MAX_WIDTH
+                    && !s->pps->cross_component_prediction_enabled_flag
+                    && s->pps->num_tile_rows <= 1 && s->pps->num_tile_columns <= 1
+                    && !(s->pps->weighted_pred_flag && s->sh.slice_type == P_SLICE)
+                    && !(s->pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE);
+                    
 #endif
 
     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index f2ff50d..7096e31 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1559,9 +1559,9 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
 #ifdef RPI
             if (!use_vpu) {
               int max_xy = FFMAX(last_significant_coeff_x, last_significant_coeff_y);
-              if (max_xy == 0)
+              if (max_xy == 0) {
                   s->hevcdsp.idct_dc[log2_trafo_size-2](coeffs);
-              else {
+              } else {
                   int col_limit = last_significant_coeff_x + last_significant_coeff_y + 4;
                   if (max_xy < 4)
                       col_limit = FFMIN(4, col_limit);
-- 
1.9.1


From cd2ee2264f86165dd782cec4b1cafa964ffa91f2 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 09:42:16 +0100
Subject: [PATCH 27/77] Split B prediction into two passes

---
 libavcodec/hevc.c          |   1 +
 libavcodec/hevc.h          |   1 +
 libavcodec/rpi_qpu.c       |   3 +
 libavcodec/rpi_qpu.h       |   1 +
 libavcodec/rpi_shader.c    | 559 +++++++++++++++++++++++++++------------------
 libavcodec/rpi_shader.h    |  11 +-
 libavcodec/rpi_shader.qasm | 198 ++++++++++++++--
 7 files changed, 532 insertions(+), 242 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index d420f55..aa46210 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -3925,6 +3925,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
             p += uv_commands_per_qpu;
         }
         s->mc_filter_uv = qpu_get_fn(QPU_MC_FILTER_UV);
+        s->mc_filter_uv_b0 = qpu_get_fn(QPU_MC_FILTER_UV_B0);
         s->mc_filter_uv_b = qpu_get_fn(QPU_MC_FILTER_UV_B);
         
     }
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 05438af..70303cc 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -913,6 +913,7 @@ typedef struct HEVCContext {
     uint32_t *u_mvs[8];
     // Function pointers
     uint32_t mc_filter_uv;
+    uint32_t mc_filter_uv_b0;
     uint32_t mc_filter_uv_b;
 #endif
     
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index a814443..59f5494 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -633,6 +633,9 @@ unsigned int qpu_get_fn(int num) {
     case QPU_MC_FILTER_UV:
       fn = mc_filter_uv;
       break;
+    case QPU_MC_FILTER_UV_B0:
+      fn = mc_filter_uv_b0;
+      break;
     case QPU_MC_FILTER_UV_B:
       fn = mc_filter_uv_b;
       break;
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index f9ad333..543c84b 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -29,6 +29,7 @@ enum {
   QPU_MC_FILTER_HONLY,
   QPU_MC_SETUP_UV,
   QPU_MC_FILTER_UV,
+  QPU_MC_FILTER_UV_B0,
   QPU_MC_FILTER_UV_B,
   QPU_MC_INTERRUPT_EXIT8,
   QPU_MC_END
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 5d00cb2..88ad20b 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -39,18 +39,18 @@ unsigned int rpi_shader[] = {
 /* [0x00000070] */ 0x00000100, 0xe00205a7, // mov ra22, 256
 /* [0x00000078] */ 0x00000008, 0xe00205e7, // mov ra23, 8
 /* [0x00000080] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
-/* [0x00000088] */ 0x00000040, 0xe0021567, // mov rb21, 64
-/* [0x00000090] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
-/* [0x00000098] */ 0x00000018, 0xe00215e7, // mov rb23, 24
-/* [0x000000a0] */ 0x00000000, 0xe0020227, // mov ra8, 0
-/* [0x000000a8] */ 0x00000000, 0xe0020267, // mov ra9, 0
-/* [0x000000b0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
-/* [0x000000b8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
-/* [0x000000c0] */ 0x00000000, 0xe0020327, // mov ra12, 0
-/* [0x000000c8] */ 0x00000000, 0xe0020367, // mov ra13, 0
-/* [0x000000d0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
-/* [0x000000d8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x000000e0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000088] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x00000090] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x00000098] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x000000a0] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x000000a8] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x000000b0] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x000000b8] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x000000c0] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x000000c8] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x000000d0] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x000000d8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x000000e0] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
 /* [0x000000e8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
 /* [0x000000f0] */ 0x159e7480, 0x10020867, // mov r1, r2
 /* [0x000000f8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
@@ -62,176 +62,176 @@ unsigned int rpi_shader[] = {
 /* [0x00000128] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
 /* [0x00000130] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
 /* [0x00000138] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000140] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00000148] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000150] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000158] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000160] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000168] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000170] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000178] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x00000180] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x00000188] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
-/* [0x00000190] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
-/* [0x00000198] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
-/* [0x000001a0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-/* [0x000001a8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x000001b0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000001b8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000001c0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
-/* [0x000001c8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x000001d0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-/* [0x000001d8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
-/* [0x000001e0] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x000001e8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000001f0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000001f8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000200] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000208] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000210] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000218] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000220] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000228] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
-/* [0x00000230] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+/* [0x00000140] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+/* [0x00000148] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00000150] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000158] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000160] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000168] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000170] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000178] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000180] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000188] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000190] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
+/* [0x00000198] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+/* [0x000001a0] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
+/* [0x000001a8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+/* [0x000001b0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x000001b8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+/* [0x000001c0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+/* [0x000001c8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x000001d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000001d8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000001e0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+/* [0x000001e8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x000001f0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+/* [0x000001f8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+/* [0x00000200] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+/* [0x00000208] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000218] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000220] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000228] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000230] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000238] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000240] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000248] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+/* [0x00000250] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
 // ::mc_filter_uv
-/* [0x00000238] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000240] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000248] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000250] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000258] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000260] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000268] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000270] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000278] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000280] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000288] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000290] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000298] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000002a0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000002a8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000002b0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000002b8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002c0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x000002c8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x000002d0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000002d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000002e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000002e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000002f0] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x000002f8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000300] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000308] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000310] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000318] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000320] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000328] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000330] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000338] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000340] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000348] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000350] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000358] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000360] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000368] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000370] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000378] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000380] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000388] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000390] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000258] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000260] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000268] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000270] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000278] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000280] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000288] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000290] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000298] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000002a0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000002a8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000002b0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000002b8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000002c0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002c8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000002d0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000002d8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000002e0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x000002e8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x000002f0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000002f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000300] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000308] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000310] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000340] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000348] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000350] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000358] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000360] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000368] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000370] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000378] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000380] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000388] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000390] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000398] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x000003a0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000003a8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003b0] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x00000398] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000003a0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000003a8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000003b0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003b8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003c0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003c8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003d0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003d8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000003e0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000003e8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000003f0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000003f8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000400] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000408] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000410] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000418] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000420] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000428] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000430] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000438] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000440] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000448] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000450] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000458] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000460] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000468] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000470] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000478] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000480] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000488] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000490] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000498] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x000004a0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x000004a8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000004b0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x000004b8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004c0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x000004c8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x000004d0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x000004d8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x000004e0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x000004e8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x000004f0] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x000004f8] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000500] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000508] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000510] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000518] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000520] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000528] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000530] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x00000538] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000540] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000560] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000568] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000570] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000578] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000580] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000588] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000590] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000598] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-// ::mc_filter_uv_b
-/* [0x000005a0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000005a8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000005b0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000005b8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000005c0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000005c8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000005d0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000005d8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000005e0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000005e8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000005f0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000005f8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000600] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000608] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000610] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000618] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000620] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000628] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000630] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000638] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000640] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000648] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000650] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000658] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000660] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000668] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000670] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+/* [0x000003b8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000003c0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000003c8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000003d0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003d8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003e0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003e8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003f0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003f8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000400] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000408] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000410] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000418] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000420] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000428] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000430] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000438] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000440] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000448] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000450] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000458] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000460] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000468] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000470] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000478] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000480] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000488] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000490] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000498] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x000004a0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x000004a8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x000004b0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x000004b8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x000004c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x000004c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000004d0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x000004d8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000004e0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x000004e8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x000004f0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x000004f8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x00000500] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x00000508] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000510] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000518] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000520] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000528] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000530] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000538] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000540] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000548] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000550] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x00000558] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000560] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x00000568] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000570] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000578] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000580] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000588] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000590] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000598] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000005a0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000005a8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000005b0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000005b8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_filter_uv_b0
+/* [0x000005c0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000005c8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000005d0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000005d8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000005e0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000005e8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000005f0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000005f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000600] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000608] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000610] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000618] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000620] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000628] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000630] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000638] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000640] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000648] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000650] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000658] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000660] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000668] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000670] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
 /* [0x00000678] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
 /* [0x00000680] */ 0x15827d80, 0x10020827, // mov r0, unif
 /* [0x00000688] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
@@ -253,7 +253,7 @@ unsigned int rpi_shader[] = {
 /* [0x00000708] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
 /* [0x00000710] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 /* [0x00000718] */ 0x00000000, 0xe00208e7, // mov r3, 0
-// :uvloop_b
+// :uvloop_b0
 /* [0x00000720] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
 /* [0x00000728] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
 /* [0x00000730] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
@@ -290,7 +290,7 @@ unsigned int rpi_shader[] = {
 /* [0x00000828] */ 0x15367d80, 0x10020327, // mov ra12, ra13
 /* [0x00000830] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
 /* [0x00000838] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
 /* [0x00000848] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
 /* [0x00000850] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
 /* [0x00000858] */ 0x009e7000, 0x100009e7, // nop                     ; nop
@@ -306,48 +306,163 @@ unsigned int rpi_shader[] = {
 /* [0x000008a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
 /* [0x000008b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
 /* [0x000008b8] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x000008c0] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x000008c8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000008d0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
-/* [0x000008d8] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000008e0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x000008e8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x000008f0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
-/* [0x000008f8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000900] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000908] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000910] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000918] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000920] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000928] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000930] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000938] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008c0] */ 0xfffffad8, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000008c8] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x000008d0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000008d8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000008e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000008e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000008f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008f8] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000900] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000908] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000910] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000918] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000920] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_filter_uv_b
+/* [0x00000928] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000930] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000938] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000940] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000948] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000950] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000958] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000960] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000968] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000970] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000978] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000980] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000988] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000990] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000998] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000009a0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000009a8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000009b0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x000009b8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x000009c0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000009c8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x000009d0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x000009d8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x000009e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000009e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000009f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000009f8] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+/* [0x00000a00] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000a08] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000a10] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a18] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a20] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a28] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000a30] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a38] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a40] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a48] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000a50] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a58] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a60] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a68] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000a70] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a78] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a80] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a88] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000a90] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000a98] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000aa0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :uvloop_b
+/* [0x00000aa8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000ab0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000ab8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000ac0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000ac8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000ad0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000ad8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000ae0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000ae8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000af0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000af8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000b00] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000b08] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000b10] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000b18] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000b20] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000b28] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000b30] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000b38] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000b40] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000b48] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000b50] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000b58] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000b60] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000b68] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000b70] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000b78] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000b80] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000b88] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000b90] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000b98] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000ba0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000ba8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000bb0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000bb8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000bc0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000bc8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000bd0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x00000bd8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x00000be0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000be8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x00000bf0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x00000bf8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000c00] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000c08] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000c10] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000c18] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000c20] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000c28] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000c30] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000c38] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000c40] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x00000c48] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x00000c50] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000c58] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+/* [0x00000c60] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000c68] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000c70] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x00000c78] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+/* [0x00000c80] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000c88] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000c90] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000c98] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000ca0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000ca8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000cb0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000cb8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000cc0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000940] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000948] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000950] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000958] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000960] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000968] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000970] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000978] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000980] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000cc8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000cd0] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000cd8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ce0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ce8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000cf0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000cf8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000d00] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000d08] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000988] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000990] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000998] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000009a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000009a8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000009b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009d0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009d8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009e0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000009e8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000009f0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x000009f8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000d10] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000d18] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000d20] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000d28] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000d30] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000d38] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d40] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d58] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d60] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d70] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000d78] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000d80] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index e36c4ae..809e582 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -4,10 +4,11 @@
 extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
-#define mc_filter_uv (rpi_shader + 142)
-#define mc_filter_uv_b (rpi_shader + 360)
-#define mc_exit (rpi_shader + 592)
-#define mc_interrupt_exit8 (rpi_shader + 610)
-#define mc_end (rpi_shader + 640)
+#define mc_filter_uv (rpi_shader + 150)
+#define mc_filter_uv_b0 (rpi_shader + 368)
+#define mc_filter_uv_b (rpi_shader + 586)
+#define mc_exit (rpi_shader + 818)
+#define mc_interrupt_exit8 (rpi_shader + 836)
+#define mc_end (rpi_shader + 866)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index fa14313..2e66dbe 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -26,7 +26,7 @@
 # ra23                                          8
 #
 # rb20                                          0xffffff00
-# rb21                                          64
+# rb21                                          vpm_setup for writing 16bit results into VPM
 # rb22                                          255
 # rb23                                          24
 #
@@ -34,7 +34,7 @@
 # rb25                                          frame width-1
 # rb26                                          height<<23 + width<<16 + vdw_setup_0
 # rb27                                          vdw_setup_0 (depends on QPU number)
-# rb28                                          vpm_setup (depends on QPU number)
+# rb28                                          vpm_setup (depends on QPU number) for writing 8bit results into VPM
 # rb29                                          vdw_setup_1(dst_pitch-width)
 # rb30                                          frame height-1
 # rb31                                          used as temp to count loop iterations
@@ -69,8 +69,6 @@
 .set ra_y_next,                    ra28
 .set ra_y,                         ra29
 
-.set rb_const_64,                  rb21
-
 
 ################################################################################
 # mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
@@ -106,7 +104,6 @@ mov ra22, 256
 mov ra23, 8
 
 mov rb20, 0xffffff00
-mov rb21, 64
 mov rb22, 255
 mov rb23, 24
 
@@ -123,6 +120,7 @@ mov ra15, 0
 
 # Compute part of VPM to use for DMA output
 mov r2, qpu_num
+shl r2, r2, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
 and r2, r2, 15
 mov r1, r2
 asr r1, r1, 2
@@ -135,16 +133,21 @@ shl r0, r0, 5
 add rb27, r0, r1
 
 # Compute part of VPM to save data into
-mov r2, qpu_num
-and r2, r2, 15
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vpm_setup(0, 4, h8p(0, 0))
-add rb28, r0, r1 
+mov r2, qpu_num   # qpu_num = abcd
+shl r2, r2, 1     
+and r2, r2, 15    # r2 = bcd0
+mov r1, r2        # r1 = bcd0
+asr r1, r1, 2     # r1 = bc
+shl r1, r1, 6     # r1 = bc000000
+mov r0, r2        # r0 = bcd0
+and r0, r0, 3     # r0 = d0
+add r0, r0, r1    # r0 = bc0000d0
+mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
+add rb28, r0, r1    
+asr r0, r0, 1     # r0 = bc0000d
+# Prepare VPM command for 16bit intermediates
+mov r1, vpm_setup(0, 2, h16p(0, 0))  # 2 is stride - stride acts on ADDR which is Y[5:0],H[0] for 16 bit
+add rb21, r0, r1
 
 # Compute base address for first and second access
 mov r0, ra_x_base           # Load x
@@ -345,6 +348,171 @@ mov vw_addr, unif # start the VDW
 
 ################################################################################
 
+# mc_filter_uv_b0(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
+
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x_base, ra_x16_base point to the current coordinates for this block
+::mc_filter_uv_b0
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num    # x
+max r0, r0, 0; mov r1, unif # y
+min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+shl ra_xshift_next, r0, 3
+sub r2, unif, r3 # compute offset from frame base u to frame base v
+add r0, r0, r3
+and rb_x_base_next, r0, ~3 
+mov ra_y_next, r1
+add ra_x2_base_next, rb_x_base_next, r2
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+
+# get filter coefficients
+
+mov r0, unif
+asr ra3, r0, rb23;      mul24 r0, r0, ra22
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+asr rb15, r0, rb23;     mul24 r0, r0, ra22
+asr rb14, r0, rb23;     mul24 r0, r0, ra22
+asr rb13, r0, rb23;     mul24 r0, r0, ra22
+asr rb12, r0, rb23  
+
+# r2 is elem_num
+# r3 is loop counter
+
+mov r5rep, -8 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+mov r3, 0
+
+:uvloop_b0
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
+mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
+add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+add t0s, ra_x2_base, r2   
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+nop                  ; mul24 r2, r0, ra0
+nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+nop                  ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+add r0, r2, r3
+
+mov r3, rb31
+
+mov ra8, ra9
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+mov ra13, ra14
+
+sub.setf -, r3, 8 ; mov r1, ra22
+
+# apply horizontal filter         
+brr.anyn -, r:uvloop_b0
+mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
+asr ra15, r0, 8         ; nop
+nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r1, ra14, rb14
+nop                     ; mul24 r0, ra13, rb13
+add r1, r1, r0          ; mul24 r0, ra12, rb12
+add r1, r1, r0          ; mul24 r0, ra11, rb11
+add r1, r1, r0          ; mul24 r0, ra10, rb10
+add r1, r1, r0          ; mul24 r0, ra9, rb9
+add r1, r1, r0          ; mul24 r0, ra8, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb15
+add r1, r1, r0          ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+asr r1, r1, 14
+add r1, r1, ra21
+brr.anyn -, r:uvloop 
+asr r1, r1, 6          # Delay 1
+min r1, r1, rb22       # Delay 2
+max vpm, r1, 0         # Delay 3
+
+# DMA out for U
+
+mov vw_setup, rb26 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+# DMA out for V
+# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+# Could potentially push this write into the start of the next pipeline stage.
+mov r0, 16
+mov -, vw_wait
+
+bra -, ra31
+add vw_setup, rb26, r0 # VDW setup 0
+mov vw_setup, rb29 # Stride
+mov vw_addr, unif # start the VDW
+
+################################################################################
+
 ::mc_filter_uv_b
 mov ra31, unif
 
-- 
1.9.1


From 365a00d7a50aac730c67bc9ea331801fa21e8c71 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 10:04:55 +0100
Subject: [PATCH 28/77] Switch to using 16bit temp buffers

---
 libavcodec/hevc.c          |  2 +-
 libavcodec/rpi_shader.c    |  4 ++--
 libavcodec/rpi_shader.qasm | 10 +++++-----
 3 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index aa46210..b75f865 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2111,7 +2111,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 uint32_t *u = s->u_mvs[chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b0;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);  
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 88ad20b..ffd3a07 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -220,7 +220,7 @@ unsigned int rpi_shader[] = {
 /* [0x00000600] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
 /* [0x00000608] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
 /* [0x00000610] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000618] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000618] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
 /* [0x00000620] */ 0x00000010, 0xe00208a7, // mov r2, 16
 /* [0x00000628] */ 0x15827d80, 0x10020827, // mov r0, unif
 /* [0x00000630] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
@@ -346,7 +346,7 @@ unsigned int rpi_shader[] = {
 /* [0x000009e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
 /* [0x000009e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
 /* [0x000009f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000009f8] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+/* [0x000009f8] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
 /* [0x00000a00] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
 /* [0x00000a08] */ 0x15827d80, 0x10020827, // mov r0, unif
 /* [0x00000a10] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 2e66dbe..ded5e40 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -26,7 +26,7 @@
 # ra23                                          8
 #
 # rb20                                          0xffffff00
-# rb21                                          vpm_setup for writing 16bit results into VPM
+# rb21                                          vpm_setup for reading/writing 16bit results into VPM
 # rb22                                          255
 # rb23                                          24
 #
@@ -370,8 +370,8 @@ and rb_x_base_next, r0, ~3
 mov ra_y_next, r1
 add ra_x2_base_next, rb_x_base_next, r2
 
-# set up VPM write
-mov vw_setup, rb28
+# set up VPM write, we need to save 16bit precision
+mov vw_setup, rb21
 
 # get width,height of block
 mov r2, 16
@@ -554,8 +554,8 @@ add r0, r0, r1 # Combine width and height of destination area
 shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
 add rb26, r0, rb27
 
-# In a B frame, so also set up VPM read
-add vr_setup, r3, rb28
+# In a B frame, so also set up VPM read (reading back 16bit precision)
+add vr_setup, r3, rb21
 
 sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
 
-- 
1.9.1


From 2631728ec406c6d9311b526daa6ada7965917899 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 10:30:44 +0100
Subject: [PATCH 29/77] Corrected B prediction: matching md5 sum for hobbit50

---
 libavcodec/rpi_shader.c    | 815 ++++++++++++++++++++++-----------------------
 libavcodec/rpi_shader.h    |  12 +-
 libavcodec/rpi_shader.qasm |  36 +-
 3 files changed, 429 insertions(+), 434 deletions(-)

diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index ffd3a07..77cca46 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -38,431 +38,428 @@ unsigned int rpi_shader[] = {
 /* [0x00000068] */ 0x00000020, 0xe0020567, // mov ra21, 32
 /* [0x00000070] */ 0x00000100, 0xe00205a7, // mov ra22, 256
 /* [0x00000078] */ 0x00000008, 0xe00205e7, // mov ra23, 8
-/* [0x00000080] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
-/* [0x00000088] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
-/* [0x00000090] */ 0x00000018, 0xe00215e7, // mov rb23, 24
-/* [0x00000098] */ 0x00000000, 0xe0020227, // mov ra8, 0
-/* [0x000000a0] */ 0x00000000, 0xe0020267, // mov ra9, 0
-/* [0x000000a8] */ 0x00000000, 0xe00202a7, // mov ra10, 0
-/* [0x000000b0] */ 0x00000000, 0xe00202e7, // mov ra11, 0
-/* [0x000000b8] */ 0x00000000, 0xe0020327, // mov ra12, 0
-/* [0x000000c0] */ 0x00000000, 0xe0020367, // mov ra13, 0
-/* [0x000000c8] */ 0x00000000, 0xe00203a7, // mov ra14, 0
-/* [0x000000d0] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x000000d8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x000000e0] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
-/* [0x000000e8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x000000f0] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x000000f8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000100] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000108] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000110] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000118] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000120] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
-/* [0x00000128] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
-/* [0x00000130] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00000138] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000140] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
-/* [0x00000148] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00000150] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000158] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000160] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000168] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000170] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000178] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000180] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x00000188] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x00000190] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
-/* [0x00000198] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
-/* [0x000001a0] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
-/* [0x000001a8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
-/* [0x000001b0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
-/* [0x000001b8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
-/* [0x000001c0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-/* [0x000001c8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x000001d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000001d8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000001e0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
-/* [0x000001e8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x000001f0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-/* [0x000001f8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
-/* [0x00000200] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x00000208] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000080] */ 0x00000040, 0xe00207a7, // mov ra30, 64
+/* [0x00000088] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x00000090] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x00000098] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x000000a0] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x000000a8] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x000000b0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x000000b8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x000000c0] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x000000c8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x000000d0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x000000d8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x000000e0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x000000e8] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+/* [0x000000f0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x000000f8] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000100] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000108] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000110] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000118] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000120] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000128] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00000130] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00000138] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00000140] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000148] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+/* [0x00000150] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00000158] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000160] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000168] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000170] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000178] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000180] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000188] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000190] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000198] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
+/* [0x000001a0] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+/* [0x000001a8] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
+/* [0x000001b0] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+/* [0x000001b8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x000001c0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+/* [0x000001c8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+/* [0x000001d0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x000001d8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000001e0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000001e8] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+/* [0x000001f0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x000001f8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+/* [0x00000200] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+/* [0x00000208] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
 /* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
 /* [0x00000218] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000220] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000228] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000230] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000238] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000240] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000248] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
-/* [0x00000250] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+/* [0x00000220] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000228] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000230] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000238] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000240] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000248] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000250] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+/* [0x00000258] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
 // ::mc_filter_uv
-/* [0x00000258] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000260] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000268] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000270] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000278] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000280] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000288] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000290] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000298] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000002a0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000002a8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000002b0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000002b8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000002c0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000002c8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000002d0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000002d8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002e0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x000002e8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x000002f0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000002f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000300] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000308] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000310] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000340] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000348] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000350] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000358] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000360] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000368] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000370] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000378] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000380] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000388] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000390] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000398] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x000003a0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000003a8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000003b0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000268] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000270] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000278] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000280] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000288] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000290] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000298] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000002a0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000002a8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000002b0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000002b8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000002c0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000002c8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000002e8] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x000002f0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000318] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000320] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000328] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000330] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000338] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000340] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000348] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000350] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000358] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000360] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000368] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000370] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000378] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000380] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000388] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000390] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000398] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000003a0] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x000003a8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000003b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003b8] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x000003b8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000003c0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000003c8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000003d0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003d8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003e0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003e8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003f0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003f8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000400] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000408] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000410] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000418] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000420] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000428] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000430] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000438] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000440] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000448] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000450] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000458] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000460] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000468] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000470] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000478] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000480] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000488] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000490] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000498] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x000004a0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x000004a8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x000004b0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x000004b8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x000004c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x000004c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000004d0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x000004d8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004e0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x000004e8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x000004f0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x000004f8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x00000500] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x00000508] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000510] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000518] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000520] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000528] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000530] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000538] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000540] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000548] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000550] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x00000558] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000560] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x00000568] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000570] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000578] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000580] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000588] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000590] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000598] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000005a0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000005a8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x000005b0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000005b8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000003c0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000003c8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000003d0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000003d8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003e0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003e8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003f0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003f8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000400] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000408] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000410] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000418] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000420] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000428] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000430] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000438] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000440] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000448] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000450] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000458] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000460] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000468] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000470] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000478] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000480] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000488] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000490] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000498] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x000004a0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x000004a8] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x000004b0] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x000004b8] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x000004c0] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x000004c8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x000004d0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000004d8] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x000004e0] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000004e8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x000004f0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x000004f8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000500] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x00000508] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x00000510] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000518] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000520] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000528] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000530] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000538] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000540] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000548] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000550] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000558] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x00000560] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000568] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x00000570] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000578] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000580] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000588] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000590] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000598] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000005a0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000005a8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000005b0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000005b8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000005c0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x000005c0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000005c8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000005d0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000005d8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000005e0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000005e8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000005f0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000005f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000600] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000608] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000610] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000618] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x00000620] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000628] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000630] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000638] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000640] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000648] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000650] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000658] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000660] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000668] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000670] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000678] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000680] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000688] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000690] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000698] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000006a8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006b0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006b8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006c0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000006c8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006d0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006d8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006e0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000006e8] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006f0] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006f8] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000700] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000708] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000710] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000718] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000005c8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000005d0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000005d8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000005e0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000005e8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000005f0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000005f8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000600] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000608] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000610] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000618] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000620] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x00000628] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000630] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000638] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000640] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000648] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000650] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000658] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000660] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000668] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000670] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000678] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000680] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000688] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000690] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000698] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000006b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000006d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000006e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000006f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000006f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000700] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000708] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000710] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000718] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000720] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000720] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000728] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000730] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000738] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000740] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000748] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000750] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000758] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000760] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000768] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000770] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000778] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000780] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000788] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000790] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000798] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000007a0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000007a8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000007b0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000007b8] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x000007c0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x000007c8] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x000007d0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x000007d8] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x000007e0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x000007e8] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x000007f0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x000007f8] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000800] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000808] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000810] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000818] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000820] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000828] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000830] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000838] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000848] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x00000850] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x00000858] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000860] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x00000868] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x00000870] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000878] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000880] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000888] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000890] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000898] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x000008a0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000008a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000008b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000008b8] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x000008c0] */ 0xfffffad8, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000008c8] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x000008d0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000008d8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000008e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000008e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000008f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000008f8] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000900] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000908] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000910] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000918] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000920] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000728] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000730] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000738] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000740] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000748] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000750] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000758] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000760] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000768] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000770] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000778] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000780] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000788] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000790] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000798] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000007a0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000007a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000007b0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000007b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000007c0] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x000007c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x000007d0] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x000007d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x000007e0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x000007e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x000007f0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x000007f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000800] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000808] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000810] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000818] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000820] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000828] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000830] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000838] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000840] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000848] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000850] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x00000858] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x00000860] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000868] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x00000870] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x00000878] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000880] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000888] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000890] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000898] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x000008a0] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x000008a8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000008b0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000008b8] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x000008c0] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
+/* [0x000008c8] */ 0x009e7000, 0x100009e7, // nop
+/* [0x000008d0] */ 0x009e7000, 0x100009e7, // nop
+/* [0x000008d8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000008e0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000008e8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008f0] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000008f8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000900] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000908] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000910] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000918] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b
-/* [0x00000928] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000930] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000938] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000940] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000948] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000950] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000958] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000960] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000968] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000970] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000978] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000980] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000988] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000990] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000998] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000009a0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000009a8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000009b0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x000009b8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x000009c0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000009c8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x000009d0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x000009d8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x000009e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000009e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000009f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000009f8] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000a00] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000a08] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000a10] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a18] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a20] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a28] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000a30] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a38] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a40] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a48] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000a50] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a58] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a60] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a68] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000a70] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a78] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a80] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a88] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000a90] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000a98] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000aa0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000920] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000928] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000930] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000938] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000940] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000948] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000950] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000958] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000960] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000968] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000970] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000978] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000980] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000988] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000990] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000998] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000009a0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000009a8] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x000009b0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x000009b8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000009c0] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x000009c8] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x000009d0] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x000009d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000009e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000009e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000009f0] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x000009f8] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000a00] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000a08] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a10] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a18] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a20] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000a28] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a30] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a38] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a40] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000a48] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a50] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a58] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000a60] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000a68] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a70] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a78] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000a80] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000a88] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000a90] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000a98] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x00000aa8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000ab0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000ab8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000ac0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000ac8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000ad0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000ad8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000ae0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000ae8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000af0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000af8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000b00] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000b08] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000b10] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000b18] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000b20] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000b28] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000b30] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000b38] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000b40] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000b48] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000b50] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000b58] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000b60] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000b68] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000b70] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000b78] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000b80] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000b88] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000b90] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000b98] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000ba0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000ba8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000bb0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000bb8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000bc0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000bc8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000bd0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x00000bd8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x00000be0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000be8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x00000bf0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x00000bf8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000c00] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000c08] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000c10] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000c18] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000c20] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000c28] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000c30] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000c38] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000c40] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x00000c48] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x00000c50] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000c58] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
-/* [0x00000c60] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000c68] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x00000c70] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x00000c78] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
-/* [0x00000c80] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000c88] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000c90] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000c98] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000ca0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000ca8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000cb0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000cb8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000cc0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000aa0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000aa8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000ab0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000ab8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000ac0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000ac8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000ad0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000ad8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000ae0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000ae8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000af0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000af8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000b00] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000b08] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000b10] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000b18] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000b20] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000b28] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000b30] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000b38] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000b40] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000b48] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000b50] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000b58] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000b60] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000b68] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000b70] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000b78] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000b80] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000b88] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000b90] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000b98] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000ba0] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000ba8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000bb0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000bb8] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000bc0] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000bc8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x00000bd0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x00000bd8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000be0] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x00000be8] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x00000bf0] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000bf8] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000c00] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000c08] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000c10] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000c18] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000c20] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000c28] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000c30] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000c38] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x00000c40] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000c48] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000c50] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000c58] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000c60] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000c68] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000c70] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000c78] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000c80] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000c88] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000c90] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000c98] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000ca0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000ca8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000cc8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000cd0] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000cb0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000cb8] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000cc0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000cc8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000cd0] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000cd8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ce0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ce8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000cf0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000cf8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000d00] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000d08] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000ce0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000ce8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000cf0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000d10] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000cf8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000d00] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000d08] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000d10] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000d18] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000d20] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000d28] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000d30] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000d20] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d28] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000d30] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000d38] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000d40] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000d48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000d50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d58] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d60] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d70] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000d78] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000d80] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000d58] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000d60] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000d68] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 809e582..6562fa9 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -4,11 +4,11 @@
 extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
-#define mc_filter_uv (rpi_shader + 150)
-#define mc_filter_uv_b0 (rpi_shader + 368)
-#define mc_filter_uv_b (rpi_shader + 586)
-#define mc_exit (rpi_shader + 818)
-#define mc_interrupt_exit8 (rpi_shader + 836)
-#define mc_end (rpi_shader + 866)
+#define mc_filter_uv (rpi_shader + 152)
+#define mc_filter_uv_b0 (rpi_shader + 370)
+#define mc_filter_uv_b (rpi_shader + 584)
+#define mc_exit (rpi_shader + 812)
+#define mc_interrupt_exit8 (rpi_shader + 830)
+#define mc_end (rpi_shader + 860)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index ded5e40..23d674e 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -39,13 +39,13 @@
 # rb30                                          frame height-1
 # rb31                                          used as temp to count loop iterations
 #
-# ra24...ra30                                   15, 14, 13, 12, 11, 10, 9
 # ra24                                          clipped(row start address+8+elem_num)&~3
 # ra25                                          per-channel shifts 2
 # ra26                                          next ra24
 # ra27                                          next ra25
 # ra28                                          next y
 # ra29                                          y for next texture access
+# ra30                                          64
 #
 # ra31                                          next kernel address
 
@@ -102,6 +102,7 @@ mov ra20, 1
 mov ra21, 32
 mov ra22, 256
 mov ra23, 8
+mov ra30, 64
 
 mov rb20, 0xffffff00
 mov rb22, 255
@@ -472,7 +473,7 @@ sub.setf -, r3, 8 ; mov r1, ra22
 # apply horizontal filter         
 brr.anyn -, r:uvloop_b0
 mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
-asr ra15, r0, 8         ; nop
+asr ra15, r0, 8         ; nop  # TODO isn't ra15 already in 24bit precision, may not need the sign extension here?
 nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
  
 # apply vertical filter and write to VPM
@@ -487,18 +488,18 @@ add r1, r1, r0          ; mul24 r0, ra8, rb8
 add r1, r1, r0          ; mul24 r0, ra15, rb15
 add r1, r1, r0          ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 14
-add r1, r1, ra21
-brr.anyn -, r:uvloop 
-asr r1, r1, 6          # Delay 1
-min r1, r1, rb22       # Delay 2
-max vpm, r1, 0         # Delay 3
+#asr r1, r1, 14
+#add r1, r1, ra21
+brr.anyn -, r:uvloop_b0
+asr vpm, r1, 14        # Delay 1 shifts down by shift2=6, but results are still in 16bit precision TODO may be able to avoid the mul24 and use more delay slots
+nop                    # Delay 2
+nop                    # Delay 3
 
 # DMA out for U
 
 mov vw_setup, rb26 # VDW setup 0
 mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW
+mov vw_addr, unif # start the VDW    # TODO in pass0 we don't need to save any results
 
 # DMA out for V
 # We need to wait for the U to complete first, but have nothing useful to compute while we wait.
@@ -639,12 +640,11 @@ mov ra12, ra13
 mov ra13, ra14
 
 sub.setf -, r3, 8 ; mov r1, ra22
-
 # apply horizontal filter         
 brr.anyn -, r:uvloop_b
 mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
 asr ra15, r0, 8         ; nop
-nop                     ; nop
+nop                     ; nop    # TODO improve use of delay slots
  
 # apply vertical filter and write to VPM
 
@@ -658,15 +658,13 @@ add r1, r1, r0          ; mul24 r0, ra8, rb8
 add r1, r1, r0          ; mul24 r0, ra15, rb15
 add r1, r1, r0          ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 14
-add r1, r1, ra21
-asr r1, r1, 6          
-min r1, r1, rb22        
-add r0, vpm, 1          # Blend in previous VPM contents at this location
+asr r1, r1, 14          # shift2=6
+add r1, r1, vpm         # Blend in previous VPM contents at this location
+add r1, r1, ra30
 brr.anyn -, r:uvloop_b
-max r1, r1, 0
-add r1, r1, r0
-shr vpm, r1, 1
+asr r1, r1, 7           # Delay 1    
+min r1, r1, rb22        # Delay 2
+max vpm, r1, 0          # Delay 3
 
 
 # DMA out for U
-- 
1.9.1


From 61974b3b7955caadcccfe67f70d37be550cbfd5d Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 10:55:07 +0100
Subject: [PATCH 30/77] P prediction uses 4 tap filters

---
 libavcodec/hevc.c          |  50 ++--
 libavcodec/rpi_shader.c    | 631 ++++++++++++++++++++++-----------------------
 libavcodec/rpi_shader.h    |  10 +-
 libavcodec/rpi_shader.qasm |  43 +--
 4 files changed, 344 insertions(+), 390 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index b75f865..ed2a47e 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -63,15 +63,15 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
 
 // TODO Chroma only needs 4 taps
-static uint32_t rpi_filter_coefs[8][2] = {
-        { ENCODE_COEFFS(  0,  0,  0,  64), ENCODE_COEFFS(   0,   0,  0,  0 ) },
-        { ENCODE_COEFFS(  0,  0, -2,  58), ENCODE_COEFFS(  10,  -2,  0,  0 ) }, 
-        { ENCODE_COEFFS(  0,  0, -4,  54), ENCODE_COEFFS(  16,  -2,  0,  0 ) },
-        { ENCODE_COEFFS(  0,  0, -6,  46), ENCODE_COEFFS(  28,  -4,  0,  0 ) },
-        { ENCODE_COEFFS(  0,  0, -4,  36), ENCODE_COEFFS(  36,  -4,  0,  0 ) },
-        { ENCODE_COEFFS(  0,  0, -4,  28), ENCODE_COEFFS(  46,  -6,  0,  0 ) },
-        { ENCODE_COEFFS(  0,  0, -2,  16), ENCODE_COEFFS(  54,  -4,  0,  0 ) },
-        { ENCODE_COEFFS(  0,  0, -2,  10), ENCODE_COEFFS(  58,  -2,  0,  0 ) }
+static uint32_t rpi_filter_coefs[8][1] = {
+        { ENCODE_COEFFS(   0,  64,   0,   0) },
+        { ENCODE_COEFFS(  -2,  58,  10,  -2) }, 
+        { ENCODE_COEFFS(  -4,  54,  16,  -2) },
+        { ENCODE_COEFFS(  -6,  46,  28,  -4) },
+        { ENCODE_COEFFS(  -4,  36,  36,  -4) },
+        { ENCODE_COEFFS(  -4,  28,  46,  -6) },
+        { ENCODE_COEFFS(  -2,  16,  54,  -4) },
+        { ENCODE_COEFFS(  -2,  10,  58,  -2) }
 };
 
 static uint32_t get_vc_address(AVBufferRef *bref) {
@@ -1991,16 +1991,16 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
                       *u++ = rpi_filter_coefs[_mx][0];
-                      *u++ = rpi_filter_coefs[_mx][1];
+                      u++;
                       *u++ = rpi_filter_coefs[_my][0];
-                      *u++ = rpi_filter_coefs[_my][1];
+                      u++;
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
@@ -2048,16 +2048,16 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
                       *u++ = rpi_filter_coefs[_mx][0];
-                      *u++ = rpi_filter_coefs[_mx][1];
+                      u++;
                       *u++ = rpi_filter_coefs[_my][0];
-                      *u++ = rpi_filter_coefs[_my][1];
+                      u++;
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
@@ -2112,29 +2112,29 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b0;
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);  
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       *u++ = rpi_filter_coefs[_mx][0];
-                      *u++ = rpi_filter_coefs[_mx][1];
+                      u++;
                       *u++ = rpi_filter_coefs[_my][0];
-                      *u++ = rpi_filter_coefs[_my][1];
+                      u++;
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]); // TODO this will become unused once we have a dedicated pass0 filter
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                       
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 3 + start_x;
-                      u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 3 + start_y;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 1 + start_x;
+                      u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 1 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
                       *u++ = rpi_filter_coefs[_mx2][0];
-                      *u++ = rpi_filter_coefs[_mx2][1];
+                      u++;
                       *u++ = rpi_filter_coefs[_my2][0];
-                      *u++ = rpi_filter_coefs[_my2][1];
+                      u++;
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 77cca46..c8d0728 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -116,8 +116,8 @@ unsigned int rpi_shader[] = {
 /* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
 /* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
 /* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002e8] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x000002f0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x000002e8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000002f0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
 /* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
 /* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
 /* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
@@ -128,338 +128,315 @@ unsigned int rpi_shader[] = {
 /* [0x00000330] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
 /* [0x00000338] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
 /* [0x00000340] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000348] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000350] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000358] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000360] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000368] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000370] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000378] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000380] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000388] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000390] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000398] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000003a0] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x000003a8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000003b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000003b8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000348] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000350] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000358] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000360] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000368] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000370] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000378] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000380] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x000003c0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000003c8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000003d0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000003d8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003e0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003e8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003f0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003f8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000400] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000408] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000410] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000418] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000420] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000428] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000430] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000438] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000440] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000448] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000450] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000458] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000460] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000468] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000470] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000478] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000480] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000488] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000490] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000498] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x000004a0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x000004a8] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x000004b0] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x000004b8] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x000004c0] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x000004c8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x000004d0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000004d8] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x000004e0] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004e8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x000004f0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x000004f8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000500] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x00000508] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x00000510] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000518] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000520] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000528] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000530] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000538] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000540] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000548] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000550] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000558] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x00000560] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000568] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x00000570] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000578] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000580] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000588] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000590] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000598] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000005a0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000005a8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000005b0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x000005b8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000005c0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000388] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000390] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000398] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000003a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000003d0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000003d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000003e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000003f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000003f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000400] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000408] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000410] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000418] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000420] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000428] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000430] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000438] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000440] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+/* [0x00000448] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000450] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x00000458] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x00000460] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000468] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000470] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000478] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000480] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000488] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000490] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000498] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000004a0] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x000004a8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000004b0] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x000004b8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000004c0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000004c8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000004d0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004d8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000004e0] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000004e8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000004f0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000004f8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000500] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000508] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x000005c8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000005d0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000005d8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000005e0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000005e8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000005f0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000005f8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000600] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000608] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000610] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000618] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000620] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x00000628] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000630] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000638] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000640] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000648] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000650] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000658] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000660] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000668] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000670] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000678] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000680] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000688] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000690] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000698] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000006b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000006d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000006e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000006f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000006f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000700] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000708] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000710] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000718] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000720] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000510] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000518] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000520] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000528] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000530] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000538] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000540] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000548] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000550] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000558] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000560] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000568] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x00000570] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000578] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000580] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000588] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000590] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000598] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x000005a0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x000005a8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000005b0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000005b8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000005c0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000005c8] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x000005d0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005d8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005e0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005e8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005f0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000005f8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000600] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000608] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000610] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000618] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000620] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000628] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000630] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000638] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000640] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000648] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000650] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000658] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000668] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000728] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000730] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000738] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000740] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000748] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000750] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000758] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000760] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000768] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000770] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000778] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000780] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000788] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000790] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000798] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000007a0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000007a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000007b0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000007b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000007c0] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x000007c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x000007d0] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x000007d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x000007e0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x000007e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x000007f0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x000007f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000800] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000808] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000810] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000818] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000820] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000828] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000830] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000838] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000840] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000848] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000850] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x00000858] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x00000860] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000868] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x00000870] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x00000878] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000880] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000888] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000890] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000898] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x000008a0] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x000008a8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000008b0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000008b8] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x000008c0] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
-/* [0x000008c8] */ 0x009e7000, 0x100009e7, // nop
-/* [0x000008d0] */ 0x009e7000, 0x100009e7, // nop
-/* [0x000008d8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000008e0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000008e8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000008f0] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000008f8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000900] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000908] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000910] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000918] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000670] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000678] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000680] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000688] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000690] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000698] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000006a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000006a8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000006b0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000006b8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000006c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000006c8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000006d0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000006d8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000006e0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000006e8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000006f0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000006f8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000700] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000708] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000710] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000718] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000720] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000728] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000730] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000738] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000740] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000748] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000750] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000758] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000760] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000768] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000770] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000778] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000780] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000788] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000790] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000798] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x000007a0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x000007a8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x000007b0] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x000007b8] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x000007c0] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x000007c8] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x000007d0] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x000007d8] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x000007e0] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x000007e8] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x000007f0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000007f8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000800] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000808] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
+/* [0x00000810] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000818] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000820] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000828] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000830] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000838] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000840] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000848] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000850] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000858] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000860] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b
-/* [0x00000920] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000928] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000930] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000938] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000940] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000948] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000950] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000958] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000960] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000968] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000970] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000978] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000980] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000988] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000990] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000998] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000009a0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000009a8] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x000009b0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x000009b8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000009c0] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x000009c8] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x000009d0] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x000009d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000009e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000009e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000009f0] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x000009f8] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000a00] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000a08] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a10] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a18] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a20] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000a28] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a30] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a38] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a40] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000a48] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a50] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a58] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000a60] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000a68] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a70] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a78] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000a80] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000a88] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000a90] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000a98] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000868] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000870] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000878] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000880] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000888] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000890] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000898] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000008a0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000008a8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000008b0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000008b8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000008c0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000008c8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000008d0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000008d8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000008e0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000008e8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000008f0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x000008f8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000900] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000908] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000910] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000918] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000920] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000928] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000930] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000938] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000940] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000948] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000950] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000958] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000960] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000968] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000970] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000978] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000980] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000988] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000990] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000998] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000009a0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000009a8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000009b0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000009b8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000009c0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000009c8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x000009d0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000009d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000009e0] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x00000aa0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000aa8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000ab0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000ab8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000ac0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000ac8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000ad0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000ad8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000ae0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000ae8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000af0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000af8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000b00] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000b08] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000b10] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000b18] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000b20] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000b28] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000b30] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000b38] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000b40] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000b48] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000b50] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000b58] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000b60] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000b68] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000b70] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000b78] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000b80] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000b88] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000b90] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000b98] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000ba0] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000ba8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000bb0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000bb8] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000bc0] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000bc8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x00000bd0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x00000bd8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000be0] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x00000be8] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x00000bf0] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000bf8] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000c00] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000c08] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000c10] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000c18] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000c20] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000c28] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000c30] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000c38] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x00000c40] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x00000c48] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000c50] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000c58] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000c60] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000c68] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000c70] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000c78] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000c80] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000c88] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000c90] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000c98] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000ca0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000ca8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000009e8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000009f0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000009f8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000a00] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000a08] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000a10] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000a18] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000a20] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000a28] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000a30] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000a38] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000a40] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000a48] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000a50] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000a58] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000a60] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000a68] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000a70] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000a78] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000a80] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00000a88] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00000a90] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00000a98] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00000aa0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00000aa8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00000ab0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00000ab8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000ac0] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000ac8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000ad0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000ad8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000ae0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000ae8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000af0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000af8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000b00] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000b08] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000b10] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x00000b18] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x00000b20] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000b28] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x00000b30] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x00000b38] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000b40] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000b48] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000b50] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000b58] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000b60] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000b68] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000b70] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000b78] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000b80] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x00000b88] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000b90] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000b98] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000ba0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000ba8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000bb0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000bb8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000bc0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000bc8] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000bd0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000bd8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000be0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000be8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000bf0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000cb0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000cb8] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000cc0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000cc8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000cd0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000cd8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ce0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000ce8] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000cf0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000bf8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000c00] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000c08] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000c10] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000c18] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000c20] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000c28] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000c30] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000c38] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000cf8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000d00] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000d08] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000d10] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000d18] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000d20] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d28] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d30] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d38] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d40] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000d58] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000d60] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000d68] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000c40] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000c48] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000c50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000c58] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000c60] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000c68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000c70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000c78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000c80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000c88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000c90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000c98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ca0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000ca8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000cb0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 6562fa9..1bf7a68 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -5,10 +5,10 @@ extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
 #define mc_filter_uv (rpi_shader + 152)
-#define mc_filter_uv_b0 (rpi_shader + 370)
-#define mc_filter_uv_b (rpi_shader + 584)
-#define mc_exit (rpi_shader + 812)
-#define mc_interrupt_exit8 (rpi_shader + 830)
-#define mc_end (rpi_shader + 860)
+#define mc_filter_uv_b0 (rpi_shader + 324)
+#define mc_filter_uv_b (rpi_shader + 538)
+#define mc_exit (rpi_shader + 766)
+#define mc_interrupt_exit8 (rpi_shader + 784)
+#define mc_end (rpi_shader + 814)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 23d674e..9bbd9b5 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -16,8 +16,8 @@
 # ra19                                          next ra17
 #
 # rb16                                          pitch
-# rb17                                          height + 5
-# rb18                                          height + 7
+# rb17                                          height + 1
+# rb18                                          height + 3
 # rb19                                          next ra16
 #
 # ra20                                          1
@@ -214,8 +214,8 @@ mov r0, unif
 shr r1, r0, r2 # Extract width
 sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
 and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
+add rb17, r0, 1
+add rb18, r0, 3
 shl r0, r0, 7
 add r0, r0, r1 # Combine width and height of destination area
 shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
@@ -230,18 +230,11 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
 asr ra2, r0, rb23;      mul24 r0, r0, ra22
 asr ra1, r0, rb23;      mul24 r0, r0, ra22
 asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
+                        mov r0, unif
 asr rb11, r0, rb23;     mul24 r0, r0, ra22
 asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
 asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-asr rb12, r0, rb23  
 
 # r2 is elem_num
 # r3 is loop counter
@@ -283,26 +276,14 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
 add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
 add r0, r2, r3
 
 mov r3, rb31
 
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
 mov ra12, ra13
 mov ra13, ra14
 
-sub.setf -, r3, 8 ; mov r1, ra22
+sub.setf -, r3, 4 ; mov r1, ra22
 
 # apply horizontal filter         
 brr.anyn -, r:uvloop
@@ -312,14 +293,10 @@ nop                     ; nop  # Delay slot 3 (TODO move more of the context scr
  
 # apply vertical filter and write to VPM
 
-nop                     ; mul24 r1, ra14, rb14
-nop                     ; mul24 r0, ra13, rb13
-add r1, r1, r0          ; mul24 r0, ra12, rb12
-add r1, r1, r0          ; mul24 r0, ra11, rb11
-add r1, r1, r0          ; mul24 r0, ra10, rb10
-add r1, r1, r0          ; mul24 r0, ra9, rb9
-add r1, r1, r0          ; mul24 r0, ra8, rb8
-add r1, r1, r0          ; mul24 r0, ra15, rb15
+nop                     ; mul24 r1, ra14, rb10
+nop                     ; mul24 r0, ra13, rb9
+add r1, r1, r0          ; mul24 r0, ra12, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb11
 add r1, r1, r0          ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
 asr r1, r1, 14
-- 
1.9.1


From ce5687c17e129a2e55f28f39d2d333c11bd0c194 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 11:03:51 +0100
Subject: [PATCH 31/77] Optimised B0 pass

---
 libavcodec/rpi_shader.c    | 424 +++++++++++++++++++++------------------------
 libavcodec/rpi_shader.h    |   8 +-
 libavcodec/rpi_shader.qasm |  43 +----
 3 files changed, 212 insertions(+), 263 deletions(-)

diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index c8d0728..1f63ee0 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -204,239 +204,215 @@ unsigned int rpi_shader[] = {
 /* [0x00000580] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
 /* [0x00000588] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
 /* [0x00000590] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000598] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x000005a0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000598] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000005a0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
 /* [0x000005a8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
 /* [0x000005b0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
 /* [0x000005b8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
 /* [0x000005c0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000005c8] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x000005d0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005d8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005e0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005e8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005f0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000005f8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000600] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000608] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000610] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000618] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000620] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000628] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000630] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000638] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000640] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000648] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000650] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000658] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000668] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000005c8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005d0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005d8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005e0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005e8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000005f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005f8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000600] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000608] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000610] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000618] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000620] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000628] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000670] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000678] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000680] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000688] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000690] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000698] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000006a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000006a8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000006b0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000006b8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000006c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000006c8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000006d0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000006d8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000006e0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000006e8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000006f0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000006f8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000700] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000708] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000710] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000718] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000720] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000728] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000730] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000738] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000740] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000748] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000750] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000758] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000760] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000768] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000770] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000778] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000780] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000788] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000790] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000798] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x000007a0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x000007a8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x000007b0] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x000007b8] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x000007c0] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x000007c8] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x000007d0] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x000007d8] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x000007e0] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x000007e8] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x000007f0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000007f8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000800] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000808] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
-/* [0x00000810] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000818] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000820] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000828] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000830] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000838] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000840] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000848] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000850] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000858] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000860] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000630] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000638] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000640] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000648] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000650] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000658] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000660] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000668] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000670] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000678] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000680] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000688] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000690] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000698] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000006a0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000006a8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000006b0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000006b8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000006c0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000006c8] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x000006d0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x000006d8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x000006e0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000006e8] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+/* [0x000006f0] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x000006f8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x00000700] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x00000708] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000710] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000718] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000720] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000728] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000730] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000738] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000740] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000748] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
+/* [0x00000750] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000758] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000760] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000768] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000770] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000778] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000780] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000788] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000790] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000798] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000007a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b
-/* [0x00000868] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000870] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000878] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000880] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000888] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000890] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000898] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000008a0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000008a8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000008b0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000008b8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000008c0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000008c8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000008d0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000008d8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000008e0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000008e8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000008f0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x000008f8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000900] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000908] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000910] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000918] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000920] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000928] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000930] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000938] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000940] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000948] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000950] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000958] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000960] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000968] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000970] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000978] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000980] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000988] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000990] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000998] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000009a0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000009a8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000009b0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000009b8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000009c0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000009c8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x000009d0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000009d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000009e0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000007a8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000007b0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000007b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000007c0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000007c8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000007d0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000007d8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000007e0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000007e8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000007f0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000007f8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000800] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000808] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000810] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000830] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000838] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000858] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000860] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000880] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+/* [0x00000888] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000890] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000898] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000008b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000008d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000008f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000900] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000908] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+/* [0x00000910] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000918] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000920] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x000009e8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000009f0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000009f8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000a00] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000a08] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000a10] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000a18] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000a20] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000a28] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000a30] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000a38] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000a40] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000a48] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000a50] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000a58] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000a60] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000a68] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000a70] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000a78] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000a80] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00000a88] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00000a90] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00000a98] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00000aa0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00000aa8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00000ab0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00000ab8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000ac0] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000ac8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000ad0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000ad8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000ae0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000ae8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000af0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000af8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000b00] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000b08] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000b10] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x00000b18] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x00000b20] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000b28] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x00000b30] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x00000b38] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000b40] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000b48] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000b50] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000b58] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000b60] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000b68] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000b70] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000b78] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000b80] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x00000b88] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x00000b90] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000b98] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000ba0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000ba8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000bb0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000bb8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000bc0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000bc8] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000bd0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000bd8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000be0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000be8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000bf0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000928] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000930] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000938] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000940] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000948] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000950] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000958] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000960] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000968] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000970] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000978] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000980] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000988] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000990] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000998] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000009a0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000009a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000009b0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000009b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000009c0] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x000009c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x000009d0] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x000009d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x000009e0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x000009e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x000009f0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x000009f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00000a00] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000a08] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000a10] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+/* [0x00000a18] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00000a20] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00000a28] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00000a30] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000a38] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000a40] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+/* [0x00000a48] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000a50] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x00000a58] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x00000a60] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x00000a68] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+/* [0x00000a70] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+/* [0x00000a78] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+/* [0x00000a80] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+/* [0x00000a88] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+/* [0x00000a90] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+/* [0x00000a98] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+/* [0x00000aa0] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+/* [0x00000aa8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000ab0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000ab8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000ac0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x00000ac8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000ad0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000ad8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000ae0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000ae8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000af0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000af8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000b00] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000b08] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000b10] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000b18] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000b20] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000b28] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000b30] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000bf8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000c00] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000c08] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000c10] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000c18] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000c20] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000c28] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000c30] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000c38] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000b38] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000b40] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000b48] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000b50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000b58] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000b60] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000b68] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000b70] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000b78] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000c40] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000c48] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000c50] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000c58] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000c60] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000c68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000c70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000c78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000c80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000c88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000c90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000c98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ca0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000ca8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000cb0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000b80] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000b88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000b90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000b98] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ba0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ba8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000bb0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000bb8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000bc0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000bc8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000bd0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000bd8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000be0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000be8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000bf0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 1bf7a68..cb74887 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -6,9 +6,9 @@ extern unsigned int rpi_shader[];
 #define mc_setup_uv (rpi_shader + 0)
 #define mc_filter_uv (rpi_shader + 152)
 #define mc_filter_uv_b0 (rpi_shader + 324)
-#define mc_filter_uv_b (rpi_shader + 538)
-#define mc_exit (rpi_shader + 766)
-#define mc_interrupt_exit8 (rpi_shader + 784)
-#define mc_end (rpi_shader + 814)
+#define mc_filter_uv_b (rpi_shader + 490)
+#define mc_exit (rpi_shader + 718)
+#define mc_interrupt_exit8 (rpi_shader + 736)
+#define mc_end (rpi_shader + 766)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 9bbd9b5..26f1c13 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -357,15 +357,13 @@ mov r0, unif
 shr r1, r0, r2 # Extract width
 sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
 and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
+add rb17, r0, 1
+add rb18, r0, 3
 shl r0, r0, 7
 add r0, r0, r1 # Combine width and height of destination area
 shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
 add rb26, r0, rb27
 
-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
-
 # get filter coefficients
 
 mov r0, unif
@@ -373,18 +371,11 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
 asr ra2, r0, rb23;      mul24 r0, r0, ra22
 asr ra1, r0, rb23;      mul24 r0, r0, ra22
 asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
+                        mov r0, unif
 asr rb11, r0, rb23;     mul24 r0, r0, ra22
 asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
 asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-asr rb12, r0, rb23  
 
 # r2 is elem_num
 # r3 is loop counter
@@ -426,26 +417,14 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
 add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
 add r0, r2, r3
 
 mov r3, rb31
 
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
 mov ra12, ra13
 mov ra13, ra14
 
-sub.setf -, r3, 8 ; mov r1, ra22
+sub.setf -, r3, 4 ; mov r1, ra22
 
 # apply horizontal filter         
 brr.anyn -, r:uvloop_b0
@@ -455,18 +434,12 @@ nop                     ; nop  # Delay slot 3 (TODO move more of the context scr
  
 # apply vertical filter and write to VPM
 
-nop                     ; mul24 r1, ra14, rb14
-nop                     ; mul24 r0, ra13, rb13
-add r1, r1, r0          ; mul24 r0, ra12, rb12
-add r1, r1, r0          ; mul24 r0, ra11, rb11
-add r1, r1, r0          ; mul24 r0, ra10, rb10
-add r1, r1, r0          ; mul24 r0, ra9, rb9
-add r1, r1, r0          ; mul24 r0, ra8, rb8
-add r1, r1, r0          ; mul24 r0, ra15, rb15
+nop                     ; mul24 r1, ra14, rb10
+nop                     ; mul24 r0, ra13, rb9
+add r1, r1, r0          ; mul24 r0, ra12, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb11
 add r1, r1, r0          ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-#asr r1, r1, 14
-#add r1, r1, ra21
 brr.anyn -, r:uvloop_b0
 asr vpm, r1, 14        # Delay 1 shifts down by shift2=6, but results are still in 16bit precision TODO may be able to avoid the mul24 and use more delay slots
 nop                    # Delay 2
-- 
1.9.1


From 6bbb5df80c069d8fe2ab11907074a285f62b99b6 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 11:12:43 +0100
Subject: [PATCH 32/77] Optimised B pass

---
 libavcodec/rpi_shader.c    | 202 ++++++++++++++++++++-------------------------
 libavcodec/rpi_shader.h    |   6 +-
 libavcodec/rpi_shader.qasm |  43 ++--------
 3 files changed, 101 insertions(+), 150 deletions(-)

diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 1f63ee0..4e6c5ea 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -289,8 +289,8 @@ unsigned int rpi_shader[] = {
 /* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
 /* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
 /* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000830] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000838] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000830] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000838] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
 /* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
 /* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
 /* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
@@ -299,120 +299,96 @@ unsigned int rpi_shader[] = {
 /* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
 /* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
 /* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000880] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000888] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000890] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000898] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000008b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000008d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000008f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000900] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000908] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
-/* [0x00000910] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000918] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000920] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000880] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000888] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000890] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000898] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000008a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000008b0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008b8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008c0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008c8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000008d0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008e0] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x00000928] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000930] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000938] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000940] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000948] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000950] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000958] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000960] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000968] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000970] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000978] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000980] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000988] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000990] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000998] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000009a0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000009a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000009b0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000009b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000009c0] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x000009c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x000009d0] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x000009d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x000009e0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x000009e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x000009f0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x000009f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00000a00] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000a08] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000a10] */ 0x15267d80, 0x10020227, // mov ra8, ra9
-/* [0x00000a18] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00000a20] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00000a28] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00000a30] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000a38] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000a40] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
-/* [0x00000a48] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000a50] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x00000a58] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x00000a60] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000a68] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
-/* [0x00000a70] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
-/* [0x00000a78] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
-/* [0x00000a80] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
-/* [0x00000a88] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
-/* [0x00000a90] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
-/* [0x00000a98] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
-/* [0x00000aa0] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
-/* [0x00000aa8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000ab0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000ab8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000ac0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x00000ac8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x00000ad0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000ad8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000ae0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000ae8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000af0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000af8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000b00] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000b08] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000b10] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000b18] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000b20] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000b28] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000b30] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008e8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000008f0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000008f8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000900] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000908] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000910] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000918] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000920] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000928] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000930] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000938] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000940] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000948] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000950] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000958] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000960] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000968] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000970] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000978] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000980] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000988] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000990] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000998] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000009a0] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+/* [0x000009a8] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000009b0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x000009b8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x000009c0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x000009c8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000009d0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000009d8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000009e0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000009e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000009f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000009f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000a00] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x00000a08] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000a10] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000a18] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000a20] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000a28] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000a30] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000a38] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a40] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000a48] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000a50] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000a60] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000b38] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000b40] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000b48] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000b50] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000b58] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000b60] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000b68] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000b70] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000b78] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a78] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a80] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a98] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000aa0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000ab0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000b80] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000b88] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000b90] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000b98] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ba0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ba8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000bb0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000bb8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000bc0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000bc8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000bd0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000bd8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000be0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000be8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000bf0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000ac0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ad8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ae0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b10] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b18] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b20] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000b28] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000b30] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index cb74887..53da629 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -7,8 +7,8 @@ extern unsigned int rpi_shader[];
 #define mc_filter_uv (rpi_shader + 152)
 #define mc_filter_uv_b0 (rpi_shader + 324)
 #define mc_filter_uv_b (rpi_shader + 490)
-#define mc_exit (rpi_shader + 718)
-#define mc_interrupt_exit8 (rpi_shader + 736)
-#define mc_end (rpi_shader + 766)
+#define mc_exit (rpi_shader + 670)
+#define mc_interrupt_exit8 (rpi_shader + 688)
+#define mc_end (rpi_shader + 718)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 26f1c13..ab1ec62 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -491,8 +491,8 @@ mov r0, unif
 shr r1, r0, r2 # Extract width
 sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
 and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
+add rb17, r0, 1
+add rb18, r0, 3
 shl r0, r0, 7
 
 # r0 is currently height<<7
@@ -508,8 +508,6 @@ add rb26, r0, rb27
 # In a B frame, so also set up VPM read (reading back 16bit precision)
 add vr_setup, r3, rb21
 
-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
-
 # get filter coefficients
 
 mov r0, unif
@@ -517,18 +515,11 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
 asr ra2, r0, rb23;      mul24 r0, r0, ra22
 asr ra1, r0, rb23;      mul24 r0, r0, ra22
 asr ra0, r0, rb23;      mov r0, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
+                        mov r0, unif
 asr rb11, r0, rb23;     mul24 r0, r0, ra22
 asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-asr rb15, r0, rb23;     mul24 r0, r0, ra22
-asr rb14, r0, rb23;     mul24 r0, r0, ra22
-asr rb13, r0, rb23;     mul24 r0, r0, ra22
-asr rb12, r0, rb23  
+asr rb8, r0, rb23;      mov r0, unif 
 
 # r2 is elem_num
 # r3 is loop counter
@@ -570,26 +561,14 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
 add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
 add r0, r2, r3
 
 mov r3, rb31
 
-mov ra8, ra9
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
 mov ra12, ra13
 mov ra13, ra14
 
-sub.setf -, r3, 8 ; mov r1, ra22
+sub.setf -, r3, 4 ; mov r1, ra22
 # apply horizontal filter         
 brr.anyn -, r:uvloop_b
 mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
@@ -598,14 +577,10 @@ nop                     ; nop    # TODO improve use of delay slots
  
 # apply vertical filter and write to VPM
 
-nop                     ; mul24 r1, ra14, rb14
-nop                     ; mul24 r0, ra13, rb13
-add r1, r1, r0          ; mul24 r0, ra12, rb12
-add r1, r1, r0          ; mul24 r0, ra11, rb11
-add r1, r1, r0          ; mul24 r0, ra10, rb10
-add r1, r1, r0          ; mul24 r0, ra9, rb9
-add r1, r1, r0          ; mul24 r0, ra8, rb8
-add r1, r1, r0          ; mul24 r0, ra15, rb15
+nop                     ; mul24 r1, ra14, rb10
+nop                     ; mul24 r0, ra13, rb9
+add r1, r1, r0          ; mul24 r0, ra12, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb11
 add r1, r1, r0          ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
 asr r1, r1, 14          # shift2=6
-- 
1.9.1


From 0ea8d84836923afe67ede0caa3b5bd40e902982d Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 11:17:09 +0100
Subject: [PATCH 33/77] Used P delay slots more efficiently

---
 libavcodec/rpi_shader.c    | 437 ++++++++++++++++++++++-----------------------
 libavcodec/rpi_shader.h    |  10 +-
 libavcodec/rpi_shader.qasm |  19 +-
 3 files changed, 228 insertions(+), 238 deletions(-)

diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 4e6c5ea..a1af4e3 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -156,239 +156,236 @@ unsigned int rpi_shader[] = {
 /* [0x00000408] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
 /* [0x00000410] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 /* [0x00000418] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000420] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000428] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000430] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000420] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000428] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000430] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
 /* [0x00000438] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000440] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
-/* [0x00000448] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000450] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x00000458] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x00000460] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000468] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000470] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000478] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000480] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000488] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000490] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000498] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000004a0] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x000004a8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004b0] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x000004b8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000004c0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000004c8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000004d0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000004d8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000004e0] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000004e8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000004f0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000004f8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000500] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000508] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000440] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000448] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000450] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000458] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000460] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000468] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000470] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000478] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000480] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000488] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x00000490] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000498] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x000004a0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000004a8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000004b0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000004b8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004c0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000004c8] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000004d0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000004d8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000004e0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000004e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x00000510] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000518] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000520] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000528] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000530] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000538] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000540] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000548] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000550] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000558] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000560] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000568] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x00000570] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000578] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000580] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000588] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000590] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000598] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000005a0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000005a8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000005b0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000005b8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000005c0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000005c8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005d0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005d8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005e0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005e8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000005f0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005f8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000600] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000608] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000610] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000618] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000620] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000628] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000004f8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000500] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000508] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000510] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000518] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000520] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000528] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000530] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000538] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000540] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000548] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000550] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x00000558] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000560] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000568] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000570] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000578] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000580] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000588] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000590] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000598] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000005a0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000005a8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000005b0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005b8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005c0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005c8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005d0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000005d8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000005e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000005f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000600] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000608] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000610] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000630] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000638] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000640] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000648] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000650] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000658] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000660] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000668] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000670] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000678] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000680] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000688] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000690] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000698] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000006a0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000006a8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000006b0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000006b8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000006c0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000006c8] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x000006d0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x000006d8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x000006e0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000006e8] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
-/* [0x000006f0] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x000006f8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x00000700] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x00000708] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x00000710] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000718] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000720] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000728] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000730] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000738] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000740] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000748] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
-/* [0x00000750] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000758] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000760] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000768] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000770] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000778] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000780] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000788] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000790] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000798] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000007a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000618] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000620] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000628] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000630] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000638] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000640] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000648] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000650] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000658] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000660] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000668] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000670] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000678] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000680] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000688] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000690] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000698] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000006a0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000006a8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000006b0] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x000006b8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x000006c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x000006c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000006d0] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+/* [0x000006d8] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x000006e0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x000006e8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x000006f0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x000006f8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000700] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000708] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000710] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000718] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000720] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000728] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000730] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
+/* [0x00000738] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000740] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000748] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000750] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000758] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000760] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000768] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000770] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000778] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000780] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000788] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b
-/* [0x000007a8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000007b0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000007b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000007c0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000007c8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000007d0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000007d8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000007e0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000007e8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000007f0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000007f8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000800] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000808] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000810] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000830] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000838] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000858] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000860] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000880] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000888] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000890] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000898] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000008a8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000008b0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008b8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008c0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008c8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000008d0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000008e0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000790] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000798] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000007a0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000007a8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000007b0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000007b8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000007c0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000007c8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000007d0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000007d8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000007e0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000007e8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000007f0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000007f8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000800] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000808] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000810] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000818] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000820] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000828] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000830] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000838] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000840] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000848] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000850] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000858] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000860] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000868] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000870] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000878] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000880] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000888] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000890] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000898] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008a0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008a8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008b0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000008b8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000008c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008c8] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x000008e8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000008f0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000008f8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000900] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000908] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000910] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000918] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000920] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000928] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000930] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000938] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000940] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000948] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000950] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000958] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000960] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000968] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000970] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000978] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000980] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000988] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000990] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000998] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000009a0] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
-/* [0x000009a8] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000009b0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x000009b8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x000009c0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x000009c8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000009d0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000009d8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000009e0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000009e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000009f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000009f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000a00] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x00000a08] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x00000a10] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000a18] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000a20] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000a28] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000a30] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000a38] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a40] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000a48] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000a50] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000a60] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008d0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000008d8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000008e0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000008e8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000008f0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000008f8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000900] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000908] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000910] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000918] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000920] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000928] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000930] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000938] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000940] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000948] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000950] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000958] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000960] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000968] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+/* [0x00000970] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+/* [0x00000978] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00000980] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000988] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+/* [0x00000990] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000998] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+/* [0x000009a0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+/* [0x000009a8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+/* [0x000009b0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000009b8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000009c0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000009c8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000009d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000009d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000009e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000009e8] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x000009f0] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x000009f8] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000a00] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000a08] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000a10] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000a18] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000a20] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a28] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000a30] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000a38] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000a40] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000a48] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000a50] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a58] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000a78] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a80] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a60] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a68] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a70] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a98] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000aa0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000ab0] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a90] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000a98] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000aa0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000ac0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000aa8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000ab0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ad8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ae0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ad0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b10] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b18] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b20] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000b28] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000b30] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000b08] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000b10] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000b18] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 53da629..1fb3e37 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -5,10 +5,10 @@ extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
 #define mc_filter_uv (rpi_shader + 152)
-#define mc_filter_uv_b0 (rpi_shader + 324)
-#define mc_filter_uv_b (rpi_shader + 490)
-#define mc_exit (rpi_shader + 670)
-#define mc_interrupt_exit8 (rpi_shader + 688)
-#define mc_end (rpi_shader + 718)
+#define mc_filter_uv_b0 (rpi_shader + 318)
+#define mc_filter_uv_b (rpi_shader + 484)
+#define mc_exit (rpi_shader + 664)
+#define mc_interrupt_exit8 (rpi_shader + 682)
+#define mc_end (rpi_shader + 712)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index ab1ec62..846d08e 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -268,6 +268,7 @@ add t0s, ra_x2_base, r2
 
 mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 
+# apply horizontal filter         
 nop                  ; mul24 r2, r0, ra0
 nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
 nop                  ; mul24      r3, ra1 << 1, r0 << 1
@@ -276,20 +277,12 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
 add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r0, r2, r3
-
-mov r3, rb31
-
-mov ra12, ra13
-mov ra13, ra14
-
-sub.setf -, r3, 4 ; mov r1, ra22
-
-# apply horizontal filter         
+add r0, r2, r3       ; mov r3, rb31
+sub.setf -, r3, 4    ; mov ra12, ra13
 brr.anyn -, r:uvloop
-mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
-asr ra15, r0, 8         ; nop
-nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
+mov ra13, ra14       # Delay slot 1
+mov ra14, ra15       # Delay slot 2
+mov ra15, r0         # Delay slot 3
  
 # apply vertical filter and write to VPM
 
-- 
1.9.1


From 7f0fbb0d4163c9edf74c4ad003f8407ede5a1ac0 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 11:22:25 +0100
Subject: [PATCH 34/77] Improved use of delay slots

---
 libavcodec/rpi_shader.c    | 503 ++++++++++++++++++++++-----------------------
 libavcodec/rpi_shader.h    |  10 +-
 libavcodec/rpi_shader.qasm |  41 ++--
 3 files changed, 265 insertions(+), 289 deletions(-)

diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index a1af4e3..c498f28 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -122,270 +122,263 @@ unsigned int rpi_shader[] = {
 /* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
 /* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
 /* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000318] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
-/* [0x00000320] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000328] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000330] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000338] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000340] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000348] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000350] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000358] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000360] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000368] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000370] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000378] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000380] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000340] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000348] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000350] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000358] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000360] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000368] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000370] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000378] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x00000388] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000390] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000398] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000003a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000003d0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000003d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000003e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000003e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000003f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000003f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000400] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000408] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000410] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000418] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000420] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000428] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000430] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000438] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000440] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000448] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000450] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000458] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000460] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000468] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000470] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000478] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000480] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000488] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x00000490] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000498] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x000004a0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000004a8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000004b0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000004b8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000004c0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000004c8] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000004d0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000004d8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000004e0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x000004e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000004f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000380] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000388] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000390] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000398] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003a0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003a8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003b8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003c0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000003c8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000003d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000003e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000003e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000003f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000003f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000400] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000408] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000410] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000418] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000420] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000428] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000430] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000438] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000440] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000448] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000450] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000458] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000460] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000468] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000470] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000478] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000480] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x00000488] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000490] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x00000498] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000004a0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000004a8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000004b0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004b8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000004c0] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000004c8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000004d0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000004d8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000004e0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004e8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x000004f8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000500] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000508] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000510] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000518] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000520] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000528] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000530] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000538] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000540] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000548] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000550] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x00000558] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000560] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000568] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000570] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000578] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000580] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000588] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000590] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000598] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000005a0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000005a8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000005b0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005b8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005c0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005c8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005d0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000005d8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000005e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000005f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000600] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000608] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000610] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000004f0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000004f8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000500] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000508] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000510] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000518] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000520] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000528] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000530] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000538] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000540] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000548] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x00000550] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000558] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000560] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000568] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000570] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000578] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000580] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000588] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000590] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000598] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000005a0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000005a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005b0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005b8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005c0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005c8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000005d0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005d8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000005e0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000005e8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005f0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000005f8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000600] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000608] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000618] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000620] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000628] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000630] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000638] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000640] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000648] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000650] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000658] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000660] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000668] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000670] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000678] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000680] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000688] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000690] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000698] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000006a0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000006a8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000006b0] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x000006b8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x000006c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x000006c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000006d0] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
-/* [0x000006d8] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x000006e0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x000006e8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x000006f0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x000006f8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000700] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000708] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000710] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000718] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000720] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000728] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000730] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
-/* [0x00000738] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000740] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000748] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000750] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000758] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000760] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000768] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000770] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000778] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000780] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000788] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000610] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000618] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000620] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000628] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000630] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000638] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000640] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000648] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000650] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000658] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000668] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000670] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000678] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000680] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000688] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000690] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000698] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000006a0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000006a8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x000006b0] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x000006b8] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x000006c0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000006c8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x000006d0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000006d8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000006e0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000006e8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000006f0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000006f8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000700] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+/* [0x00000708] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000710] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+/* [0x00000718] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000720] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000728] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000730] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000738] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000740] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000748] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000750] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000758] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000760] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000768] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b
-/* [0x00000790] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000798] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000007a0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000007a8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000007b0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000007b8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000007c0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000007c8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000007d0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000007d8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000007e0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000007e8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000007f0] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000007f8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000800] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000808] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000810] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000818] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000820] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000828] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000830] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000838] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000840] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000848] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000850] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000858] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000860] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000868] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000870] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000878] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000880] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000888] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000890] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000898] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008a0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008a8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008b0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000008b8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000008c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000008c8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000770] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000778] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000780] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000788] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000790] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000798] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000007a0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000007a8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000007b0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000007b8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000007c0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000007c8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000007d0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000007d8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000007e0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000007e8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000007f0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000007f8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000800] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000808] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000810] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000818] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000820] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000828] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000830] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000838] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000840] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000848] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000850] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000858] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000860] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000868] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000870] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000878] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000880] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000888] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000890] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000898] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000008a0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008a8] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x000008d0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000008d8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000008e0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000008e8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000008f0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000008f8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000900] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000908] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000910] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000918] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000920] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000928] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000930] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000938] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000940] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000948] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000950] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000958] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000960] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000968] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
-/* [0x00000970] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
-/* [0x00000978] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00000980] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000988] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
-/* [0x00000990] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000998] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
-/* [0x000009a0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
-/* [0x000009a8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
-/* [0x000009b0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000009b8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000009c0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000009c8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000009d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000009d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000009e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000009e8] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x000009f0] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x000009f8] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000a00] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000a08] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000a10] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000a18] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000a20] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a28] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000a30] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000a38] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000a40] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000a48] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000a50] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a58] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008b0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000008b8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000008c0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000008c8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000008d0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000008d8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000008e0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000008e8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000008f0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000008f8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000900] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000908] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000910] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000918] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000920] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000928] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000930] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000938] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000940] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000948] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000950] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000958] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000960] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000968] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000970] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000978] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000980] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000988] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000990] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000998] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000009a0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000009a8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000009b0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x000009b8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x000009c0] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000009c8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x000009d0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000009d8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000009e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000009e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000009f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000009f8] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000a08] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000a10] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000a18] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a20] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000a60] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a68] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000a70] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a28] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a30] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a38] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a40] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a48] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a58] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000a60] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a68] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_interrupt_exit8
+/* [0x00000a70] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
 /* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a90] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000a98] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000aa0] */ 0x009e7000, 0x100009e7, // nop        ; nop
-// ::mc_interrupt_exit8
-/* [0x00000aa8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000ab0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ad0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b08] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000b10] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000b18] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000aa0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000aa8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ab0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ab8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ac0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ac8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ad0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000ad8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000ae0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 1fb3e37..3fac45f 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -5,10 +5,10 @@ extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
 #define mc_filter_uv (rpi_shader + 152)
-#define mc_filter_uv_b0 (rpi_shader + 318)
-#define mc_filter_uv_b (rpi_shader + 484)
-#define mc_exit (rpi_shader + 664)
-#define mc_interrupt_exit8 (rpi_shader + 682)
-#define mc_end (rpi_shader + 712)
+#define mc_filter_uv_b0 (rpi_shader + 316)
+#define mc_filter_uv_b (rpi_shader + 476)
+#define mc_exit (rpi_shader + 650)
+#define mc_interrupt_exit8 (rpi_shader + 668)
+#define mc_end (rpi_shader + 698)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 846d08e..13eb0d8 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -221,8 +221,6 @@ add r0, r0, r1 # Combine width and height of destination area
 shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
 add rb26, r0, rb27
 
-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
-
 # get filter coefficients
 
 mov r0, unif
@@ -410,20 +408,12 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
 add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r0, r2, r3
-
-mov r3, rb31
-
-mov ra12, ra13
-mov ra13, ra14
-
-sub.setf -, r3, 4 ; mov r1, ra22
-
-# apply horizontal filter         
+add r0, r2, r3       ; mov r3, rb31
+sub.setf -, r3, 4    ; mov ra12, ra13
 brr.anyn -, r:uvloop_b0
-mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
-asr ra15, r0, 8         ; nop  # TODO isn't ra15 already in 24bit precision, may not need the sign extension here?
-nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
+mov ra13, ra14       # Delay slot 1
+mov ra14, ra15       # Delay slot 2
+mov ra15, r0         # Delay slot 3
  
 # apply vertical filter and write to VPM
 
@@ -432,9 +422,9 @@ nop                     ; mul24 r0, ra13, rb9
 add r1, r1, r0          ; mul24 r0, ra12, rb8
 add r1, r1, r0          ; mul24 r0, ra15, rb11
 add r1, r1, r0          ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+sub.setf -, r3, rb18
 brr.anyn -, r:uvloop_b0
-asr vpm, r1, 14        # Delay 1 shifts down by shift2=6, but results are still in 16bit precision TODO may be able to avoid the mul24 and use more delay slots
+asr vpm, r1, 6         # Delay 1 shifts down by shift2=6, but results are still in 16bit precision
 nop                    # Delay 2
 nop                    # Delay 3
 
@@ -554,19 +544,12 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
 nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
 add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
 nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r0, r2, r3
-
-mov r3, rb31
-
-mov ra12, ra13
-mov ra13, ra14
-
-sub.setf -, r3, 4 ; mov r1, ra22
-# apply horizontal filter         
+add r0, r2, r3       ; mov r3, rb31
+sub.setf -, r3, 4    ; mov ra12, ra13
 brr.anyn -, r:uvloop_b
-mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
-asr ra15, r0, 8         ; nop
-nop                     ; nop    # TODO improve use of delay slots
+mov ra13, ra14       # Delay slot 1
+mov ra14, ra15       # Delay slot 2
+mov ra15, r0         # Delay slot 3
  
 # apply vertical filter and write to VPM
 
-- 
1.9.1


From b4575df7b3567d967ce0cf72cf6eb50d598b7efe Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 11:31:23 +0100
Subject: [PATCH 35/77] Avoid writeback of first B results

---
 libavcodec/rpi_shader.c    | 229 ++++++++++++++++++++++-----------------------
 libavcodec/rpi_shader.h    |   8 +-
 libavcodec/rpi_shader.qasm |  18 +---
 3 files changed, 121 insertions(+), 134 deletions(-)

diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index c498f28..ba453a2 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -255,130 +255,125 @@ unsigned int rpi_shader[] = {
 /* [0x00000710] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
 /* [0x00000718] */ 0x009e7000, 0x100009e7, // nop
 /* [0x00000720] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000728] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000730] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000738] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000740] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000748] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000750] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000758] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000760] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000768] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000728] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000730] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000738] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000740] */ 0x009e7000, 0x100009e7, // nop
 // ::mc_filter_uv_b
-/* [0x00000770] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000778] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000780] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000788] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000790] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000798] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000007a0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000007a8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000007b0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000007b8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000007c0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000007c8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000007d0] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000007d8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000007e0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000007e8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000007f0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000007f8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000800] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000808] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000810] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000818] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000820] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000828] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000830] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000838] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000840] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000748] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000750] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000758] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000760] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000768] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000770] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000778] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000780] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000788] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000790] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000798] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000007a0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000007a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000007b0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000007b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000007c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000007c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000007d0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000007d8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000007e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000007e8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x000007f0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x000007f8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000800] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000808] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000810] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000818] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000820] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000828] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000830] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000838] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000840] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
 /* [0x00000848] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000850] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000858] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000860] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000868] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000870] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000878] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000880] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000888] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000890] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000898] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000008a0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000008a8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000850] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000858] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000860] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000868] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000870] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000878] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000880] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x000008b0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000008b8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000008c0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000008c8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000008d0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000008d8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000008e0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000008e8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000008f0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000008f8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000900] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000908] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000910] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000918] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000920] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000928] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000930] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000938] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000940] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000948] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000950] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000958] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000960] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000968] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000970] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000978] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000980] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000988] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000990] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000998] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000009a0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000009a8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000009b0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x000009b8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x000009c0] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000009c8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x000009d0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000009d8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000009e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000009e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000009f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000009f8] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000a08] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000a10] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000a18] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a20] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000888] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000890] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000898] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000008a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000008a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000008b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000008b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000008c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000008c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000008d0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000008e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000008f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000008f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000900] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000908] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000910] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000918] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000920] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000928] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000930] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000938] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000940] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000948] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000950] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000958] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000960] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000968] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000970] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000978] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000980] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000988] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x00000990] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000998] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000009a0] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x000009a8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000009b0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000009b8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000009c0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000009c8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000009d0] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000009e0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000009e8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000009f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000009f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000a28] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a30] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000a38] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a40] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a48] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a58] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000a60] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000a68] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a08] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a10] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a18] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a20] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a28] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a30] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000a38] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a40] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000a70] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a48] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a58] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a60] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a68] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000a98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000aa0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000aa8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ab0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ab8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ac0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ac8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ad0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000ad8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000ae0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000ab0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 3fac45f..45dbe0e 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -6,9 +6,9 @@ extern unsigned int rpi_shader[];
 #define mc_setup_uv (rpi_shader + 0)
 #define mc_filter_uv (rpi_shader + 152)
 #define mc_filter_uv_b0 (rpi_shader + 316)
-#define mc_filter_uv_b (rpi_shader + 476)
-#define mc_exit (rpi_shader + 650)
-#define mc_interrupt_exit8 (rpi_shader + 668)
-#define mc_end (rpi_shader + 698)
+#define mc_filter_uv_b (rpi_shader + 466)
+#define mc_exit (rpi_shader + 640)
+#define mc_interrupt_exit8 (rpi_shader + 658)
+#define mc_end (rpi_shader + 688)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 13eb0d8..23b085f 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -428,22 +428,14 @@ asr vpm, r1, 6         # Delay 1 shifts down by shift2=6, but results are still
 nop                    # Delay 2
 nop                    # Delay 3
 
+# in pass0 we don't really need to save any results, but need to discard the uniforms
 # DMA out for U
 
-mov vw_setup, rb26 # VDW setup 0
-mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW    # TODO in pass0 we don't need to save any results
-
-# DMA out for V
-# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
-# Could potentially push this write into the start of the next pipeline stage.
-mov r0, 16
-mov -, vw_wait
-
 bra -, ra31
-add vw_setup, rb26, r0 # VDW setup 0
-mov vw_setup, rb29 # Stride
-mov vw_addr, unif # start the VDW
+mov r0, unif           # Delay 1 
+mov r0, unif           # Delay 2
+nop                    # Delay 3
+
 
 ################################################################################
 
-- 
1.9.1


From f2fbc15c3a6b25050a831f79b114c6eccd3048aa Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 11:36:24 +0100
Subject: [PATCH 36/77] Cutdown size of chroma prediction commands

---
 libavcodec/hevc.c          |  17 +-
 libavcodec/rpi_shader.c    | 543 ++++++++++++++++++++++-----------------------
 libavcodec/rpi_shader.h    |  12 +-
 libavcodec/rpi_shader.qasm |  11 +-
 4 files changed, 281 insertions(+), 302 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index ed2a47e..747f949 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -54,7 +54,7 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 
 #ifdef RPI_INTER_QPU
 
-#define RPI_CHROMA_COMMAND_WORDS 12
+#define RPI_CHROMA_COMMAND_WORDS 10
 #define UV_COMMANDS_PER_QPU ((1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS)       
 // The QPU code for UV blocks only works up to a block width of 8
 #define RPI_CHROMA_BLOCK_WIDTH 8
@@ -1996,11 +1996,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
-                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
                       *u++ = rpi_filter_coefs[_mx][0];
-                      u++;
                       *u++ = rpi_filter_coefs[_my][0];
-                      u++;
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
@@ -2055,9 +2052,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
                       *u++ = rpi_filter_coefs[_mx][0];
-                      u++;
                       *u++ = rpi_filter_coefs[_my][0];
-                      u++;
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
@@ -2118,11 +2113,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       *u++ = rpi_filter_coefs[_mx][0];
-                      u++;
                       *u++ = rpi_filter_coefs[_my][0];
-                      u++;
-                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]); // TODO this will become unused once we have a dedicated pass0 filter
-                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                      u+=2; // Intermediate results are not written back in first pass of B filtering
                       
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 1 + start_x;
@@ -2130,11 +2122,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
-                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
                       *u++ = rpi_filter_coefs[_mx2][0];
-                      u++;
                       *u++ = rpi_filter_coefs[_my2][0];
-                      u++;
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
@@ -2772,7 +2761,7 @@ static void rpi_inter_clear(HEVCContext *s)
         *s->u_mvs[i]++ = pic_height;
         *s->u_mvs[i]++ = s->frame->linesize[1];
         *s->u_mvs[i]++ = s->frame->linesize[2];
-        s->u_mvs[i] += 3;  // Padding words
+        s->u_mvs[i] += 1;  // Padding words
     }
 }
 
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index ba453a2..b0b93b5 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -89,291 +89,286 @@ unsigned int rpi_shader[] = {
 /* [0x00000200] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
 /* [0x00000208] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
 /* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000218] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000220] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000228] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000230] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000238] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000240] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000248] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000250] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
-/* [0x00000258] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+/* [0x00000218] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000220] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000228] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000230] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000238] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000240] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+/* [0x00000248] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
 // ::mc_filter_uv
-/* [0x00000260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000268] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000270] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000278] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000280] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000288] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000290] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000298] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000002a0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000002a8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000002b0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000002b8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000002c0] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000002c8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002e8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000002f0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000340] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000348] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000350] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000358] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000360] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000368] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000370] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000378] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000258] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000260] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000268] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000270] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000278] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000280] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000288] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000290] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000298] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000002a0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000002a8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000002b0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000002b8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002c0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000002c8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000002d0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000002d8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000002e0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000002e8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000002f0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000002f8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000300] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000330] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000338] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000340] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000348] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000350] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000358] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000360] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x00000380] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000388] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000390] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000398] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003a0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003a8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003b8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003c0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000003c8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000003d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000003d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000003e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000003e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000003f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000003f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000400] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000408] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000410] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000418] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000420] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000428] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000430] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000438] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000440] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000448] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000450] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000458] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000460] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000468] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000470] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000478] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000480] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x00000488] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000490] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x00000498] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000004a0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000004a8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000004b0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000004b8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000004c0] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000004c8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000004d0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000004d8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x000004e0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000004e8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000368] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000370] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000378] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000380] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000388] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000390] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000398] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003a0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003a8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000003b0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000003b8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003c0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000003c8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000003d0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000003d8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000003e0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000003e8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000003f0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000003f8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000400] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000408] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000410] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000418] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000420] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000428] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000430] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000438] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000440] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000448] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000450] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000458] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000460] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000468] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+/* [0x00000470] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000478] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x00000480] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000488] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000490] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000498] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000004a8] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000004b0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000004b8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000004c0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000004c8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004d0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x000004f0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000004f8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000500] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000508] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000510] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000518] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000520] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000528] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000530] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000538] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000540] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000548] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x00000550] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000558] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000560] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000568] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000570] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000578] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000580] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000588] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000590] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000598] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000005a0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000005a8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005b0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005b8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005c0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005c8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000005d0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005d8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000005e0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000005e8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005f0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000005f8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000600] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000608] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000004d8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000004e0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000004e8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000004f0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000004f8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000500] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000508] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000510] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000518] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000520] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000528] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000530] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x00000538] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000540] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000548] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000550] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000558] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000560] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000568] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000570] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000578] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000580] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000588] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000590] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000598] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005a0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005a8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005b0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000005b8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000005c0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000005c8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005d0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x000005d8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000005e0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000005e8] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000610] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000618] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000620] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000628] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000630] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000638] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000640] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000648] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000650] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000658] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000668] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000670] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000678] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000680] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000688] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000690] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000698] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000006a0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000006a8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x000006b0] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x000006b8] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x000006c0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000006c8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x000006d0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x000006d8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000006e0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000006e8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000006f0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000006f8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000700] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
-/* [0x00000708] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000710] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
-/* [0x00000718] */ 0x009e7000, 0x100009e7, // nop
+/* [0x000005f0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000005f8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000600] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000608] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000610] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000618] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000620] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000628] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000630] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000638] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000640] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000648] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000650] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000658] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000660] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000668] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000670] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000678] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000680] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000688] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000690] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000698] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x000006a0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000006a8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x000006b0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000006b8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000006c0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000006c8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000006d0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000006d8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000006e0] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+/* [0x000006e8] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x000006f0] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+/* [0x000006f8] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000700] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000708] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000710] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000718] */ 0x15827d80, 0x10020827, // mov r0, unif
 /* [0x00000720] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000728] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000730] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000738] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000740] */ 0x009e7000, 0x100009e7, // nop
 // ::mc_filter_uv_b
-/* [0x00000748] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000750] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000758] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000760] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000768] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000770] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000778] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000780] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000788] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000790] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000798] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000007a0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000007a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000007b0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000007b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000007c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000007c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000007d0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000007d8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000007e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000007e8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x000007f0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x000007f8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000800] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000808] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000810] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000818] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000820] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000828] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000830] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000838] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000840] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000848] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000850] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000858] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000860] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000868] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000870] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000878] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000880] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000728] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000730] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000738] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000740] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000748] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000750] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000758] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000760] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000768] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000770] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000778] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000780] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000788] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000790] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000798] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000007a0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000007a8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000007b0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000007b8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000007c0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000007c8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x000007d0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x000007d8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x000007e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000007e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000007f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000007f8] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000800] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000808] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000810] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000818] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000820] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000828] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000830] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000838] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000840] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000848] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000850] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000858] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x00000888] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000890] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000898] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000008a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000008a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000008b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000008b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000008c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000008c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000008d0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000008e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000008e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000008f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000008f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000900] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000908] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000910] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000918] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000920] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000928] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000930] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000938] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000940] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000948] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000950] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000958] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000960] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000968] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000970] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000978] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000980] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000988] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x00000990] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x00000998] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000009a0] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x000009a8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000009b0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000009b8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000009c0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000009c8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000009d0] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000009e0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000009e8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x000009f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000009f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000860] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000868] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000870] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000878] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000880] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000888] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000890] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000898] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000008a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000008a8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000008b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000008c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000008c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000008d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000008d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000008e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000008e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000008f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000008f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000900] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000908] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000910] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000918] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000920] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000928] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000930] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000938] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000940] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000948] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000950] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000958] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000960] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x00000968] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000970] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000978] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000980] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000988] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000990] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000998] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000009a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000009a8] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000009b0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000009b8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000009c0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000009c8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000009d0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a08] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000a10] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a18] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a20] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a28] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a30] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000a38] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000a40] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x000009e0] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x000009e8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000009f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x000009f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a00] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a08] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000a10] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a18] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000a48] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a58] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a60] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a68] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a20] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a28] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a30] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a38] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a40] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a58] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a60] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000a70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000a78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000aa0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000ab0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a80] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000a88] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000a90] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 45dbe0e..99927c4 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -4,11 +4,11 @@
 extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
-#define mc_filter_uv (rpi_shader + 152)
-#define mc_filter_uv_b0 (rpi_shader + 316)
-#define mc_filter_uv_b (rpi_shader + 466)
-#define mc_exit (rpi_shader + 640)
-#define mc_interrupt_exit8 (rpi_shader + 658)
-#define mc_end (rpi_shader + 688)
+#define mc_filter_uv (rpi_shader + 148)
+#define mc_filter_uv_b0 (rpi_shader + 310)
+#define mc_filter_uv_b (rpi_shader + 458)
+#define mc_exit (rpi_shader + 630)
+#define mc_interrupt_exit8 (rpi_shader + 648)
+#define mc_end (rpi_shader + 678)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 23b085f..4aed168 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -167,8 +167,6 @@ add t0s, r2, r1
 
 # Dump padding words
 mov r0, unif
-mov r0, unif
-mov r0, unif
 
 # submit texture requests for second line
 max r1, ra_y, 0
@@ -228,11 +226,10 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
 asr ra2, r0, rb23;      mul24 r0, r0, ra22
 asr ra1, r0, rb23;      mul24 r0, r0, ra22
 asr ra0, r0, rb23;      mov r0, unif
-                        mov r0, unif
 asr rb11, r0, rb23;     mul24 r0, r0, ra22
 asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
+asr rb8, r0, rb23
 
 # r2 is elem_num
 # r3 is loop counter
@@ -362,11 +359,10 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
 asr ra2, r0, rb23;      mul24 r0, r0, ra22
 asr ra1, r0, rb23;      mul24 r0, r0, ra22
 asr ra0, r0, rb23;      mov r0, unif
-                        mov r0, unif
 asr rb11, r0, rb23;     mul24 r0, r0, ra22
 asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
+asr rb8, r0, rb23      
 
 # r2 is elem_num
 # r3 is loop counter
@@ -490,11 +486,10 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
 asr ra2, r0, rb23;      mul24 r0, r0, ra22
 asr ra1, r0, rb23;      mul24 r0, r0, ra22
 asr ra0, r0, rb23;      mov r0, unif
-                        mov r0, unif
 asr rb11, r0, rb23;     mul24 r0, r0, ra22
 asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif 
+asr rb8, r0, rb23     
 
 # r2 is elem_num
 # r3 is loop counter
-- 
1.9.1


From a0210a8cd37ae2fc75e837ee93e09d3af09f3ac8 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 14 May 2015 11:41:09 +0100
Subject: [PATCH 37/77] Commented reason for lack of saturation

---
 libavcodec/rpi_hevc_transform.s | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
index 1a4dfb5..6a1959f 100644
--- a/libavcodec/rpi_hevc_transform.s
+++ b/libavcodec/rpi_hevc_transform.s
@@ -121,7 +121,7 @@ block_loop:
   bl col_trans_16
   vadd HY(0++,0)+r0,HY(0++,0)+r0,r5 REP 16   # Now add on rounding, shift down by 7, and saturate
   #vsasls HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16 # 4+12=16 so this ends up with the output saturated and in the top half of the word.
-  vasl HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16    # This should be saturating, but the instruction above does not assemble?
+  vasl HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16    # This should be saturating, but the instruction above does not assemble?  (Probably because it ends with ls which is interpreted as a condition flag)
 
   # Save results - note there has been a transposition during the processing so we save columns
   vsth VX(0,32++)+r0, (r1 += r3) REP 16
-- 
1.9.1


From 155e465f24503a2691fb59ccbceb1d09294032fd Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 14 May 2015 15:21:33 +0100
Subject: [PATCH 38/77] ffmpeg: Fix align up of width/height

---
 ffmpeg.c | 20 +++++++++++---------
 1 file changed, 11 insertions(+), 9 deletions(-)

diff --git a/ffmpeg.c b/ffmpeg.c
index 53e32da..9974a6d 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -242,8 +242,8 @@ static MMAL_COMPONENT_T* display_init(size_t x, size_t y, size_t w, size_t h)
     format->es->video.height = h2;
     format->es->video.crop.x = 0;
     format->es->video.crop.y = 0;
-    format->es->video.crop.width = w2;
-    format->es->video.crop.height = h2;
+    format->es->video.crop.width = w;
+    format->es->video.crop.height = h;
     mmal_port_format_commit(display->input[0]);
     
     mmal_component_enable(display);
@@ -262,6 +262,8 @@ static void display_frame(MMAL_COMPONENT_T* display,AVFrame* fr)
 {
     int w = fr->width;
     int h = fr->height;
+    int w2 = (w+31)&~31;
+    int h2 = (h+15)&~15;
     if (!display || !rpi_pool)
         return;
     MMAL_BUFFER_HEADER_T* buf = mmal_queue_get(rpi_pool->queue);
@@ -271,18 +273,18 @@ static void display_frame(MMAL_COMPONENT_T* display,AVFrame* fr)
     }
     assert(buf);
     buf->cmd = 0;
-    buf->length = (w * h * 3)/2;
+    buf->length = (w2 * h2 * 3)/2;
     buf->offset = 0; // Offset to valid data
     buf->flags = 0;
 #ifdef RPI_ZERO_COPY
     buf->data = get_vc_handle(fr->buf[0]);
-    buf->alloc_size = (w*h*3)/2;
+    buf->alloc_size = (w2*h2*3)/2;
 #else
-    mmal_buffer_header_mem_lock(buf);
-    memcpy(buf->data, fr->data[0], w * h);
-    memcpy(buf->data+w*h, fr->data[1], w * h / 4);
-    memcpy(buf->data+w*h*5/4, fr->data[2], w * h / 4);
-    mmal_buffer_header_mem_unlock(buf);
+    //mmal_buffer_header_mem_lock(buf);
+    memcpy(buf->data, fr->data[0], w2 * h);
+    memcpy(buf->data+w2*h2, fr->data[1], w2 * h / 4);
+    memcpy(buf->data+w2*h2*5/4, fr->data[2], w2 * h / 4);
+    //mmal_buffer_header_mem_unlock(buf);
 #endif
     
     mmal_port_send_buffer(display->input[0], buf);  // I assume this will automatically get released
-- 
1.9.1


From 09504cd897622ea0a6099b1f1aa16c20987fcbed Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 14 May 2015 15:21:49 +0100
Subject: [PATCH 39/77] hevc: don't redirect when not rpi_enabled

---
 libavcodec/hevc.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 747f949..ad2b613 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -1432,7 +1432,7 @@ static int hls_pcm_sample(HEVCContext *s, int x0, int y0, int log2_cb_size)
  */
 
 #ifdef RPI_INTER
-#define RPI_REDIRECT(fn) rpi_ ## fn
+#define RPI_REDIRECT(fn) (s->enable_rpi ? rpi_ ## fn : fn)
 static void rpi_luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
                         AVFrame *ref, const Mv *mv, int x_off, int y_off,
                         int block_w, int block_h, int luma_weight, int luma_offset)
-- 
1.9.1


From fee4118069e8db4a28b9d48ddbb3a2614eaa1a2e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 14 May 2015 15:22:02 +0100
Subject: [PATCH 40/77] Use /dev/vcio for mailbox access

---
 libavcodec/rpi_mailbox.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/rpi_mailbox.c b/libavcodec/rpi_mailbox.c
index 536896f..77a56dd 100644
--- a/libavcodec/rpi_mailbox.c
+++ b/libavcodec/rpi_mailbox.c
@@ -39,7 +39,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MAJOR_NUM 100
 #define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
-#define DEVICE_FILE_NAME "/dev/char_dev"
+#define DEVICE_FILE_NAME "/dev/vcio"
 
 #include "rpi_mailbox.h"
 
-- 
1.9.1


From 211ac8b8dd97709cc6bf31bee5c32afe963517f2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 14 May 2015 15:25:25 +0100
Subject: [PATCH 41/77] Use vcsm for all memory allocations

---
 libavcodec/rpi_qpu.c | 180 +++++++++++++++++++--------------------------------
 1 file changed, 67 insertions(+), 113 deletions(-)

diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 59f5494..729cdb3 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -1,6 +1,4 @@
-// define RPI_USE_VCSM to use the vcsm device for shared memory
 // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
-#define RPI_USE_VCSM
 // define RPI_TIME_TOTAL_QPU to print out how much time is spent in the QPU code
 #define RPI_TIME_TOTAL_QPU
 // define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
@@ -22,9 +20,7 @@
 #include "rpi_shader.h"
 #include "rpi_hevc_transform.h"
 
-#ifdef RPI_USE_VCSM
 #include "rpi_user_vcsm.h"
-#endif
 
 // On Pi2 there is no way to access the VPU L2 cache
 // GPU_MEM_FLG should be 4 for uncached memory.  (Or C for alias to allocate in the VPU L2 cache)
@@ -93,7 +89,6 @@ struct GPU
   unsigned int vpu_code[VPU_CODE_SIZE];
   short transMatrix2even[16*16*2];
   int open_count; // Number of allocated video buffers
-  unsigned int vc_handle; // Handle of this memory
   int      mb; // Mailbox handle
   int      vc; // Address in GPU memory
   int mail[12]; // These are used to pass pairs of code/unifs to the QPUs
@@ -102,6 +97,7 @@ struct GPU
 // Stop more than one thread trying to allocate memory or use the processing resources at once
 static pthread_mutex_t gpu_mutex = PTHREAD_MUTEX_INITIALIZER;
 static volatile struct GPU* gpu = NULL;
+static GPU_MEM_PTR_T gpu_mem_ptr;
 
 #if defined(RPI_TIME_TOTAL_QPU) || defined(RPI_TIME_TOTAL_VPU)
 static unsigned int Microseconds(void) {
@@ -129,39 +125,27 @@ static volatile int vpu_async_tail=0; // Contains the number of posted jobs
 static volatile int vpu_async_head=0;
 #endif
 
+static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb);
+static void gpu_free_internal(GPU_MEM_PTR_T *p);
+
 // Connect to QPU, returns 0 on success.
 static int gpu_init(volatile struct GPU **gpu) {
   int mb = mbox_open();
   int vc;
-  int handle;
   volatile struct GPU* ptr;
 	if (mb < 0)
 		return -1;
 
 	if (qpu_enable(mb, 1)) return -2;
   
-#ifdef RPI_USE_VCSM
   vcsm_init();
-#endif
-  
-  handle = mem_alloc(mb, sizeof(struct GPU), 4096, GPU_MEM_FLG);
-  if (!handle)
-  {
-    qpu_enable(mb, 0);
-    return -3;
-  }
-	vc = mem_lock(mb, handle);
-	ptr = mapmem_shared((vc+GPU_MEM_MAP)&~0xc0000000, sizeof(struct GPU));
-	if (ptr == NULL)
-	{	mem_free(mb, handle);
-		mem_unlock(mb, handle);
-		qpu_enable(mb, 0);
-		return -4;
-	}
-
-	ptr->mb = mb;
-	ptr->vc_handle = handle;
-	ptr->vc = vc;
+  gpu_malloc_uncached_internal(sizeof(struct GPU), &gpu_mem_ptr, mb);
+  ptr = (volatile struct GPU*)gpu_mem_ptr.arm;
+  memset(ptr, 0, sizeof *ptr);
+  vc = gpu_mem_ptr.vc;
+
+  ptr->mb = mb;
+  ptr->vc = vc;
   
   printf("GPU allocated at 0x%x\n",vc);
   
@@ -223,94 +207,74 @@ static void gpu_unlock(void) {
   pthread_mutex_unlock(&gpu_mutex);
 }
 
+static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb) {
+  p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
+  assert(p->vcsm_handle);
+  p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
+  assert(p->vc_handle);
+  p->arm = vcsm_lock(p->vcsm_handle);  
+  assert(p->arm);
+  p->vc = mem_lock(mb, p->vc_handle);
+  assert(p->vc);
+  return 0;
+}
+
 // Allocate memory on GPU
 // Fills in structure <p> containing ARM pointer, videocore handle, videocore memory address, numbytes
 // Returns 0 on success.
 // This allocates memory that will not be cached in ARM's data cache.
 // Therefore safe to use without data cache flushing.
-int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p) {
+int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p)
+{
+  int r;
   gpu_lock();
-  p->vc_handle = mem_alloc(gpu->mb, numbytes, 4096, GPU_MEM_FLG);
-  p->vcsm_handle = 0;
-  if (!p->vc_handle)
-  {
-    qpu_enable(gpu->mb, 0);
-    return -3;
-  }
-  p->vc = mem_lock(gpu->mb, p->vc_handle);
-  p->arm = mapmem_shared((p->vc+GPU_MEM_MAP)&~0xc0000000,numbytes);
-  p->numbytes = numbytes;
-  if (p->arm == NULL)
-  {
-    mem_free(gpu->mb, p->vc_handle);
-    mem_unlock(gpu->mb, p->vc_handle);
-    gpu_unlock();
-    qpu_enable(gpu->mb, 0);
-    return -4;
-  }
+  r = gpu_malloc_uncached_internal(numbytes, p, gpu->mb);
   gpu->open_count++;
   gpu_unlock();
-  return 0;
+  return r;
 }
 
 void gpu_cache_flush(GPU_MEM_PTR_T *p)
 {
-  // This only works when using RPI_USE_VCSM
   void *tmp = vcsm_lock(p->vcsm_handle); 
   vcsm_unlock_ptr(tmp);
 }
 
+static int gpu_malloc_cached_internal(int numbytes, GPU_MEM_PTR_T *p) {
+  p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" );
+  //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" ); 
+  //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
+  //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST_AND_VC, (char *)"Video Frame" );
+  assert(p->vcsm_handle);
+  p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
+  assert(p->vc_handle);
+  p->arm = vcsm_lock(p->vcsm_handle);  
+  assert(p->arm);
+  p->vc = mem_lock(gpu->mb, p->vc_handle);
+  assert(p->vc);
+  return 0;
+}
+
 // This allocates data that will be
 //    Cached in ARM L2
 //    Uncached in VPU L2
-int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p) {
+int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p)
+{
+  int r;
   gpu_lock();
-#ifdef RPI_USE_VCSM
-  {
-      p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" ); // f....... locks up for VP9 - retest this?
-      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" ); // 3b...... works
-      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" ); //fb...... locks up
-      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST_AND_VC, (char *)"Video Frame" ); // 3b works (but corrupted due to caching)
-      p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
-      p->arm = vcsm_lock(p->vcsm_handle);  
-      p->vc = mem_lock(gpu->mb, p->vc_handle);
-  }
-#else
-  p->vc_handle = mem_alloc(gpu->mb, numbytes, 4096, GPU_MEM_FLG);
-  p->vcsm_handle = 0;
-  if (!p->handle)
-  {
-    qpu_enable(gpu->mb, 0);
-    return -3;
-  }
-  p->vc = mem_lock(gpu->mb, p->vc_handle);
-  printf("This mapmem_private does not seem to work\n");
-  exit(-1);
-  p->arm = mapmem_private((p->vc+GPU_MEM_MAP)&~0xc0000000,numbytes);
-  p->numbytes = numbytes;
-  if (p->arm == NULL)
-  {
-    mem_free(gpu->mb, p->handle);
-    mem_unlock(gpu->mb, p->handle);
-    gpu_unlock();
-    qpu_enable(gpu->mb, 0);
-    return -4;
-  }
-#endif
+  r = gpu_malloc_cached_internal(numbytes, p);
   gpu->open_count++;
   gpu_unlock();
-  return 0;
+  return r;
 }
 
 static void gpu_term(void)
 {
-	int mb;
-	unsigned handle;
+  int mb;
   
   if (gpu==NULL) 
     return;
   mb = gpu->mb;
-  handle = gpu->vc_handle;
   
 #ifdef RPI_ASYNC
   {
@@ -320,38 +284,27 @@ static void gpu_term(void)
   }
 #endif
     
-    
-	unmapmem((void*)gpu, sizeof(struct GPU));
-	mem_unlock(mb, handle);
-	mem_free(mb, handle);
-	qpu_enable(mb, 0);
-#ifdef RPI_USE_VCSM
+  qpu_enable(mb, 0);
+  gpu_free_internal(&gpu_mem_ptr);
+
   vcsm_exit();
-#endif
-	mbox_close(mb);
+
+  mbox_close(mb);
   gpu = NULL;
 }
 
-void gpu_free(GPU_MEM_PTR_T *p) {
+void gpu_free_internal(GPU_MEM_PTR_T *p) {
   int mb = gpu->mb;
-	unsigned handle = p->vc_handle;
+  mem_unlock(mb,p->vc_handle);
+  vcsm_unlock_ptr(p->arm);
+  vcsm_free(p->vcsm_handle);
+}
+
+void gpu_free(GPU_MEM_PTR_T *p) {
   gpu_lock();
-#ifdef RPI_USE_VCSM
-  if (p->vcsm_handle) {
-      mem_unlock(mb,p->vc_handle);
-      vcsm_unlock_ptr(p->arm);
-      vcsm_free(p->vcsm_handle);
-  } else {
-    	unmapmem((void*)p->arm, sizeof(struct GPU));
-      mem_unlock(mb, handle);
-      mem_free(mb, handle);
-  }
-#else
-	unmapmem((void*)p->arm, sizeof(struct GPU));
-	mem_unlock(mb, handle);
-	mem_free(mb, handle);
-#endif
-  
+
+  gpu_free_internal(p);
+
   gpu->open_count--;
   if (gpu->open_count==0) {
       printf("Closing GPU\n");
@@ -383,20 +336,21 @@ unsigned int vpu_get_constants(void) {
 
 static void *vpu_start(void *arg) {
   while(1) {
+    int *p;
     pthread_mutex_lock(&post_mutex);
     while( vpu_async_tail - vpu_async_head <= 0)
     {
       //printf("Checking number %d %d\n",vpu_async_head,vpu_async_tail);
       pthread_cond_wait(&post_cond_tail, &post_mutex);
     }
-    int *p = vpu_cmds[vpu_async_head%MAXCMDS];
+    p = vpu_cmds[vpu_async_head%MAXCMDS];
     pthread_mutex_unlock(&post_mutex);
     
     if (p[6] == -1) {
       break; // Last job
     }
     if (p[7]) {
-        GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
+        //GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
         //gpu_cache_flush(buf);
     }
     vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
-- 
1.9.1


From e6e1787afe0676db73e0cddac74efbe4f229cba0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 14 May 2015 15:43:17 +0100
Subject: [PATCH 42/77] Enable EARLY_MALLOC and fix sps access bug

---
 libavcodec/hevc.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index ad2b613..ce56587 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -42,7 +42,7 @@
 #ifdef RPI
   #include "rpi_qpu.h"
   // For some unknown reason, the code seems to crash if I do a late malloc
-  #define EARLY_MALLOC
+  //#define EARLY_MALLOC
   // Move Inter prediction into separate pass
   #define RPI_INTER
 #endif
@@ -147,7 +147,8 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
 #ifdef RPI
 #ifdef EARLY_MALLOC
 #else
-    int coeffs_in_ctb = (1 << s->sps->log2_ctb_size) * (1 << s->sps->log2_ctb_size);
+    assert(sps);
+    int coeffs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
     int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
     printf("pic_arrays_init\n");
     printf("Allocated %d\n",coefs_per_row);
-- 
1.9.1


From e87d7d3b13eb64a60ae20aa0ec961ab9fbe1697f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 14 May 2015 16:40:51 +0100
Subject: [PATCH 43/77] Add copy of av_mod_uintp2 for use with stable ffmpeg

---
 libavcodec/hevc.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index ce56587..55c3b55 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -49,6 +49,14 @@
 
 // #define DISABLE_MC
 
+#ifndef av_mod_uintp2
+static av_always_inline av_const unsigned av_mod_uintp2_c(unsigned a, unsigned p)
+{
+    return a & ((1 << p) - 1);
+}
+#   define av_mod_uintp2   av_mod_uintp2_c
+#endif
+
 const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
 
 
-- 
1.9.1


From 92bc080ef1c862f493cfb4ace6f0a149d170d9c8 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 14 May 2015 17:03:26 +0100
Subject: [PATCH 44/77] Fix build with RPI not defined

---
 libavcodec/hevc_cabac.c  | 2 ++
 libavcodec/hevc_filter.c | 2 +-
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index 7096e31..7f50567 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1079,7 +1079,9 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     int vshift = s->sps->vshift[c_idx];
     uint8_t *dst = &s->frame->data[c_idx][(y0 >> vshift) * stride +
                                           ((x0 >> hshift) << s->sps->pixel_shift)];
+#ifdef RPI
     int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag && !transform_skip_flag && !lc->tu.cross_pf && log2_trafo_size>=4;
+#endif
     int16_t *coeffs = (int16_t*)(c_idx ? lc->edge_emu_buffer2 : lc->edge_emu_buffer);
     uint8_t significant_coeff_group_flag[8][8] = {{0}};
     int explicit_rdpcm_flag = 0;
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 9fb08bc..23fe07f 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -865,12 +865,12 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
 #undef CB
 #undef CR
 
+#ifdef RPI_INTER_QPU
 static void flush_buffer(AVBufferRef *bref) {
     GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
     gpu_cache_flush(p);
 }
 
-#ifdef RPI_INTER_QPU
 static void ff_hevc_flush_chroma(HEVCContext *s)
 {
     if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
-- 
1.9.1


From c686835fdf48da41d90b989265fc864b2da585dc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 14 May 2015 17:59:34 +0100
Subject: [PATCH 45/77] Disable RPI_INTER_QPU for now

---
 libavcodec/hevc.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 70303cc..d2a33a4 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -43,7 +43,7 @@
 
   #include "rpi_qpu.h"
   // Use QPU for inter prediction
-  #define RPI_INTER_QPU
+  //#define RPI_INTER_QPU
 
 #endif
 
-- 
1.9.1


From 7ca46e47615c14655dbbd9a0133aad7b2d41cf5d Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Mon, 18 May 2015 11:11:02 +0100
Subject: [PATCH 46/77] Added support for weighted prediction in P frames

---
 libavcodec/hevc.c          |  51 +++-
 libavcodec/rpi_shader.c    | 566 +++++++++++++++++++++++----------------------
 libavcodec/rpi_shader.h    |  12 +-
 libavcodec/rpi_shader.qasm |  41 +++-
 4 files changed, 384 insertions(+), 286 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 55c3b55..fa34e48 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -62,7 +62,7 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 
 #ifdef RPI_INTER_QPU
 
-#define RPI_CHROMA_COMMAND_WORDS 10
+#define RPI_CHROMA_COMMAND_WORDS 12
 #define UV_COMMANDS_PER_QPU ((1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS)       
 // The QPU code for UV blocks only works up to a block width of 8
 #define RPI_CHROMA_BLOCK_WIDTH 8
@@ -1995,6 +1995,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 int y1_c = y0_c + (mv->y >> (2 + hshift));
                 //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
                 int chan = x0>>8;
+                int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
+                                       (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
                 
                 uint32_t *u = s->u_mvs[chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
@@ -2007,6 +2009,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       *u++ = rpi_filter_coefs[_mx][0];
                       *u++ = rpi_filter_coefs[_my][0];
+                      if (weight_flag) {
+                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0] & 0xffff);
+                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1] & 0xffff);
+                      } else {
+                          *u++ = 1; // Weight of 1 and offset of 0
+                          *u++ = 1;
+                      }
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
@@ -2049,6 +2058,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 int y1_c = y0_c + (mv->y >> (2 + hshift));
                 //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
                 int chan = x0>>8;
+                int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
+                                       (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
                 
                 uint32_t *u = s->u_mvs[chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
@@ -2062,6 +2073,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
                       *u++ = rpi_filter_coefs[_mx][0];
                       *u++ = rpi_filter_coefs[_my][0];
+                      if (weight_flag) {
+                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[1]][0] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[1]][0] & 0xffff);
+                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[1]][1] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[1]][1] & 0xffff);
+                      } else {
+                          *u++ = 1; // Weight of 1 and offset of 0
+                          *u++ = 1;
+                      }
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
@@ -2123,6 +2141,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       *u++ = rpi_filter_coefs[_mx][0];
                       *u++ = rpi_filter_coefs[_my][0];
+                      u+=2; // Weights not supported in B slices
                       u+=2; // Intermediate results are not written back in first pass of B filtering
                       
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
@@ -2133,6 +2152,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
                       *u++ = rpi_filter_coefs[_mx2][0];
                       *u++ = rpi_filter_coefs[_my2][0];
+                      u+=2; // Weights not supported in B slices
                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
@@ -2759,6 +2779,9 @@ static void rpi_inter_clear(HEVCContext *s)
     int i;
     int pic_width        = s->sps->width >> s->sps->hshift[1];
     int pic_height       = s->sps->height >> s->sps->vshift[1];
+    int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
+                           (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
+                                       
     for(i=0;i<8;i++) {
         s->u_mvs[i] = s->mvs_base[i];
         *s->u_mvs[i]++ = 0;
@@ -2770,6 +2793,13 @@ static void rpi_inter_clear(HEVCContext *s)
         *s->u_mvs[i]++ = pic_height;
         *s->u_mvs[i]++ = s->frame->linesize[1];
         *s->u_mvs[i]++ = s->frame->linesize[2];
+        if (weight_flag) {
+            *s->u_mvs[i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
+            *s->u_mvs[i]++ = s->sh.chroma_log2_weight_denom + 6;
+        } else {
+            *s->u_mvs[i]++ = 1 << 5;
+            *s->u_mvs[i]++ = 6;
+        }
         s->u_mvs[i] += 1;  // Padding words
     }
 }
@@ -2813,11 +2843,27 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
 
 #ifdef RPI
+#ifdef RPI_INTER_QPU
     s->enable_rpi = s->sps->width <= RPI_MAX_WIDTH
                     && !s->pps->cross_component_prediction_enabled_flag
                     && s->pps->num_tile_rows <= 1 && s->pps->num_tile_columns <= 1
-                    && !(s->pps->weighted_pred_flag && s->sh.slice_type == P_SLICE)
                     && !(s->pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE);
+#else
+    s->enable_rpi = s->sps->width <= RPI_MAX_WIDTH
+                    && !s->pps->cross_component_prediction_enabled_flag
+                    && s->pps->num_tile_rows <= 1 && s->pps->num_tile_columns <= 1;
+#endif                    
+                    
+    /*if (!s->enable_rpi) {
+      if (s->pps->cross_component_prediction_enabled_flag)
+        printf("Cross component\n");
+      if (s->pps->num_tile_rows > 1 || s->pps->num_tile_columns > 1)
+        printf("Tiles\n");
+      if (s->pps->weighted_pred_flag && s->sh.slice_type == P_SLICE)
+        printf("Weighted P slice\n");
+      if (s->pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
+        printf("Weighted B slice\n");
+    }*/
                     
 #endif
 
@@ -2950,6 +2996,7 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
 
 #ifdef RPI
     s->enable_rpi = 0;
+    //printf("Wavefront\n");
 #endif
 
     if(ctb_row) {
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index b0b93b5..3f04d80 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -88,287 +88,307 @@ unsigned int rpi_shader[] = {
 /* [0x000001f8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
 /* [0x00000200] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
 /* [0x00000208] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000218] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000220] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000228] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000230] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000238] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000240] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
-/* [0x00000248] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+/* [0x00000210] */ 0x15827d80, 0x10021327, // mov rb12,unif
+/* [0x00000218] */ 0x15827d80, 0x10021367, // mov rb13,unif
+/* [0x00000220] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000228] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000230] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000238] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000240] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000248] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000250] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+/* [0x00000258] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
 // ::mc_filter_uv
-/* [0x00000250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000258] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000260] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000268] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000270] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000278] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000280] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000288] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000290] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000298] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000002a0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000002a8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000002b0] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000002b8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000002c0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000002c8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000002d0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002d8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000002e0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000002e8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000002f0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000002f8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000300] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000330] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000338] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000340] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000348] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x00000350] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000358] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000360] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000268] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000270] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000278] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000280] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000288] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000290] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000298] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000002a0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000002a8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000002b0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000002b8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000002c0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000002c8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000002e8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000002f0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000340] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000348] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000350] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000358] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000360] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000368] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000370] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+/* [0x00000378] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000380] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+/* [0x00000388] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000390] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
+/* [0x00000398] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000003a0] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
+/* [0x000003a8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000003b0] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x00000368] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000370] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000378] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000380] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000388] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000390] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000398] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003a0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003a8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000003b0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000003b8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000003c0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000003c8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000003d0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000003d8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000003e0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000003e8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000003f0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000003f8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000400] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000408] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000410] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000418] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000420] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000428] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000430] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000438] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000440] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000448] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000450] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000458] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000460] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000468] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
-/* [0x00000470] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000478] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
-/* [0x00000480] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000488] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000490] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000498] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000004a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000004a8] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000004b0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000004b8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000004c0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x000004c8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000004d0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000003b8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000003c0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x000003c8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x000003d0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003d8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003e0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003e8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003f0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003f8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000400] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000408] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000410] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000418] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000420] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000428] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000430] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000438] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000440] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000448] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000450] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000458] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000460] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000468] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000470] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000478] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000480] */ 0x00000020, 0xe0021327, // mov rb12,32
+/* [0x00000488] */ 0x00000006, 0xe0021367, // mov rb13,6
+/* [0x00000490] */ 0x00000001, 0xe00213a7, // mov rb14,1
+/* [0x00000498] */ 0x00000000, 0xe00213e7, // mov rb15,0
+/* [0x000004a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000004a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000004b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000004b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000004c0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000004c8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000004d0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000004d8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+/* [0x000004e0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+/* [0x000004e8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+/* [0x000004f0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000004f8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+/* [0x00000500] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000508] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000510] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000518] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000520] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000528] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000530] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000538] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000540] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000548] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000550] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x000004d8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000004e0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000004e8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000004f0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000004f8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000500] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000508] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000510] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000518] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000520] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000528] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000530] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x00000538] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000540] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000548] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000550] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000558] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000560] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000568] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000570] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000578] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000580] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000588] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000590] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000598] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005a0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005a8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005b0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000005b8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000005c0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000005c8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000005d0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x000005d8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000005e0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000005e8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000558] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000560] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000568] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000570] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000578] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000580] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000588] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000590] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000598] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x000005a0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000005a8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x000005b0] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x000005b8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000005c0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005c8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000005d0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000005d8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000005e0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000005e8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000005f0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000005f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000600] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000608] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000610] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000618] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000620] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000628] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000630] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000638] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000640] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000648] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000650] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000658] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000660] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000668] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000670] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000678] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x000005f0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000005f8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000600] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000608] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000610] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000618] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000620] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000628] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000630] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000638] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000640] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000648] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000650] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000658] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000660] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000668] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000670] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000678] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000680] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000688] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000690] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000698] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x000006a0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000006a8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x000006b0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x000006b8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000006c0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000006c8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000006d0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000006d8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000006e0] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
-/* [0x000006e8] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x000006f0] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
-/* [0x000006f8] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000700] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000708] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000710] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000718] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000720] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000680] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000688] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000690] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000698] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000006a0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000006a8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000006b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000006b8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000006c0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x000006c8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x000006d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000006d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000006e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000006e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000006f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000006f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000700] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000708] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000710] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000718] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000720] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000728] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000730] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000738] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000740] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000748] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000750] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000758] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000760] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000768] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000770] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+/* [0x00000778] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000780] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+/* [0x00000788] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000790] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000798] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000007a0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000007a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000007b0] */ 0x009e7000, 0x100009e7, // nop
 // ::mc_filter_uv_b
-/* [0x00000728] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000730] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000738] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000740] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000748] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000750] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000758] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000760] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000768] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000770] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000778] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000780] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000788] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000790] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000798] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000007a0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000007a8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000007b0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000007b8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000007c0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000007c8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x000007d0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x000007d8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x000007e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000007e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000007f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000007f8] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000800] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000808] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000810] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000818] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000820] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000828] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000830] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000838] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000840] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x00000848] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000850] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000858] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000007b8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000007c0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000007c8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000007d0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000007d8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000007e0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000007e8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000007f0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000007f8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+/* [0x00000800] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000808] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+/* [0x00000810] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000818] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000820] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000828] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000830] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000838] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000840] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000848] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000850] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000858] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000860] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000868] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000870] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000878] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000880] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000888] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000890] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000898] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008a0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008a8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008b0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000008b8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008c0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008c8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008d0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x000008d8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000008e0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000008e8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000008f0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008f8] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x00000860] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000868] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000870] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000878] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000880] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000888] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000890] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000898] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000008a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000008a8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000008b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000008b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000008c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000008c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000008d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000008d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000008e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000008e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000008f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000008f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000900] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000908] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000910] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000918] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000920] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000928] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000930] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000938] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000940] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000948] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000950] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x00000958] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000960] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x00000968] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x00000970] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000978] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000980] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000988] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000990] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000998] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000009a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x000009a8] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x000009b0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x000009b8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000009c0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x000009c8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x000009d0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000900] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000908] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+/* [0x00000910] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+/* [0x00000918] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000920] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000928] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000930] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000938] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000940] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+/* [0x00000948] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+/* [0x00000950] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000958] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000960] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000968] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000970] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000978] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000980] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000988] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000990] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000998] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x000009a0] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x000009a8] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000009b0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000009b8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x000009c0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000009c8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000009d0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000009d8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000009e0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000009e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000009f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000009f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000a00] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x00000a08] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000a10] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000a18] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000a20] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000a28] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000a30] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000a38] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a40] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000a48] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000a50] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000a60] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x000009e0] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x000009e8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000009f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x000009f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a00] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a08] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000a10] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000a18] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a78] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a80] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a98] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000aa0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000ab0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000a20] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a28] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a30] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a38] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a40] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a58] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a60] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000a80] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000a88] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000a90] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000ac0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ad8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ae0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b10] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b18] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000b20] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000b28] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000b30] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 99927c4..cec9901 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -4,11 +4,11 @@
 extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
-#define mc_filter_uv (rpi_shader + 148)
-#define mc_filter_uv_b0 (rpi_shader + 310)
-#define mc_filter_uv_b (rpi_shader + 458)
-#define mc_exit (rpi_shader + 630)
-#define mc_interrupt_exit8 (rpi_shader + 648)
-#define mc_end (rpi_shader + 678)
+#define mc_filter_uv (rpi_shader + 152)
+#define mc_filter_uv_b0 (rpi_shader + 342)
+#define mc_filter_uv_b (rpi_shader + 494)
+#define mc_exit (rpi_shader + 670)
+#define mc_interrupt_exit8 (rpi_shader + 688)
+#define mc_end (rpi_shader + 718)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 4aed168..0a65ab5 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -9,7 +9,12 @@
 #                                               (ra15 isn't clamped to zero - this happens during the
 #                                                copy to ra14, and during its use in the vertical filter)
 #
-# rb8...rb15                                    eight vertical filter coefficients
+# rb8...rb11                                    eight vertical filter coefficients
+ 
+# rb12 offset to add before shift
+# rb13 shift 
+# rb14 weight (U on left, V on right)
+# rb15 offset (U on left, V on right)
 #
 # ra16                                          clipped(row start address+elem_num)&~3
 # ra17                                          per-channel shifts
@@ -165,6 +170,9 @@ add r2, r2, r0 ; mul24 r1, r1, rb_pitch
 add t0s, r0, r1 ; mov ra_x2_base, r2
 add t0s, r2, r1
 
+mov rb12,unif # offset before shift
+mov rb13,unif # offset after shift 
+
 # Dump padding words
 mov r0, unif
 
@@ -231,11 +239,21 @@ asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
 asr rb8, r0, rb23
 
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+mov r0, unif # U offset/weight
+asr rb15, r0, r2  # Compute offset from MSBs
+shl r0, r0, r2
+asr rb14, r0, r2  # Compute weight from LSBs
+mov r0, unif # V offset/weight
+asr.ifnz rb15, r0, r2
+shl r0, r0, r2
+asr.ifnz rb14, r0, r2 
+
 # r2 is elem_num
 # r3 is loop counter
 
 mov r5rep, -8 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 
 # retrieve texture results and pick out bytes
 # then submit two more texture requests
@@ -278,6 +296,11 @@ brr.anyn -, r:uvloop
 mov ra13, ra14       # Delay slot 1
 mov ra14, ra15       # Delay slot 2
 mov ra15, r0         # Delay slot 3
+
+mov rb12,32
+mov rb13,6
+mov rb14,1
+mov rb15,0
  
 # apply vertical filter and write to VPM
 
@@ -288,9 +311,11 @@ add r1, r1, r0          ; mul24 r0, ra15, rb11
 add r1, r1, r0          ; mov -, vw_wait
 sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
 asr r1, r1, 14
-add r1, r1, ra21
+nop                     ; mul24 r1, r1, rb14
+add r1, r1, rb12
+asr r1, r1, rb13
 brr.anyn -, r:uvloop 
-asr r1, r1, 6          # Delay 1
+add r1, r1, rb15       # Delay 1
 min r1, r1, rb22       # Delay 2
 max vpm, r1, 0         # Delay 3
 
@@ -362,7 +387,10 @@ asr ra0, r0, rb23;      mov r0, unif
 asr rb11, r0, rb23;     mul24 r0, r0, ra22
 asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23      
+asr rb8, r0, rb23     
+
+mov r0, unif # U offset/weight
+mov r0, unif # V offset/weight 
 
 # r2 is elem_num
 # r3 is loop counter
@@ -491,6 +519,9 @@ asr rb10, r0, rb23;     mul24 r0, r0, ra22
 asr rb9, r0, rb23;      mul24 r0, r0, ra22
 asr rb8, r0, rb23     
 
+mov r0, unif # U offset/weight
+mov r0, unif # V offset/weight
+
 # r2 is elem_num
 # r3 is loop counter
 
-- 
1.9.1


From e2f4daa03586b3eba4d141a1164cee19e39732d6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 20 May 2015 12:10:58 +0100
Subject: [PATCH 47/77] ffmpeg: Fix for display seg fault on exit

---
 ffmpeg.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/ffmpeg.c b/ffmpeg.c
index 9974a6d..22ffad4 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -1048,7 +1048,8 @@ static void do_video_out(AVFormatContext *s,
 #ifdef RPI_DISPLAY
     if (!rpi_display)
         rpi_display = display_init(0,0,next_picture->width,next_picture->height);
-     display_frame(rpi_display,next_picture);
+    if (next_picture)
+        display_frame(rpi_display,next_picture);
 #endif
 
     if (ost->source_index >= 0)
-- 
1.9.1


From a05a7d559a3e9b05b75e4af3d13526a1f6304ba5 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 21 May 2015 16:49:03 +0100
Subject: [PATCH 48/77] Protect access to next_picture in display code

---
 ffmpeg.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/ffmpeg.c b/ffmpeg.c
index 22ffad4..5457de0 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -1046,10 +1046,12 @@ static void do_video_out(AVFormatContext *s,
     InputStream *ist = NULL;
     AVFilterContext *filter = ost->filter->filter;
 #ifdef RPI_DISPLAY
-    if (!rpi_display)
-        rpi_display = display_init(0,0,next_picture->width,next_picture->height);
     if (next_picture)
+    {
+	if (!rpi_display)
+           rpi_display = display_init(0,0,next_picture->width,next_picture->height);
         display_frame(rpi_display,next_picture);
+    }
 #endif
 
     if (ost->source_index >= 0)
-- 
1.9.1


From 74ab852a32c3bd9d482c2e25cf8ebe3f6531ed08 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 20 May 2015 15:19:08 +0100
Subject: [PATCH 49/77] Revert "Disable RPI_INTER_QPU for now"

This reverts commit 9e2369c992f660e2bf576773c36337c7a88e27b0.
---
 libavcodec/hevc.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index d2a33a4..70303cc 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -43,7 +43,7 @@
 
   #include "rpi_qpu.h"
   // Use QPU for inter prediction
-  //#define RPI_INTER_QPU
+  #define RPI_INTER_QPU
 
 #endif
 
-- 
1.9.1


From 7f728a6139f465da32e047faf88a8089d240deef Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 19 May 2015 08:43:30 +0100
Subject: [PATCH 50/77] Improved ordering of tasks

---
 libavcodec/hevc.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index fa34e48..79d339c 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2905,15 +2905,15 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
           s->dblk_cmds[s->num_dblk_cmds][0] = x_ctb;
           s->dblk_cmds[s->num_dblk_cmds++][1] = y_ctb;
           if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->sps->width) {
-#ifdef RPI_INTER_QPU
-            // Kick off inter prediction on QPUs
-            rpi_execute_inter_qpu(s);
-#endif
             // Transform all blocks
             // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
             rpi_execute_transform(s);
             // Perform inter prediction
             rpi_execute_inter_cmds(s);
+#ifdef RPI_INTER_QPU
+            // Kick off inter prediction on QPUs
+            rpi_execute_inter_qpu(s);
+#endif
             // Wait for transform completion
             vpu_wait(s->vpu_id);
             
-- 
1.9.1


From f6f81480f3a4148a09ed4b75dbb07228e2431637 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 20 May 2015 19:58:19 +0100
Subject: [PATCH 51/77] Drafted Luma inter prediction

---
 libavcodec/rpi_shader.qasm | 594 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 554 insertions(+), 40 deletions(-)

diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 0a65ab5..a0348a0 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -2,7 +2,10 @@
 #
 # ra0...ra7                                     eight horizontal filter coefficients
 #
-# rb1...rb7                                     seven shifted copies of the current unfiltered row
+# rb0 rx_shift2
+# rb1 ra_y2_next
+#
+# rb4...rb7                                     
 #
 # ra8...ra15                                    eight filtered rows of context (rb15 == most recent)
 #
@@ -26,9 +29,9 @@
 # rb19                                          next ra16
 #
 # ra20                                          1
-# ra21                                          32
+# ra21                                          ra_21
 # ra22                                          256
-# ra23                                          8
+# ra23                                          rx_shift2_next
 #
 # rb20                                          0xffffff00
 # rb21                                          vpm_setup for reading/writing 16bit results into VPM
@@ -57,16 +60,23 @@
 .set rb_frame_width_minus_1,       rb25
 .set rb_frame_height_minus_1,      rb30
 .set rb_pitch,                     rb16
-.set ra_x_base,                    ra16
-.set rb_x_base_next,               rb19
-.set ra_x2_base,                   ra24
-.set ra_x2_base_next,              ra26
+.set ra_x,                         ra16
+.set ra_y2,                        ra21
+.set ra_y2_next,                   rb1
+
+.set rb_x_next,                    rb19
+.set rx_frame_base2_next,          rb19
+
+.set ra_frame_base,                ra24
+.set ra_frame_base_next,           ra26
 .set ra_xshift,                    ra17
 
-.set ra_x2shift,                   ra25
 .set ra_u2v_ref_offset,            ra25
+.set ra_frame_base2,               ra25
 
 .set ra_xshift_next,               ra19
+.set rx_xshift2,                   rb0
+.set rx_xshift2_next,              ra23
 
 .set ra_x2shift_next,              ra27
 .set ra_u2v_dst_offset,            ra27
@@ -83,11 +93,11 @@
 mov ra31, unif
 
 # Load first request location
-add ra_x_base, unif, elem_num # Store x
+add ra_x, unif, elem_num # Store x
 mov ra_y, unif # Store y
-mov ra_x2_base, unif # Store frame u base
+mov ra_frame_base, unif # Store frame u base
 nop
-sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
+sub ra_u2v_ref_offset, unif, ra_frame_base # Store offset to add to move from u to v in reference frame
 
 # Read image dimensions
 sub rb25,unif,1
@@ -104,9 +114,7 @@ add rb24, r1, r0
 # load constants
 
 mov ra20, 1
-mov ra21, 32
 mov ra22, 256
-mov ra23, 8
 mov ra30, 64
 
 mov rb20, 0xffffff00
@@ -156,18 +164,18 @@ mov r1, vpm_setup(0, 2, h16p(0, 0))  # 2 is stride - stride acts on ADDR which i
 add rb21, r0, r1
 
 # Compute base address for first and second access
-mov r0, ra_x_base           # Load x
+mov r0, ra_x           # Load x
 max r0, r0, 0; mov r1, ra_y # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
+min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base  # Load the frame base
 shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
 add ra_y, r1, 1
 add r0, r0, r3
 and r0, r0, ~3
-max r1, r1, 0 ; mov ra_x_base, r0 # y
+max r1, r1, 0 ; mov ra_x, r0 # y
 min r1, r1, rb_frame_height_minus_1
 # submit texture requests for first line
 add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-add t0s, r0, r1 ; mov ra_x2_base, r2
+add t0s, r0, r1 ; mov ra_frame_base, r2
 add t0s, r2, r1
 
 mov rb12,unif # offset before shift
@@ -182,8 +190,8 @@ min r1, r1, rb_frame_height_minus_1
 add ra_y, ra_y, 1
 bra -, ra31
 nop ; mul24 r1, r1, rb_pitch
-add t0s, r1, ra_x_base
-add t0s, r1, ra_x2_base
+add t0s, r1, ra_x
+add t0s, r1, ra_frame_base
 
 
 
@@ -192,7 +200,7 @@ add t0s, r1, ra_x2_base
 # mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
 
 # At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
+# ra_x, ra_x16_base point to the current coordinates for this block
 ::mc_filter_uv
 mov ra31, unif
 
@@ -207,9 +215,9 @@ min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
 shl ra_xshift_next, r0, 3
 sub r2, unif, r3 # compute offset from frame base u to frame base v
 add r0, r0, r3
-and rb_x_base_next, r0, ~3 
+and rb_x_next, r0, ~3 
 mov ra_y_next, r1
-add ra_x2_base_next, rb_x_base_next, r2
+add ra_frame_base_next, rb_x_next, r2
 
 # set up VPM write
 mov vw_setup, rb28
@@ -265,16 +273,16 @@ mov r3, 0
 # then submit two more texture requests
 
 sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0  
+mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
 mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
 shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
 
 max r2, ra_y, 0  # y
 min r2, r2, rb_frame_height_minus_1
 add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
+add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+add t0s, ra_frame_base, r2   
 
 # generate seven shifted versions
 # interleave with scroll of vertical context
@@ -297,7 +305,7 @@ mov ra13, ra14       # Delay slot 1
 mov ra14, ra15       # Delay slot 2
 mov ra15, r0         # Delay slot 3
 
-mov rb12,32
+mov rb12,32 # TODO remove these to make P weighted prediction work properly
 mov rb13,6
 mov rb14,1
 mov rb15,0
@@ -342,7 +350,7 @@ mov vw_addr, unif # start the VDW
 # mc_filter_uv_b0(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
 
 # At this point we have already issued two pairs of texture requests for the current block
-# ra_x_base, ra_x16_base point to the current coordinates for this block
+# ra_x, ra_x16_base point to the current coordinates for this block
 ::mc_filter_uv_b0
 mov ra31, unif
 
@@ -357,9 +365,9 @@ min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
 shl ra_xshift_next, r0, 3
 sub r2, unif, r3 # compute offset from frame base u to frame base v
 add r0, r0, r3
-and rb_x_base_next, r0, ~3 
+and rb_x_next, r0, ~3 
 mov ra_y_next, r1
-add ra_x2_base_next, rb_x_base_next, r2
+add ra_frame_base_next, rb_x_next, r2
 
 # set up VPM write, we need to save 16bit precision
 mov vw_setup, rb21
@@ -408,16 +416,16 @@ mov r3, 0
 # then submit two more texture requests
 
 sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0  
+mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
 mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
 shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
 
 max r2, ra_y, 0  # y
 min r2, r2, rb_frame_height_minus_1
 add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
+add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+add t0s, ra_frame_base, r2   
 
 # generate seven shifted versions
 # interleave with scroll of vertical context
@@ -477,9 +485,9 @@ min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
 shl ra_xshift_next, r0, 3
 sub r2, unif, r3 # compute offset from frame base u to frame base v
 add r0, r0, r3
-and rb_x_base_next, r0, ~3 
+and rb_x_next, r0, ~3 
 mov ra_y_next, r1
-add ra_x2_base_next, rb_x_base_next, r2
+add ra_frame_base_next, rb_x_next, r2
 
 # set up VPM write
 mov vw_setup, rb28
@@ -538,16 +546,16 @@ mov r3, 0
 # then submit two more texture requests
 
 sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0  
-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0  
+mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
 mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
 shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
 
 max r2, ra_y, 0  # y
 min r2, r2, rb_frame_height_minus_1
 add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-add t0s, ra_x2_base, r2   
+add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+add t0s, ra_frame_base, r2   
 
 # generate seven shifted versions
 # interleave with scroll of vertical context
@@ -642,5 +650,511 @@ nop        ; nop ; thrend
 mov interrupt, 1; nop # delay slot 1
 nop        ; nop # delay slot 2
 
+
+
+
+
+# LUMA CODE
+
+# The idea is to form B predictions by doing 8 pixels from ref0 in parallel with 8 pixels from ref1.
+# For P frames we make the second x,y coordinates offset by +8 
+
+################################################################################
+# mc_setup(next_kernel, x, y, ref_y_base, x2, y2, ref_y2_base, frame_width, frame_height, pitch, dst_pitch, offset, shift, pad2)
+::mc_setup
+
+# Read starting kernel
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+mov ra31, unif
+
+# Compute base address for first and second access
+add r0, unif, elem_num # Load x
+max r0, r0, 0; mov r1, unif # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+shl ra_xshift_next, r0, 3 # Compute shifts
+add ra_y, r1, 1
+and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+add r2, r2, r0  # r2 is address for frame0 (not including y offset)
+max r1, r1, 0
+min r1, r1, rb_frame_height_minus_1
+nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
+add t0s, r2, r1 ; mov ra_frame_base, r2
+
+add r0, unif, elem_num # Load x
+max r0, r0, 0; mov r1, unif # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+shl rx_xshift2_next, r0, 3 # Compute shifts
+add ra_y2, r1, 1
+and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+add r2, r2, r0  # r2 is address for frame1 (not including y offset)
+max r1, r1, 0
+min r1, r1, rb_frame_height_minus_1
+nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
+add t0s, r2, r1 ; mov ra_frame_base2, r2
+
+
+# Read image dimensions
+sub rb25,unif,1
+sub rb30,unif,1
+
+# get source pitch
+mov rb16, unif
+
+# get destination pitch
+mov r0, unif
+mov r1, vdw_setup_1(0)
+add rb24, r1, r0
+
+# load constants
+
+mov ra20, 1
+mov ra22, 256
+mov ra30, 64
+
+mov rb20, 0xffffff00
+mov rb22, 255
+mov rb23, 24
+
+# touch vertical context to keep simulator happy
+
+mov ra8, 0
+mov ra9, 0
+mov ra10, 0    
+mov ra11, 0
+mov ra12, 0    
+mov ra13, 0
+mov ra14, 0    
+mov ra15, 0
+
+# Compute part of VPM to use for DMA output
+mov r2, qpu_num
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+shl r0, r0, 5
+add rb27, r0, r1
+
+# Compute part of VPM to save data into
+mov r2, qpu_num   # qpu_num = abcd
+mov r1, r2        
+asr r1, r1, 2     
+shl r1, r1, 6     
+mov r0, r2        
+and r0, r0, 3     
+add r0, r0, r1    
+mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
+add rb28, r0, r1  
+
+mov rb12,unif # offset before shift
+mov rb13,unif # shift 
+
+# Dump padding words
+mov r0, unif
+
+# submit texture requests for second line
+max r1, ra_y, 0
+min r1, r1, rb_frame_height_minus_1
+add ra_y, ra_y, 1
+nop ; mul24 r1, r1, rb_pitch
+add t0s, r1, ra_frame_base
+
+max r1, ra_y2, 0
+min r1, r1, rb_frame_height_minus_1
+bra -, ra31
+add ra_y2, ra_y2, 1           # Delay 1
+nop ; mul24 r1, r1, rb_pitch  # Delay 2
+add t0s, r1, ra_frame_base2   # Delay 3
+
+
+################################################################################
+
+# mc_filter(next_kernel, x, y, frame_base, x2, y2, frame_base2, height, hcoeffs[0], hcoeffs2[0], hcoeffs[1], hcoeffs2[1], vcoeffs[0], vcoeffs2[0], vcoeffs[1], vcoeffs2[1], offsetweight0, offsetweight1, this_dst)
+# In a P block, only the first half of coefficients contain used information.
+# At this point we have already issued two pairs of texture requests for the current block
+# ra_x, ra_x16_base point to the current coordinates for this block
+::mc_filter
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+mov rx_xshift2, rx_xshift2_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num # Load x
+max r0, r0, 0; mov r1, unif # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+shl ra_xshift_next, r0, 3 # Compute shifts
+mov ra_y_next, r1
+and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+add ra_frame_base_next, r2, r0  # r2 is address for frame0 (not including y offset)
+
+add r0, unif, elem_num # Load x
+max r0, r0, 0   ; mov r1, unif # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+shl rx_xshift2_next, r0, 3 # Compute shifts
+add ra_y2_next, r1, 1
+and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
+ 
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+# get filter coefficients and discard unused B frame values
+mov r0, unif
+mov.ifnz -, unif # Alternate coefficients are unused for P frames
+asr ra3, r0, rb23;      mul24 r0, r0, ra22 # These may need some pre-rotation to be used in B frames correctly
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+mov.ifnz -, unif
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+asr ra4, r0, rb23;      mov r0, unif
+mov.ifnz -, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+mov.ifnz -, unif
+asr rb7, r0, rb23;      mul24 r0, r0, ra22
+asr rb6, r0, rb23;      mul24 r0, r0, ra22
+asr rb5, r0, rb23;      mul24 r0, r0, ra22
+asr rb4, r0, rb23
+
+mov r0, unif # Frame0 offset/weight
+mov.ifnz -, unif # Frame1 offset/weight unused
+asr rb15, r0, r2  # Compute offset from MSBs
+shl r0, r0, r2
+asr rb14, r0, r2  # Compute weight from LSBs
+
+# r3 is loop counter
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+mov r3, 0
+
+:yloop
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+# If we knew there was no clipping then this code would get simpler.
+# Perhaps we could add on the pitch and clip using larger values?
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0  
+mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, rx_xshift2       
+mov.ifz ra_y2, ra_y2_next
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1            ; mul24 r2, r2, r3                     
+add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
+
+max r2, ra_y2, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3                     
+add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+  
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+# apply horizontal filter         
+nop                  ; mul24 r2, r0, ra0
+nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+nop                  ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+add r0, r2, r3       ; mov r3, rb31
+sub.setf -, r3, 8    ; mov ra12, ra13
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+brr.anyn -, r:yloop
+mov ra13, ra14       # Delay slot 1
+mov ra14, ra15       # Delay slot 2
+mov ra15, r0         # Delay slot 3
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r1, ra14, rb10
+nop                     ; mul24 r0, ra13, rb9
+add r1, r1, r0          ; mul24 r0, ra12, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb11
+add r1, r1, r0          ; mul24 r0, ra8, rb4
+add r1, r1, r0          ; mul24 r0, ra9, rb5
+add r1, r1, r0          ; mul24 r0, ra10, rb6
+add r1, r1, r0          ; mul24 r0, ra11, rb7
+
+add r1, r1, r0          ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+asr r1, r1, 14
+nop                     ; mul24 r1, r1, rb14
+add r1, r1, rb12
+asr r1, r1, rb13
+brr.anyn -, r:yloop 
+add r1, r1, rb15       # Delay 1
+min r1, r1, rb22       # Delay 2
+max vpm, r1, 0         # Delay 3
+
+# DMA out
+
+bra -, ra31
+mov vw_setup, rb26 # VDW setup 0    Delay 1
+mov vw_setup, rb29 # Stride         Delay 2
+mov vw_addr, unif # start the VDW   Delay 3
+
+
+
+################################################################################
+
+# mc_filter_b(next_kernel, x, y, frame_base, x2, y2, frame_base2, width_height, hcoeffs[0], hcoeffs2[0], hcoeffs[1], hcoeffs2[1], vcoeffs[0], vcoeffs2[0], vcoeffs[1], vcoeffs2[1], offsetweight0, offsetweight1, this_dst)
+# In a P block, only the first half of coefficients contain used information.
+# At this point we have already issued two pairs of texture requests for the current block
+# May be better to just send 16.16 motion vector and figure out the coefficients inside this block (only 4 cases so can compute hcoeffs in around 24 cycles?)
+# Can fill in the coefficients so only 
+# Can also assume default weighted prediction for B frames.
+# Perhaps can unpack coefficients in a more efficient manner by doing H/V for a and b at the same time?
+# Or possibly by taking advantage of symmetry?
+# From 19->7 32bits per command.
+::mc_filter_b
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+mov ra31, unif
+
+# per-channel shifts were calculated on the *previous* invocation
+
+mov ra_xshift, ra_xshift_next
+mov rx_xshift2, rx_xshift2_next
+
+# get base addresses and per-channel shifts for *next* invocation
+add r0, unif, elem_num # Load x
+max r0, r0, 0; mov r1, unif # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+shl ra_xshift_next, r0, 3 # Compute shifts
+mov ra_y_next, r1
+and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+add ra_frame_base_next, r2, r0  # r2 is address for frame0 (not including y offset)
+
+add r0, unif, elem_num # Load x
+max r0, r0, 0   ; mov r1, unif # Load y
+min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+shl rx_xshift2_next, r0, 3 # Compute shifts
+add ra_y2_next, r1, 1
+and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
+ 
+
+# set up VPM write
+mov vw_setup, rb28
+
+# get width,height of block
+mov r2, 16
+mov r0, unif
+shr r1, r0, r2 # Extract width
+sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+and r0, r0, rb22 # Extract height
+add rb17, r0, 5
+add rb18, r0, 7
+shl r0, r0, 7
+add r0, r0, r1 # Combine width and height of destination area
+shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+add rb26, r0, rb27
+
+# get filter coefficients and discard unused B frame values
+mov r0, unif
+mov r1, 1
+mov.ifnz r0, unif # Alternate coefficients are unused for P frames
+nop              ;      mul24 r0, r0 << 13, r1 << 13
+asr ra3, r0, rb23;      mul24 r0, r0, ra22 
+nop              ;      mul24 r0, r0 << 14, r1 << 14
+asr ra2, r0, rb23;      mul24 r0, r0, ra22
+nop              ;      mul24 r0, r0 << 15, r1 << 15 # Adjust such that a rotate of 1 will produce the values with first 8 on left, second 8 on right
+asr ra1, r0, rb23;      mul24 r0, r0, ra22
+asr ra0, r0, rb23;      mov r0, unif
+mov.ifnz r0, unif
+nop              ;      mul24 r0, r0 << 9, r1 << 9
+asr ra7, r0, rb23;      mul24 r0, r0, ra22
+nop              ;      mul24 r0, r0 << 10, r1 << 10
+asr ra6, r0, rb23;      mul24 r0, r0, ra22
+nop              ;      mul24 r0, r0 << 11, r1 << 11
+asr ra5, r0, rb23;      mul24 r0, r0, ra22
+nop              ;      mul24 r0, r0 << 12, r1 << 12
+asr ra4, r0, rb23;      mov r0, unif
+mov.ifnz r0, unif
+asr rb11, r0, rb23;     mul24 r0, r0, ra22
+asr rb10, r0, rb23;     mul24 r0, r0, ra22
+asr rb9, r0, rb23;      mul24 r0, r0, ra22
+asr rb8, r0, rb23;      mov r0, unif
+mov.ifnz r0, unif
+asr rb7, r0, rb23;      mul24 r0, r0, ra22
+asr rb6, r0, rb23;      mul24 r0, r0, ra22
+asr rb5, r0, rb23;      mul24 r0, r0, ra22
+asr rb4, r0, rb23
+
+mov r0, unif # Frame0 offset/weight
+mov.ifnz r0, unif # Frame1 offset/weight unused
+asr rb15, r0, r2  # Compute offset from MSBs
+shl r0, r0, r2
+asr rb14, r0, r2  # Compute weight from LSBs
+
+# r3 is loop counter
+
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+mov r3, 0
+
+:yloopb
+# retrieve texture results and pick out bytes
+# then submit two more texture requests
+
+# If we knew there was no clipping then this code would get simpler.
+# Perhaps we could add on the pitch and clip using larger values?
+
+sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0  
+mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+shr r1, r4, rx_xshift2       
+mov.ifz ra_y2, ra_y2_next
+
+max r2, ra_y, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y, ra_y, 1            ; mul24 r2, r2, r3                     
+add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
+
+max r2, ra_y2, 0  # y
+min r2, r2, rb_frame_height_minus_1
+add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3                     
+add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+  
+
+# generate seven shifted versions
+# interleave with scroll of vertical context
+
+mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+
+# apply horizontal filter         
+nop                  ; mul24 r2, r0, ra0
+nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+nop                  ; mul24      r3, ra1 << 1, r0 << 1
+nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+add r0, r2, r3       ; mov r3, rb31
+sub.setf -, r3, 8    ; mov ra12, ra13
+mov ra9, ra10
+mov ra10, ra11
+mov ra11, ra12
+mov ra12, ra13
+brr.anyn -, r:yloopb
+mov ra13, ra14       # Delay slot 1
+mov ra14, ra15       # Delay slot 2
+mov ra15, r0         # Delay slot 3
+ 
+# apply vertical filter and write to VPM
+
+nop                     ; mul24 r1, ra14, rb10
+nop                     ; mul24 r0, ra13, rb9
+add r1, r1, r0          ; mul24 r0, ra12, rb8
+add r1, r1, r0          ; mul24 r0, ra15, rb11
+add r1, r1, r0          ; mul24 r0, ra8, rb4
+add r1, r1, r0          ; mul24 r0, ra9, rb5
+add r1, r1, r0          ; mul24 r0, ra10, rb6
+add r1, r1, r0          ; mul24 r0, ra11, rb7
+
+add r1, r1, r0          ; mov -, vw_wait
+sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+asr r1, r1, 14           
+nop                     ; mul24 r1, r1 << 8, ra20 << 8 # Rotate to align left and right halves
+add r1, r1, ra30        ; mul24 r0, r1, rb14
+add r1, r1, r0
+brr.anyn -, r:yloopb 
+asr r1, r1, 7          # Delay 1
+min r1, r1, rb22       # Delay 2
+max vpm, r1, 0         # Delay 3
+
+# DMA out
+bra -, ra31
+mov vw_setup, rb26 # VDW setup 0    Delay 1
+mov vw_setup, rb29 # Stride         Delay 2
+mov vw_addr, unif # start the VDW   Delay 3
+
+################################################################################
+
+# mc_interrupt_exit12()
+::mc_interrupt_exit12 
+mov  -, vw_wait # wait on the VDW
+
+ldtmu0
+ldtmu0
+ldtmu0
+ldtmu0
+
+mov -,sacq(0) # 1 
+mov -,sacq(0) # 2 
+mov -,sacq(0) # 3 
+mov -,sacq(0) # 4 
+mov -,sacq(0) # 5 
+mov -,sacq(0) # 6 
+mov -,sacq(0) # 7 
+mov -,sacq(0) # 8 
+mov -,sacq(0) # 9 
+mov -,sacq(0) # 10 
+mov -,sacq(0) # 11 
+
+nop        ; nop ; thrend
+mov interrupt, 1; nop # delay slot 1
+nop        ; nop # delay slot 2
+
+
 ::mc_end
 # Do not add code here because mc_end must appear after all other code.
-- 
1.9.1


From d2eb316fb5c21bd384c28f3815f24ef5af682513 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 20 May 2015 19:58:30 +0100
Subject: [PATCH 52/77] Added support for fast cache flush in deblocker

---
 libavcodec/hevc_filter.c   |   46 +-
 libavcodec/rpi_qpu.c       |    6 +
 libavcodec/rpi_qpu.h       |    2 +
 libavcodec/rpi_shader.c    | 1028 +++++++++++++++++++++++++++++---------------
 libavcodec/rpi_shader.h    |   16 +-
 libavcodec/rpi_user_vcsm.h |   22 +
 6 files changed, 769 insertions(+), 351 deletions(-)

diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 23fe07f..66476b6 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -37,6 +37,11 @@
 
 #include "bit_depth_template.c"
 
+#ifdef RPI
+#include "rpi_user_vcsm.h"
+#include "rpi_qpu.h"
+#endif
+
 #define LUMA 0
 #define CB 1
 #define CR 2
@@ -871,15 +876,46 @@ static void flush_buffer(AVBufferRef *bref) {
     gpu_cache_flush(p);
 }
 
-static void ff_hevc_flush_chroma(HEVCContext *s)
+// Return Physical address for this image
+static int ff_hevc_buf_base(AVBufferRef *bref) {
+  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+  return p->vc & 0x3fffffff;
+}
+
+static void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
 {
     if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
             s->nal_unit_type == NAL_TSA_N   ||
             s->nal_unit_type == NAL_STSA_N  ||
             s->nal_unit_type == NAL_RADL_N  ||
-            s->nal_unit_type == NAL_RASL_N )) {           
+            s->nal_unit_type == NAL_RASL_N )) {  
+#define RPI_FAST_CACHEFLUSH            
+#ifdef RPI_FAST_CACHEFLUSH
+        struct vcsm_user_clean_invalid_s iocache = {}; 
+        int curr_y = f->progress->data[0];
+        int sz,base;
+        if (curr_y < 0) curr_y = 0;
+        if (n<=curr_y) return; // Should not happen
+        sz = s->frame->linesize[1] * (n-curr_y);
+        base = s->frame->linesize[1] * curr_y;
+        iocache.s[0].cmd = 3; // Flush L1 cache
+        iocache.s[0].addr = 0; 
+        iocache.s[0].size  = 0;
+
+        iocache.s[1].cmd = 2;
+        iocache.s[1].addr = ff_hevc_buf_base(s->frame->buf[1]) + base;
+        iocache.s[1].size  = sz;
+        
+        iocache.s[2].cmd = 2;
+        iocache.s[2].addr = ff_hevc_buf_base(s->frame->buf[2]) + base;
+        iocache.s[2].size  = sz;
+
+        vcsm_clean_invalid( gpu_get_mailbox(), &iocache );
+
+#else            
         flush_buffer(s->frame->buf[1]);
         flush_buffer(s->frame->buf[2]);
+#endif
         //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
         //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
         //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
@@ -901,7 +937,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
             sao_filter_CTB(s, x, y - ctb_size);
             if (s->threads_type & FF_THREAD_FRAME ) {
 #ifdef RPI_INTER_QPU
-                ff_hevc_flush_chroma(s);
+                ff_hevc_flush_chroma(s,&s->ref->tf, y);
 #endif
                 ff_thread_report_progress(&s->ref->tf, y, 0);
             }
@@ -910,7 +946,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
             sao_filter_CTB(s, x , y);
             if (s->threads_type & FF_THREAD_FRAME ) {
 #ifdef RPI_INTER_QPU
-                ff_hevc_flush_chroma(s);
+                ff_hevc_flush_chroma(s, &s->ref->tf, y + ctb_size);
 #endif
                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
             }
@@ -920,7 +956,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
         //int currh = s->ref->tf.progress->data[0];
         //if (((y + ctb_size)&63)==0)
 #ifdef RPI_INTER_QPU
-        ff_hevc_flush_chroma(s);
+        ff_hevc_flush_chroma(s, &s->ref->tf, y + ctb_size - 4);
 #endif
         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
     }
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 729cdb3..45bba46 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -234,6 +234,12 @@ int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p)
   return r;
 }
 
+int gpu_get_mailbox(void)
+{
+  assert(gpu);
+  return gpu->mb;
+}
+
 void gpu_cache_flush(GPU_MEM_PTR_T *p)
 {
   void *tmp = vcsm_lock(p->vcsm_handle); 
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index 543c84b..88965e5 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -49,4 +49,6 @@ extern int rpi_test_shader(void);
 extern void rpi_do_block(const unsigned char *in_buffer_vc, int src_pitch, unsigned char *dst_vc, int dst_pitch, unsigned char *dst);
 extern void rpi_do_block_arm(const unsigned char *in_buffer, int src_pitch, unsigned char *dst, int dst_pitch);
 
+extern int gpu_get_mailbox(void);
+
 #endif
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 3f04d80..9c30e32 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -23,11 +23,11 @@ __attribute__((aligned(8)))
 unsigned int rpi_shader[] = {
 // ::mc_setup_uv
 /* [0x00000000] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000008] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
+/* [0x00000008] */ 0x0c9a0f80, 0x10020427, // add ra_x, unif, elem_num
 /* [0x00000010] */ 0x15827d80, 0x10020767, // mov ra_y, unif
-/* [0x00000018] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
+/* [0x00000018] */ 0x15827d80, 0x10020627, // mov ra_frame_base, unif
 /* [0x00000020] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000028] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
+/* [0x00000028] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_frame_base
 /* [0x00000030] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
 /* [0x00000038] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
 /* [0x00000040] */ 0x15827d80, 0x10021427, // mov rb16, unif
@@ -35,360 +35,708 @@ unsigned int rpi_shader[] = {
 /* [0x00000050] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
 /* [0x00000058] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
 /* [0x00000060] */ 0x00000001, 0xe0020527, // mov ra20, 1
-/* [0x00000068] */ 0x00000020, 0xe0020567, // mov ra21, 32
-/* [0x00000070] */ 0x00000100, 0xe00205a7, // mov ra22, 256
-/* [0x00000078] */ 0x00000008, 0xe00205e7, // mov ra23, 8
-/* [0x00000080] */ 0x00000040, 0xe00207a7, // mov ra30, 64
-/* [0x00000088] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
-/* [0x00000090] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
-/* [0x00000098] */ 0x00000018, 0xe00215e7, // mov rb23, 24
-/* [0x000000a0] */ 0x00000000, 0xe0020227, // mov ra8, 0
-/* [0x000000a8] */ 0x00000000, 0xe0020267, // mov ra9, 0
-/* [0x000000b0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
-/* [0x000000b8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
-/* [0x000000c0] */ 0x00000000, 0xe0020327, // mov ra12, 0
-/* [0x000000c8] */ 0x00000000, 0xe0020367, // mov ra13, 0
-/* [0x000000d0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
-/* [0x000000d8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x000000e0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x000000e8] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
-/* [0x000000f0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x000000f8] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000100] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000108] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000110] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000118] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000120] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000128] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
-/* [0x00000130] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
-/* [0x00000138] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00000140] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000148] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
-/* [0x00000150] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00000158] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000160] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000168] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000170] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000178] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000180] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000188] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x00000190] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x00000198] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
-/* [0x000001a0] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
-/* [0x000001a8] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
-/* [0x000001b0] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
-/* [0x000001b8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
-/* [0x000001c0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
-/* [0x000001c8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-/* [0x000001d0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x000001d8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000001e0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000001e8] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
-/* [0x000001f0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x000001f8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-/* [0x00000200] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
-/* [0x00000208] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x00000210] */ 0x15827d80, 0x10021327, // mov rb12,unif
-/* [0x00000218] */ 0x15827d80, 0x10021367, // mov rb13,unif
-/* [0x00000220] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000228] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000230] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000238] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000240] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000248] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000250] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
-/* [0x00000258] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+/* [0x00000068] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+/* [0x00000070] */ 0x00000040, 0xe00207a7, // mov ra30, 64
+/* [0x00000078] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x00000080] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x00000088] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x00000090] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x00000098] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x000000a0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x000000a8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x000000b0] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x000000d0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x000000d8] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+/* [0x000000e0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x000000e8] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x000000f0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x000000f8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000100] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000108] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000110] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000118] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00000120] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00000128] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00000130] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000138] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+/* [0x00000140] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00000148] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000150] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000158] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000160] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000168] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000170] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000178] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000180] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000188] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
+/* [0x00000190] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+/* [0x00000198] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
+/* [0x000001a0] */ 0x15427d80, 0x10020827, // mov r0, ra_x
+/* [0x000001a8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x000001b0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
+/* [0x000001b8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+/* [0x000001c0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x000001c8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000001d0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000001d8] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
+/* [0x000001e0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x000001e8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+/* [0x000001f0] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
+/* [0x000001f8] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+/* [0x00000200] */ 0x15827d80, 0x10021327, // mov rb12,unif
+/* [0x00000208] */ 0x15827d80, 0x10021367, // mov rb13,unif
+/* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000218] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000220] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000228] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000230] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000238] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000240] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
+/* [0x00000248] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
 // ::mc_filter_uv
-/* [0x00000260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000268] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000270] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000278] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000280] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000288] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000290] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000298] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000002a0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000002a8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000002b0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000002b8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000002c0] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000002c8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002e8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000002f0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000340] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000348] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000350] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000358] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x00000360] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000368] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000370] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
-/* [0x00000378] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000380] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
-/* [0x00000388] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000390] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
-/* [0x00000398] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000003a0] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
-/* [0x000003a8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000003b0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000258] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000260] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000268] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000270] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000278] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000280] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000288] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000290] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x00000298] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000002a0] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x000002a8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000002b0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000002b8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002c0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000002c8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000002d0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000002d8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000002e0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000002e8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000002f0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000002f8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000300] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000330] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000338] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000340] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000348] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000350] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000358] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000360] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+/* [0x00000368] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000370] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+/* [0x00000378] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000380] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
+/* [0x00000388] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000390] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
+/* [0x00000398] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000003a0] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x000003b8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000003c0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x000003c8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x000003d0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003d8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003e0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003e8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003f0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003f8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000400] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000408] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000410] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000418] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000420] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000428] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000430] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000438] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000440] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000448] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000450] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000458] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000460] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000468] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000470] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000478] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000480] */ 0x00000020, 0xe0021327, // mov rb12,32
-/* [0x00000488] */ 0x00000006, 0xe0021367, // mov rb13,6
-/* [0x00000490] */ 0x00000001, 0xe00213a7, // mov rb14,1
-/* [0x00000498] */ 0x00000000, 0xe00213e7, // mov rb15,0
-/* [0x000004a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000004a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000004b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000004b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000004c0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000004c8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000004d0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000004d8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
-/* [0x000004e0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
-/* [0x000004e8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
-/* [0x000004f0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004f8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
-/* [0x00000500] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000508] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000510] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000518] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000520] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000528] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000530] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000538] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000540] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000548] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000550] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000003a8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000003b0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+/* [0x000003b8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x000003c0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003c8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003d0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003d8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003e0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+/* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000400] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000420] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000430] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000440] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000448] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000450] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000458] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000460] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000468] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000470] */ 0x00000020, 0xe0021327, // mov rb12,32
+/* [0x00000478] */ 0x00000006, 0xe0021367, // mov rb13,6
+/* [0x00000480] */ 0x00000001, 0xe00213a7, // mov rb14,1
+/* [0x00000488] */ 0x00000000, 0xe00213e7, // mov rb15,0
+/* [0x00000490] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000498] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000004a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000004a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000004b0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000004b8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000004c0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000004c8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+/* [0x000004d0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+/* [0x000004d8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+/* [0x000004e0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000004e8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+/* [0x000004f0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000004f8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000500] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000508] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000510] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000518] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000520] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000528] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000530] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000538] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000540] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x00000558] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000560] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000568] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000570] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000578] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000580] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000588] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000590] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000598] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x000005a0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000005a8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x000005b0] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x000005b8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000005c0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005c8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000005d0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000005d8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000005e0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000005e8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000005f0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000005f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000600] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000608] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000610] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000618] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000620] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000628] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000630] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000638] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000640] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000648] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000650] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x00000658] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000660] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000668] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000670] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000678] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000548] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000550] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000558] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000560] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000568] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000570] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000578] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000580] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000588] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x00000590] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000598] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x000005a0] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x000005a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000005b0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000005c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000005c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000005d0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000005d8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000005e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000005e8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000005f0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000005f8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000600] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000608] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000610] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000618] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000620] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000628] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000630] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000638] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000640] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000648] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000650] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000658] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000668] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000680] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000688] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000690] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000698] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000006a0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000006a8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000006b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000006b8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000006c0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x000006c8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x000006d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000006d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000006e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000006e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000006f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000006f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000700] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000708] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000710] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000718] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000720] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000728] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000730] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000738] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000740] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000748] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000750] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000758] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000760] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000768] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000770] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
-/* [0x00000778] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000780] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
-/* [0x00000788] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000790] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000798] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x000007a0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000007a8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000007b0] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000670] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000678] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+/* [0x00000680] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00000688] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000690] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000698] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000006a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000006a8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000006b0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x000006b8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+/* [0x000006c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000006c8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000006d0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000006d8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000006e0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000006e8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000006f0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000006f8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000700] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000708] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000710] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000718] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000720] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000728] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000730] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000738] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000740] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000748] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000750] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000758] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000760] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+/* [0x00000768] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000770] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+/* [0x00000778] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000780] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000788] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000790] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000798] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000007a0] */ 0x009e7000, 0x100009e7, // nop
 // ::mc_filter_uv_b
-/* [0x000007b8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000007c0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000007c8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000007d0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000007d8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000007e0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000007e8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000007f0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000007f8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
-/* [0x00000800] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000808] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
-/* [0x00000810] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000818] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000820] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000828] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000830] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000838] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000840] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000848] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000850] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000858] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000860] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000868] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000870] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000878] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000880] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000888] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000890] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000898] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008a0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008a8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008b0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000008b8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008c0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008c8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008d0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x000008d8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000008e0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000008e8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000008f0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000008f8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000007a8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000007b0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000007b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000007c0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000007c8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000007d0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000007d8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000007e0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000007e8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x000007f0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000007f8] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x00000800] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000808] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000810] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000830] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000838] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000858] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000860] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000880] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000888] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000890] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000898] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000008a8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008b0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008b8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008c0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x000008c8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000008d0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000008d8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000008e0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008e8] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x00000900] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000908] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
-/* [0x00000910] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
-/* [0x00000918] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000920] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000928] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000930] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000938] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000940] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
-/* [0x00000948] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
-/* [0x00000950] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000958] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000960] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000968] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000970] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000978] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000980] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000988] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000990] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000998] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x000009a0] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x000009a8] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000009b0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000009b8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x000009c0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x000009c8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000009d0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000009d8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000009e0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000009e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000009f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000009f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x00000a00] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x00000a08] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x00000a10] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000a18] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000a20] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000a28] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000a30] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000a38] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a40] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000a48] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000a50] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000a60] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008f0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000008f8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+/* [0x00000900] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00000908] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000910] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000918] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000920] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000928] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000930] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x00000938] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+/* [0x00000940] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000948] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000950] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000958] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000960] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000968] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000970] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000978] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000980] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000988] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000990] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000998] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000009a0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000009a8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x000009b0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000009b8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000009c0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000009c8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000009d0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000009d8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000009e0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000009e8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000009f0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x000009f8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000a00] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000a08] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000a10] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000a18] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000a20] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000a28] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a30] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000a38] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000a40] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000a48] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000a50] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000a58] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a60] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000a78] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a80] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a68] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a70] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a98] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000aa0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000ab0] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a98] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000aa0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000aa8] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000ac0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000ab0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ad8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ae0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b10] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b18] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b20] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000b28] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000b30] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000b10] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000b18] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000b20] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_setup
+/* [0x00000b28] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000b30] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000b38] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000b40] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000b48] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000b50] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000b58] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x00000b60] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000b68] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+/* [0x00000b70] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000b78] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000b80] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+/* [0x00000b88] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
+/* [0x00000b90] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000b98] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000ba0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000ba8] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+/* [0x00000bb0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
+/* [0x00000bb8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000bc0] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+/* [0x00000bc8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000bd0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000bd8] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+/* [0x00000be0] */ 0x8c9e7452, 0x10025e19, // add t0s, r2, r1 ; mov ra_frame_base2, r2
+/* [0x00000be8] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+/* [0x00000bf0] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+/* [0x00000bf8] */ 0x15827d80, 0x10021427, // mov rb16, unif
+/* [0x00000c00] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000c08] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+/* [0x00000c10] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+/* [0x00000c18] */ 0x00000001, 0xe0020527, // mov ra20, 1
+/* [0x00000c20] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+/* [0x00000c28] */ 0x00000040, 0xe00207a7, // mov ra30, 64
+/* [0x00000c30] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x00000c38] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x00000c40] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x00000c48] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x00000c50] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x00000c58] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x00000c60] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x00000c68] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x00000c70] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x00000c78] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x00000c80] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x00000c88] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000c90] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000c98] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000ca0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000ca8] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000cb0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000cb8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000cc0] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00000cc8] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00000cd0] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00000cd8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000ce0] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000ce8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000cf0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000cf8] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000d00] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000d08] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000d10] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000d18] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000d20] */ 0x15827d80, 0x10021327, // mov rb12,unif
+/* [0x00000d28] */ 0x15827d80, 0x10021367, // mov rb13,unif
+/* [0x00000d30] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000d38] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000d40] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000d48] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000d50] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000d58] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+/* [0x00000d60] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
+/* [0x00000d68] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000d70] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000d78] */ 0x0c541dc0, 0xd0020567, // add ra_y2, ra_y2, 1
+/* [0x00000d80] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000d88] */ 0x0c667380, 0x10020e27, // add t0s, r1, ra_frame_base2
+// ::mc_filter
+/* [0x00000d90] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000d98] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000da0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000da8] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
+/* [0x00000db0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000db8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000dc0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000dc8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000dd0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000dd8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000de0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
+/* [0x00000de8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000df0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
+/* [0x00000df8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000e00] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+/* [0x00000e08] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
+/* [0x00000e10] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000e18] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+/* [0x00000e20] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000e28] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000e30] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000e38] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000e40] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000e48] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000e50] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000e58] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000e60] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000e68] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000e70] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000e78] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000e80] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000e88] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000e90] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000e98] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ea0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ea8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000eb0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000eb8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ec0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ec8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ed0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000ed8] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000ee0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000ee8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000ef0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ef8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000f00] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000f08] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f10] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f18] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f20] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
+/* [0x00000f28] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000f30] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000f38] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+/* [0x00000f40] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000f48] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+/* [0x00000f50] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :yloop
+/* [0x00000f58] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+/* [0x00000f60] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+/* [0x00000f68] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00000f70] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000f78] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+/* [0x00000f80] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+/* [0x00000f88] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000f90] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000f98] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+/* [0x00000fa0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+/* [0x00000fa8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+/* [0x00000fb0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000fb8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+/* [0x00000fc0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+/* [0x00000fc8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000fd0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000fd8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000fe0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000fe8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000ff0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000ff8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00001000] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00001008] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00001010] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00001018] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00001020] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00001028] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00001030] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00001038] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00001040] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00001048] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00001050] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00001058] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
+/* [0x00001060] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00001068] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00001070] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00001078] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00001080] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
+/* [0x00001088] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00001090] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00001098] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000010a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000010a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000010b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000010b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000010c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+/* [0x000010c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+/* [0x000010d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+/* [0x000010d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+/* [0x000010e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000010e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000010f0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000010f8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+/* [0x00001100] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+/* [0x00001108] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+/* [0x00001110] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
+/* [0x00001118] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+/* [0x00001120] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00001128] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00001130] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001138] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00001140] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001148] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_filter_b
+/* [0x00001150] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00001158] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00001160] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00001168] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
+/* [0x00001170] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00001178] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00001180] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00001188] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00001190] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00001198] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000011a0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
+/* [0x000011a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000011b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
+/* [0x000011b8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x000011c0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+/* [0x000011c8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
+/* [0x000011d0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000011d8] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+/* [0x000011e0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000011e8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000011f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000011f8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00001200] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00001208] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00001210] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00001218] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00001220] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00001228] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00001230] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00001238] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00001240] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001248] */ 0x00000001, 0xe0020867, // mov r1, 1
+/* [0x00001250] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x00001258] */ 0x409f3001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 13, r1 << 13
+/* [0x00001260] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001268] */ 0x409f2001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 14, r1 << 14
+/* [0x00001270] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001278] */ 0x409f1001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 15, r1 << 15
+/* [0x00001280] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001288] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00001290] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x00001298] */ 0x409f7001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 9, r1 << 9
+/* [0x000012a0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000012a8] */ 0x409f6001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 10, r1 << 10
+/* [0x000012b0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000012b8] */ 0x409f5001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 11, r1 << 11
+/* [0x000012c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000012c8] */ 0x409f4001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 12, r1 << 12
+/* [0x000012d0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000012d8] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x000012e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000012e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000012f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000012f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00001300] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x00001308] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001310] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001318] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001320] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
+/* [0x00001328] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001330] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x00001338] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+/* [0x00001340] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00001348] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+/* [0x00001350] */ 0x00000000, 0xe00208e7, // mov r3, 0
+// :yloopb
+/* [0x00001358] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+/* [0x00001360] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+/* [0x00001368] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00001370] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00001378] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+/* [0x00001380] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+/* [0x00001388] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00001390] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00001398] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+/* [0x000013a0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+/* [0x000013a8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+/* [0x000013b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000013b8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+/* [0x000013c0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+/* [0x000013c8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000013d0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000013d8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000013e0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000013e8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000013f0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000013f8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00001400] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00001408] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00001410] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00001418] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00001420] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00001428] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00001430] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00001438] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00001440] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00001448] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00001450] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00001458] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
+/* [0x00001460] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00001468] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00001470] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00001478] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00001480] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
+/* [0x00001488] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00001490] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00001498] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000014a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000014a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000014b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000014b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000014c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+/* [0x000014c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+/* [0x000014d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+/* [0x000014d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+/* [0x000014e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000014e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000014f0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000014f8] */ 0x4053800e, 0xd00049e1, // nop                     ; mul24 r1, r1 << 8, ra20 << 8
+/* [0x00001500] */ 0x4c78e38f, 0x10024860, // add r1, r1, ra30        ; mul24 r0, r1, rb14
+/* [0x00001508] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x00001510] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloopb
+/* [0x00001518] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00001520] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00001528] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00001530] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001538] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00001540] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001548] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+// ::mc_interrupt_exit12
+/* [0x00001550] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00001558] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001560] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001568] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001570] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001578] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001580] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001588] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001590] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001598] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000015a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000015a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000015b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000015b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000015c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000015c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000015d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000015d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000015e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index cec9901..3fa8531 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -4,11 +4,15 @@
 extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
-#define mc_filter_uv (rpi_shader + 152)
-#define mc_filter_uv_b0 (rpi_shader + 342)
-#define mc_filter_uv_b (rpi_shader + 494)
-#define mc_exit (rpi_shader + 670)
-#define mc_interrupt_exit8 (rpi_shader + 688)
-#define mc_end (rpi_shader + 718)
+#define mc_filter_uv (rpi_shader + 148)
+#define mc_filter_uv_b0 (rpi_shader + 338)
+#define mc_filter_uv_b (rpi_shader + 490)
+#define mc_exit (rpi_shader + 666)
+#define mc_interrupt_exit8 (rpi_shader + 684)
+#define mc_setup (rpi_shader + 714)
+#define mc_filter (rpi_shader + 868)
+#define mc_filter_b (rpi_shader + 1108)
+#define mc_interrupt_exit12 (rpi_shader + 1364)
+#define mc_end (rpi_shader + 1402)
 
 #endif
diff --git a/libavcodec/rpi_user_vcsm.h b/libavcodec/rpi_user_vcsm.h
index cdc4e4d..95b3125 100644
--- a/libavcodec/rpi_user_vcsm.h
+++ b/libavcodec/rpi_user_vcsm.h
@@ -418,6 +418,28 @@ int vcsm_unlock_hdl( unsigned int handle );
 */
 int vcsm_unlock_hdl_sp( unsigned int handle, int cache_no_flush );
 
+/* Clean and/or invalidate the memory associated with this user opaque handle
+**
+** Returns:        non-zero on error
+**
+** structure contains a list of flush/invalidate commands. Commands are:
+** 0: nop
+** 1: invalidate given physical range in L2
+** 2: clean      given physical range in L2
+** 3: clean+invalidate all of L1
+** 4: flush      all of L2 and all of L1
+*/
+struct vcsm_user_clean_invalid_s {
+    struct {
+       unsigned int cmd;
+       unsigned int addr;
+       unsigned int size;
+    } s[8];
+};
+
+int vcsm_clean_invalid( unsigned int handle, struct vcsm_user_clean_invalid_s *s );
+
+
 #ifdef __cplusplus
 }
 #endif
-- 
1.9.1


From 308456ae7d48cbde8a8f0151db59e7e2cf27b584 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 20 May 2015 21:12:55 +0100
Subject: [PATCH 53/77] Added multi mailbox - not working

---
 libavcodec/hevc.c        | 42 +++++++++++++++++++++++++++++----
 libavcodec/rpi_mailbox.c | 47 +++++++++++++++++++++++++++++++++++++
 libavcodec/rpi_mailbox.h |  5 ++++
 libavcodec/rpi_qpu.c     | 61 ++++++++++++++++++++++++++++++++++++++++++++----
 libavcodec/rpi_qpu.h     |  2 ++
 5 files changed, 148 insertions(+), 9 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 79d339c..c3e496f 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -45,6 +45,11 @@
   //#define EARLY_MALLOC
   // Move Inter prediction into separate pass
   #define RPI_INTER
+  
+  #ifdef RPI_INTER_QPU
+    // Define RPI_MULTI_MAILBOX to use the updated mailbox that can launch both QPU and VPU
+    #define RPI_MULTI_MAILBOX
+  #endif
 #endif
 
 // #define DISABLE_MC
@@ -2807,10 +2812,14 @@ static void rpi_inter_clear(HEVCContext *s)
 static void rpi_execute_inter_qpu(HEVCContext *s)
 {
     int k;
-    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;   
-                    
-    if (s->sh.slice_type == I_SLICE)
-        return;
+    int i;
+    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;
+    if (s->sh.slice_type == I_SLICE) {
+#ifdef RPI_MULTI_MAILBOX
+      rpi_execute_transform(s);
+      return;
+#endif
+    }
     for(k=0;k<8;k++) {
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
@@ -2820,6 +2829,22 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
              
     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
 
+#ifdef RPI_MULTI_MAILBOX
+    gpu_cache_flush(&s->coeffs_buf_accelerated);
+    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0,
+                                   qpu_get_fn(QPU_MC_SETUP_UV),
+                                   (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
+                                 );
+    for(i=0;i<4;i++)
+        s->num_coeffs[i] = 0;
+#else
     qpu_run_shader8(qpu_get_fn(QPU_MC_SETUP_UV),
       (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
       (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
@@ -2830,6 +2855,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
       (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
       (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
       );
+#endif
 }
 #endif
 
@@ -2907,6 +2933,12 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
           if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->sps->width) {
             // Transform all blocks
             // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+#ifdef RPI_MULTI_MAILBOX
+            // Kick off inter prediction on QPUs
+            rpi_execute_inter_qpu(s);
+            // Perform luma inter prediction
+            rpi_execute_inter_cmds(s);         
+#else
             rpi_execute_transform(s);
             // Perform inter prediction
             rpi_execute_inter_cmds(s);
@@ -2914,6 +2946,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
             // Kick off inter prediction on QPUs
             rpi_execute_inter_qpu(s);
 #endif
+#endif
+
             // Wait for transform completion
             vpu_wait(s->vpu_id);
             
diff --git a/libavcodec/rpi_mailbox.c b/libavcodec/rpi_mailbox.c
index 77a56dd..3904efc 100644
--- a/libavcodec/rpi_mailbox.c
+++ b/libavcodec/rpi_mailbox.c
@@ -276,6 +276,53 @@ unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigne
    return p[5];
 }
 
+void execute_multi(int file_desc,
+   unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout,
+   unsigned num_qpus_2, unsigned control_2, unsigned noflush_2, unsigned timeout_2,
+   unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5,
+   unsigned code_2, unsigned r0_2, unsigned r1_2, unsigned r2_2, unsigned r3_2, unsigned r4_2, unsigned r5_2) {
+   int i=0;
+   unsigned p[32];
+
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+   p[i++] = 0x30018; // (the tag id)
+   p[i++] = 88; // (size of the buffer)
+   p[i++] = 88; // (size of the data)
+
+   p[i++] = num_qpus;
+   p[i++] = control;
+   p[i++] = noflush;
+   p[i++] = timeout; // ms
+
+   p[i++] = num_qpus_2;
+   p[i++] = control_2;
+   p[i++] = noflush_2;
+   p[i++] = timeout_2; // ms
+
+   p[i++] = code;
+   p[i++] = r0;
+   p[i++] = r1;
+   p[i++] = r2;
+   p[i++] = r3;
+   p[i++] = r4;
+   p[i++] = r5;
+
+   p[i++] = code_2;
+   p[i++] = r0_2;
+   p[i++] = r1_2;
+   p[i++] = r2_2;
+   p[i++] = r3_2;
+   p[i++] = r4_2;
+   p[i++] = r5_2;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return;
+}
+
 int mbox_open() {
    int file_desc;
 
diff --git a/libavcodec/rpi_mailbox.h b/libavcodec/rpi_mailbox.h
index c264d2e..5898102 100644
--- a/libavcodec/rpi_mailbox.h
+++ b/libavcodec/rpi_mailbox.h
@@ -15,6 +15,11 @@ extern void unmapmem(void *addr, unsigned size);
 
 extern unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
 extern unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout);
+extern void execute_multi(int file_desc,
+   unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout,
+   unsigned num_qpus_2, unsigned control_2, unsigned noflush_2, unsigned timeout_2,
+   unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5,
+   unsigned code_2, unsigned r0_2, unsigned r1_2, unsigned r2_2, unsigned r3_2, unsigned r4_2, unsigned r5_2);
 extern unsigned qpu_enable(int file_desc, unsigned enable);
 
 #endif
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 45bba46..d56fd01 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -120,7 +120,7 @@ static pthread_cond_t post_cond_head = PTHREAD_COND_INITIALIZER;
 static pthread_cond_t post_cond_tail = PTHREAD_COND_INITIALIZER;
 static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-static int vpu_cmds[MAXCMDS][8];
+static int vpu_cmds[MAXCMDS][16];
 static volatile int vpu_async_tail=0; // Contains the number of posted jobs
 static volatile int vpu_async_head=0;
 #endif
@@ -343,6 +343,7 @@ unsigned int vpu_get_constants(void) {
 static void *vpu_start(void *arg) {
   while(1) {
     int *p;
+    int qpu_code;
     pthread_mutex_lock(&post_mutex);
     while( vpu_async_tail - vpu_async_head <= 0)
     {
@@ -355,12 +356,25 @@ static void *vpu_start(void *arg) {
     if (p[6] == -1) {
       break; // Last job
     }
-    if (p[7]) {
+    qpu_code = p[7];
+    //if (p[7]) {
         //GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
         //gpu_cache_flush(buf);
+    //}
+    if (!qpu_code) {
+      vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
+    } else {
+      int i;
+      for(i=0;i<8;i++) {
+        gpu->mail[i*2] = p[8+i];
+        gpu->mail[i*2 + 1] = qpu_code;  
+      }
+     
+      execute_multi(gpu->mb,8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
+                              0, 0, 0, 0,
+                              p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
+                              0,    0   , 0   , 0   , 0   , 0   , 0); // VPU1
     }
-    vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
-    
     pthread_mutex_lock(&post_mutex);
     vpu_async_head++;
     pthread_cond_broadcast(&post_cond_head);
@@ -397,7 +411,43 @@ int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned
     p[4] = r3;
     p[5] = r4;
     p[6] = r5;
-    p[7] = (int) buf;
+    p[7] = 0;
+    if (num<=1)
+      pthread_cond_broadcast(&post_cond_tail); // Otherwise the vpu thread must already be awake
+    pthread_mutex_unlock(&post_mutex);
+    return id;
+  }
+}
+
+int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, 
+                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8)
+{
+    
+  pthread_mutex_lock(&post_mutex);
+  {
+    int id = vpu_async_tail++;
+    int *p = vpu_cmds[id%MAXCMDS];
+    int num = vpu_async_tail - vpu_async_head;
+    if (num>MAXCMDS) {
+      printf("Too many commands submitted\n");
+      exit(-1);
+    }
+    p[0] = vpu_code;
+    p[1] = r0;
+    p[2] = r1;
+    p[3] = r2;
+    p[4] = r3;
+    p[5] = r4;
+    p[6] = r5;
+    p[7] = qpu_code;
+    p[8 ] = unifs1;
+    p[9 ] = unifs2;
+    p[10] = unifs3;
+    p[11] = unifs4;
+    p[12] = unifs5;
+    p[13] = unifs6;
+    p[14] = unifs7;
+    p[15] = unifs8;
     if (num<=1)
       pthread_cond_broadcast(&post_cond_tail); // Otherwise the vpu thread must already be awake
     pthread_mutex_unlock(&post_mutex);
@@ -963,4 +1013,5 @@ void rpi_do_block(const uint8_t *in_buffer_vc, int src_pitch, uint8_t *dst_vc, i
 }
 
 
+
 #endif
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index 88965e5..9e5ebe7 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -41,6 +41,8 @@ extern unsigned int vpu_get_fn(void);
 extern unsigned int vpu_get_constants(void);
 extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
 extern int vpu_post_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf);
+int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, 
+                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
 extern void vpu_wait( int id);
 
 // Simple test of shader code
-- 
1.9.1


From 791525c3bd6ea49fe00492e1b98de6804f77ef40 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 21 May 2015 16:50:02 +0100
Subject: [PATCH 54/77] Pass qpu number in as uniform

---
 libavcodec/hevc.c          |    2 +-
 libavcodec/rpi_shader.c    | 1288 ++++++++++++++++++++++----------------------
 libavcodec/rpi_shader.h    |   20 +-
 libavcodec/rpi_shader.qasm |   10 +-
 4 files changed, 657 insertions(+), 663 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index c3e496f..dac9860 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2798,6 +2798,7 @@ static void rpi_inter_clear(HEVCContext *s)
         *s->u_mvs[i]++ = pic_height;
         *s->u_mvs[i]++ = s->frame->linesize[1];
         *s->u_mvs[i]++ = s->frame->linesize[2];
+        *s->u_mvs[i]++ = i;
         if (weight_flag) {
             *s->u_mvs[i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
             *s->u_mvs[i]++ = s->sh.chroma_log2_weight_denom + 6;
@@ -2805,7 +2806,6 @@ static void rpi_inter_clear(HEVCContext *s)
             *s->u_mvs[i]++ = 1 << 5;
             *s->u_mvs[i]++ = 6;
         }
-        s->u_mvs[i] += 1;  // Padding words
     }
 }
 
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index 9c30e32..a0f0282 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -48,8 +48,8 @@ unsigned int rpi_shader[] = {
 /* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
 /* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
 /* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x000000d0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x000000d8] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+/* [0x000000d0] */ 0x15827d80, 0x100208e7, // mov r3, unif
+/* [0x000000d8] */ 0x119c17c0, 0xd00208a7, // shl r2, r3, 1
 /* [0x000000e0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
 /* [0x000000e8] */ 0x159e7480, 0x10020867, // mov r1, r2
 /* [0x000000f0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
@@ -60,669 +60,669 @@ unsigned int rpi_shader[] = {
 /* [0x00000118] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
 /* [0x00000120] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
 /* [0x00000128] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00000130] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000138] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
-/* [0x00000140] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00000148] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000150] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000158] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000160] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000168] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000170] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000178] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x00000180] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x00000188] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
-/* [0x00000190] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
-/* [0x00000198] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
-/* [0x000001a0] */ 0x15427d80, 0x10020827, // mov r0, ra_x
-/* [0x000001a8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
-/* [0x000001b0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
-/* [0x000001b8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-/* [0x000001c0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x000001c8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000001d0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000001d8] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
-/* [0x000001e0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x000001e8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-/* [0x000001f0] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
-/* [0x000001f8] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x00000200] */ 0x15827d80, 0x10021327, // mov rb12,unif
-/* [0x00000208] */ 0x15827d80, 0x10021367, // mov rb13,unif
-/* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000218] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000220] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000228] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000230] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000238] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000240] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
-/* [0x00000248] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+/* [0x00000130] */ 0x119c17c0, 0xd00208a7, // shl r2, r3, 1
+/* [0x00000138] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00000140] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000148] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000150] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000158] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000160] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000168] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000170] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000178] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000180] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
+/* [0x00000188] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+/* [0x00000190] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
+/* [0x00000198] */ 0x15427d80, 0x10020827, // mov r0, ra_x
+/* [0x000001a0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x000001a8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
+/* [0x000001b0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+/* [0x000001b8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x000001c0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000001c8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000001d0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
+/* [0x000001d8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x000001e0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+/* [0x000001e8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
+/* [0x000001f0] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+/* [0x000001f8] */ 0x15827d80, 0x10021327, // mov rb12,unif
+/* [0x00000200] */ 0x15827d80, 0x10021367, // mov rb13,unif
+/* [0x00000208] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000210] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000218] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000220] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000228] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000230] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
+/* [0x00000238] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
 // ::mc_filter_uv
-/* [0x00000250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000258] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000260] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000268] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000270] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000278] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000280] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000288] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000290] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
-/* [0x00000298] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000002a0] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
-/* [0x000002a8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000002b0] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000002b8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000002c0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000002c8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000002d0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002d8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000002e0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000002e8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000002f0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000002f8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000300] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000330] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000338] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000340] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000348] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x00000350] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000358] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000360] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
-/* [0x00000368] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000370] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
-/* [0x00000378] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000380] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
-/* [0x00000388] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000390] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
-/* [0x00000398] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000003a0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000240] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000248] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000250] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000258] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000260] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000268] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000270] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000278] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000280] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x00000288] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000290] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x00000298] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000002a0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000002a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002b0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000002b8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000002c0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000002c8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000002d0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000002d8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000002e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000002e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000002f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000002f8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000300] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000308] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000310] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000318] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000320] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000328] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000330] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000338] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000340] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000348] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000350] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+/* [0x00000358] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000360] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+/* [0x00000368] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000370] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
+/* [0x00000378] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000380] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
+/* [0x00000388] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000390] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x000003a8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000003b0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
-/* [0x000003b8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x000003c0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003c8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003d0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003d8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003e0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-/* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
-/* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000400] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000420] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000430] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000440] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000448] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000450] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000458] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000460] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000468] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000470] */ 0x00000020, 0xe0021327, // mov rb12,32
-/* [0x00000478] */ 0x00000006, 0xe0021367, // mov rb13,6
-/* [0x00000480] */ 0x00000001, 0xe00213a7, // mov rb14,1
-/* [0x00000488] */ 0x00000000, 0xe00213e7, // mov rb15,0
-/* [0x00000490] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000498] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000004a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000004a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000004b0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000004b8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000004c0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000004c8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
-/* [0x000004d0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
-/* [0x000004d8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
-/* [0x000004e0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004e8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
-/* [0x000004f0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000004f8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000500] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000508] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000510] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000518] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000520] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000528] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000530] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000538] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000540] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000398] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000003a0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+/* [0x000003a8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x000003b0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000003b8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000003c0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000003c8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000003d0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003d8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x000003e0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+/* [0x000003e8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003f0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000003f8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000400] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000408] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000410] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000418] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000420] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000428] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000430] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000438] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000440] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000448] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000450] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000458] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000460] */ 0x00000020, 0xe0021327, // mov rb12,32
+/* [0x00000468] */ 0x00000006, 0xe0021367, // mov rb13,6
+/* [0x00000470] */ 0x00000001, 0xe00213a7, // mov rb14,1
+/* [0x00000478] */ 0x00000000, 0xe00213e7, // mov rb15,0
+/* [0x00000480] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000488] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000490] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000498] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000004a0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000004a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000004b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000004b8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+/* [0x000004c0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+/* [0x000004c8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+/* [0x000004d0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x000004d8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+/* [0x000004e0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000004e8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000004f0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000004f8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000500] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000508] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000510] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000518] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000520] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000528] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000530] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x00000548] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000550] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000558] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000560] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000568] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000570] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000578] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000580] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000588] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
-/* [0x00000590] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000598] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
-/* [0x000005a0] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x000005a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000005b0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000005c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000005c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000005d0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000005d8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000005e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000005e8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000005f0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000005f8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000600] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000608] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000610] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000618] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000620] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000628] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000630] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000638] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000640] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x00000648] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000650] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000658] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000668] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000538] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000540] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000548] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000550] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000558] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000560] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000568] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000570] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000578] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x00000580] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000588] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x00000590] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x00000598] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000005a0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005a8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000005b0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000005b8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000005c0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000005c8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000005d0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000005d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000005e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000005e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000005f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005f8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000600] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000608] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000610] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000618] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000620] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000628] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000630] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000638] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000640] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000648] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000650] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000658] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000670] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000678] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
-/* [0x00000680] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x00000688] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000690] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000698] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000006a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000006a8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000006b0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-/* [0x000006b8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
-/* [0x000006c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000006c8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000006d0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000006d8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000006e0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000006e8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000006f0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000006f8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000700] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000708] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000710] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000718] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000720] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000728] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000730] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000738] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000740] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000748] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000750] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000758] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000760] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
-/* [0x00000768] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000770] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
-/* [0x00000778] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000780] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000788] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000790] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000798] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000007a0] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000660] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000668] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+/* [0x00000670] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00000678] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000680] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000688] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000690] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000698] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000006a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x000006a8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+/* [0x000006b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000006b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000006c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000006c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000006d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000006d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000006e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000006e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000006f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000006f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000700] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000708] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000710] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000718] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000720] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000728] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000730] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000738] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000740] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000748] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000750] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+/* [0x00000758] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000760] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+/* [0x00000768] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000770] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000778] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000780] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000788] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000790] */ 0x009e7000, 0x100009e7, // nop
 // ::mc_filter_uv_b
-/* [0x000007a8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000007b0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000007b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000007c0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000007c8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000007d0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000007d8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000007e0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000007e8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
-/* [0x000007f0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000007f8] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
-/* [0x00000800] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000808] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000810] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000830] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000838] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000858] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000860] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000880] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000888] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000890] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000898] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x000008a8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008b0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008b8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008c0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x000008c8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000008d0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000008d8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000008e0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000008e8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000798] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000007a0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000007a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000007b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x000007b8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x000007c0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x000007c8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x000007d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x000007d8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x000007e0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x000007e8] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x000007f0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000007f8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000800] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000808] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000810] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000818] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000820] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000828] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000830] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000838] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x00000840] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x00000848] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x00000850] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000858] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000860] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000868] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000870] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000878] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000880] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000888] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000890] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000898] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008a0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000008a8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000008b0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x000008b8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000008c0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000008c8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000008d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008d8] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x000008f0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000008f8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
-/* [0x00000900] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x00000908] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000910] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000918] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000920] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000928] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000930] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-/* [0x00000938] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
-/* [0x00000940] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000948] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000950] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000958] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000960] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000968] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000970] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000978] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000980] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000988] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000990] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000998] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000009a0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x000009a8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x000009b0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x000009b8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000009c0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000009c8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000009d0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000009d8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000009e0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000009e8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000009f0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x000009f8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x00000a00] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000a08] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000a10] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000a18] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000a20] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000a28] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a30] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000a38] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000a40] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000a48] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000a50] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000a58] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a60] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000008e0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x000008e8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+/* [0x000008f0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x000008f8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000900] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000908] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000910] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000918] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000920] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x00000928] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+/* [0x00000930] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000938] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000940] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000948] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000950] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000958] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000960] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000968] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000970] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000978] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000980] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000988] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000990] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000998] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x000009a0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000009a8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000009b0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000009b8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000009c0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000009c8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000009d0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000009d8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000009e0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x000009e8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x000009f0] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000009f8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00000a00] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000a08] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000a10] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00000a18] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a20] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000a28] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x00000a30] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x00000a38] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000a40] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x00000a48] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00000a50] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000a68] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a70] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a58] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a60] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a68] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a70] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a98] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000aa0] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000aa8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a88] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000a90] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a98] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000ab0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000aa0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000aa8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ab0] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000ac8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000ad0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b10] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000b18] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000b20] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000b00] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000b08] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000b10] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_setup
-/* [0x00000b28] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000b30] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000b38] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000b40] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000b48] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00000b50] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000b58] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x00000b60] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00000b68] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
-/* [0x00000b70] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x00000b78] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000b80] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
-/* [0x00000b88] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
-/* [0x00000b90] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000b98] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000ba0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00000ba8] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
-/* [0x00000bb0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
-/* [0x00000bb8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00000bc0] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
-/* [0x00000bc8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x00000bd0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000bd8] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
-/* [0x00000be0] */ 0x8c9e7452, 0x10025e19, // add t0s, r2, r1 ; mov ra_frame_base2, r2
-/* [0x00000be8] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
-/* [0x00000bf0] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
-/* [0x00000bf8] */ 0x15827d80, 0x10021427, // mov rb16, unif
-/* [0x00000c00] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000c08] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
-/* [0x00000c10] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
-/* [0x00000c18] */ 0x00000001, 0xe0020527, // mov ra20, 1
-/* [0x00000c20] */ 0x00000100, 0xe00205a7, // mov ra22, 256
-/* [0x00000c28] */ 0x00000040, 0xe00207a7, // mov ra30, 64
-/* [0x00000c30] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
-/* [0x00000c38] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
-/* [0x00000c40] */ 0x00000018, 0xe00215e7, // mov rb23, 24
-/* [0x00000c48] */ 0x00000000, 0xe0020227, // mov ra8, 0
-/* [0x00000c50] */ 0x00000000, 0xe0020267, // mov ra9, 0
-/* [0x00000c58] */ 0x00000000, 0xe00202a7, // mov ra10, 0
-/* [0x00000c60] */ 0x00000000, 0xe00202e7, // mov ra11, 0
-/* [0x00000c68] */ 0x00000000, 0xe0020327, // mov ra12, 0
-/* [0x00000c70] */ 0x00000000, 0xe0020367, // mov ra13, 0
-/* [0x00000c78] */ 0x00000000, 0xe00203a7, // mov ra14, 0
-/* [0x00000c80] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x00000c88] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000c90] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000c98] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000ca0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000ca8] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000cb0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000cb8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000cc0] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
-/* [0x00000cc8] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
-/* [0x00000cd0] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00000cd8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000ce0] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000ce8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000cf0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000cf8] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000d00] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000d08] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000d10] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x00000d18] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x00000d20] */ 0x15827d80, 0x10021327, // mov rb12,unif
-/* [0x00000d28] */ 0x15827d80, 0x10021367, // mov rb13,unif
-/* [0x00000d30] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000d38] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000d40] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000d48] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000d50] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000d58] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
-/* [0x00000d60] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
-/* [0x00000d68] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000d70] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000d78] */ 0x0c541dc0, 0xd0020567, // add ra_y2, ra_y2, 1
-/* [0x00000d80] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000d88] */ 0x0c667380, 0x10020e27, // add t0s, r1, ra_frame_base2
+/* [0x00000b18] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000b20] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000b28] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000b30] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000b38] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000b40] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000b48] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x00000b50] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000b58] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+/* [0x00000b60] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000b68] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000b70] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+/* [0x00000b78] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
+/* [0x00000b80] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000b88] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000b90] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000b98] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+/* [0x00000ba0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
+/* [0x00000ba8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000bb0] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+/* [0x00000bb8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000bc0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000bc8] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+/* [0x00000bd0] */ 0x8c9e7452, 0x10025e19, // add t0s, r2, r1 ; mov ra_frame_base2, r2
+/* [0x00000bd8] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+/* [0x00000be0] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+/* [0x00000be8] */ 0x15827d80, 0x10021427, // mov rb16, unif
+/* [0x00000bf0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000bf8] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+/* [0x00000c00] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+/* [0x00000c08] */ 0x00000001, 0xe0020527, // mov ra20, 1
+/* [0x00000c10] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+/* [0x00000c18] */ 0x00000040, 0xe00207a7, // mov ra30, 64
+/* [0x00000c20] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x00000c28] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x00000c30] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x00000c38] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x00000c40] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x00000c48] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x00000c50] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x00000c58] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x00000c60] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x00000c68] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x00000c70] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x00000c78] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000c80] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000c88] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000c90] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000c98] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000ca0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000ca8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000cb0] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00000cb8] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00000cc0] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00000cc8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000cd0] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000cd8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000ce0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000ce8] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000cf0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000cf8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000d00] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000d08] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000d10] */ 0x15827d80, 0x10021327, // mov rb12,unif
+/* [0x00000d18] */ 0x15827d80, 0x10021367, // mov rb13,unif
+/* [0x00000d20] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000d28] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000d30] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000d38] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000d40] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000d48] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+/* [0x00000d50] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
+/* [0x00000d58] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000d60] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000d68] */ 0x0c541dc0, 0xd0020567, // add ra_y2, ra_y2, 1
+/* [0x00000d70] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000d78] */ 0x0c667380, 0x10020e27, // add t0s, r1, ra_frame_base2
 // ::mc_filter
-/* [0x00000d90] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000d98] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000da0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000da8] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
-/* [0x00000db0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000db8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000dc0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00000dc8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000dd0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000dd8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00000de0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
-/* [0x00000de8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000df0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
-/* [0x00000df8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00000e00] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
-/* [0x00000e08] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
-/* [0x00000e10] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00000e18] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
-/* [0x00000e20] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000e28] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000e30] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000e38] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000e40] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000e48] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000e50] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000e58] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000e60] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000e68] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000e70] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000e78] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000e80] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000e88] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000e90] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000e98] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ea0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ea8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000eb0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000eb8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ec0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ec8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ed0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000ed8] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000ee0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000ee8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000ef0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ef8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000f00] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000f08] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f10] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f18] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f20] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
-/* [0x00000f28] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000f30] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000f38] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
-/* [0x00000f40] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000f48] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
-/* [0x00000f50] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000d80] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000d88] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000d90] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000d98] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
+/* [0x00000da0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000da8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000db0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000db8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000dc0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000dc8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000dd0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
+/* [0x00000dd8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000de0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
+/* [0x00000de8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000df0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+/* [0x00000df8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
+/* [0x00000e00] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000e08] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+/* [0x00000e10] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000e18] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000e20] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000e28] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000e30] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000e38] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000e40] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000e48] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000e50] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000e58] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000e60] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000e68] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000e70] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000e78] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000e80] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000e88] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000e90] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000e98] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000ea0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000ea8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000eb0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000eb8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ec0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x00000ec8] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000ed0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000ed8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000ee0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ee8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x00000ef0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000ef8] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f00] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f08] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000f10] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
+/* [0x00000f18] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000f20] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+/* [0x00000f28] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+/* [0x00000f30] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000f38] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+/* [0x00000f40] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :yloop
-/* [0x00000f58] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
-/* [0x00000f60] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
-/* [0x00000f68] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x00000f70] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000f78] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
-/* [0x00000f80] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
-/* [0x00000f88] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000f90] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000f98] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
-/* [0x00000fa0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
-/* [0x00000fa8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
-/* [0x00000fb0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000fb8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
-/* [0x00000fc0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
-/* [0x00000fc8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000fd0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000fd8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000fe0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000fe8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000ff0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000ff8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00001000] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00001008] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00001010] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00001018] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00001020] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00001028] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00001030] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00001038] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00001040] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00001048] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00001050] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00001058] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
-/* [0x00001060] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00001068] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00001070] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00001078] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00001080] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
-/* [0x00001088] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00001090] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00001098] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x000010a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000010a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000010b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000010b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000010c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
-/* [0x000010c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
-/* [0x000010d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
-/* [0x000010d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
-/* [0x000010e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000010e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000010f0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000010f8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
-/* [0x00001100] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
-/* [0x00001108] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
-/* [0x00001110] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
-/* [0x00001118] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
-/* [0x00001120] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00001128] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00001130] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001138] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00001140] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00001148] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000f48] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+/* [0x00000f50] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+/* [0x00000f58] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00000f60] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000f68] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+/* [0x00000f70] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+/* [0x00000f78] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000f80] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000f88] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+/* [0x00000f90] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+/* [0x00000f98] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+/* [0x00000fa0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000fa8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+/* [0x00000fb0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+/* [0x00000fb8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000fc0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000fc8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000fd0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000fd8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000fe0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000fe8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000ff0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000ff8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00001000] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00001008] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00001010] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00001018] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00001020] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00001028] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00001030] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00001038] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00001040] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00001048] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
+/* [0x00001050] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00001058] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00001060] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00001068] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00001070] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
+/* [0x00001078] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00001080] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00001088] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00001090] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00001098] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000010a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000010a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000010b0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+/* [0x000010b8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+/* [0x000010c0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+/* [0x000010c8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+/* [0x000010d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000010d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000010e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000010e8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+/* [0x000010f0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+/* [0x000010f8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+/* [0x00001100] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
+/* [0x00001108] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+/* [0x00001110] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00001118] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00001120] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001128] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00001130] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001138] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_b
-/* [0x00001150] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00001158] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00001160] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00001168] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
-/* [0x00001170] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00001178] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00001180] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00001188] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00001190] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00001198] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000011a0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
-/* [0x000011a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000011b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
-/* [0x000011b8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x000011c0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
-/* [0x000011c8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
-/* [0x000011d0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000011d8] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
-/* [0x000011e0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000011e8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000011f0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000011f8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00001200] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00001208] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00001210] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00001218] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00001220] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00001228] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00001230] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00001238] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00001240] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001248] */ 0x00000001, 0xe0020867, // mov r1, 1
-/* [0x00001250] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x00001258] */ 0x409f3001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 13, r1 << 13
-/* [0x00001260] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001268] */ 0x409f2001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 14, r1 << 14
-/* [0x00001270] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001278] */ 0x409f1001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 15, r1 << 15
-/* [0x00001280] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001288] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00001290] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x00001298] */ 0x409f7001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 9, r1 << 9
-/* [0x000012a0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000012a8] */ 0x409f6001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 10, r1 << 10
-/* [0x000012b0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000012b8] */ 0x409f5001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 11, r1 << 11
-/* [0x000012c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000012c8] */ 0x409f4001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 12, r1 << 12
-/* [0x000012d0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000012d8] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x000012e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000012e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000012f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000012f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00001300] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x00001308] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001310] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001318] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001320] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
-/* [0x00001328] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001330] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x00001338] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
-/* [0x00001340] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00001348] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
-/* [0x00001350] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00001140] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00001148] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00001150] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00001158] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
+/* [0x00001160] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00001168] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00001170] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00001178] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00001180] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00001188] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00001190] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
+/* [0x00001198] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000011a0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
+/* [0x000011a8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x000011b0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+/* [0x000011b8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
+/* [0x000011c0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x000011c8] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+/* [0x000011d0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000011d8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000011e0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000011e8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000011f0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000011f8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00001200] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00001208] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00001210] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00001218] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00001220] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00001228] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00001230] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001238] */ 0x00000001, 0xe0020867, // mov r1, 1
+/* [0x00001240] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x00001248] */ 0x409f3001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 13, r1 << 13
+/* [0x00001250] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001258] */ 0x409f2001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 14, r1 << 14
+/* [0x00001260] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001268] */ 0x409f1001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 15, r1 << 15
+/* [0x00001270] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001278] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00001280] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x00001288] */ 0x409f7001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 9, r1 << 9
+/* [0x00001290] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001298] */ 0x409f6001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 10, r1 << 10
+/* [0x000012a0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000012a8] */ 0x409f5001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 11, r1 << 11
+/* [0x000012b0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000012b8] */ 0x409f4001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 12, r1 << 12
+/* [0x000012c0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+/* [0x000012c8] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x000012d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000012d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000012e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000012e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+/* [0x000012f0] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x000012f8] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001300] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001308] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00001310] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
+/* [0x00001318] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001320] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+/* [0x00001328] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+/* [0x00001330] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00001338] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+/* [0x00001340] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :yloopb
-/* [0x00001358] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
-/* [0x00001360] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
-/* [0x00001368] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x00001370] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00001378] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
-/* [0x00001380] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
-/* [0x00001388] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00001390] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00001398] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
-/* [0x000013a0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
-/* [0x000013a8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
-/* [0x000013b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000013b8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
-/* [0x000013c0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
-/* [0x000013c8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000013d0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000013d8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000013e0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000013e8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000013f0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000013f8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00001400] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00001408] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00001410] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00001418] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00001420] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00001428] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00001430] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00001438] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00001440] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00001448] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00001450] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00001458] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
-/* [0x00001460] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00001468] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00001470] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00001478] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00001480] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
-/* [0x00001488] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00001490] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00001498] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x000014a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000014a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000014b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000014b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000014c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
-/* [0x000014c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
-/* [0x000014d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
-/* [0x000014d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
-/* [0x000014e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000014e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000014f0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000014f8] */ 0x4053800e, 0xd00049e1, // nop                     ; mul24 r1, r1 << 8, ra20 << 8
-/* [0x00001500] */ 0x4c78e38f, 0x10024860, // add r1, r1, ra30        ; mul24 r0, r1, rb14
-/* [0x00001508] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x00001510] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloopb
-/* [0x00001518] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00001520] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00001528] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00001530] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001538] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00001540] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00001548] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00001348] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+/* [0x00001350] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+/* [0x00001358] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00001360] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00001368] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+/* [0x00001370] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+/* [0x00001378] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00001380] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00001388] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+/* [0x00001390] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+/* [0x00001398] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+/* [0x000013a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000013a8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+/* [0x000013b0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+/* [0x000013b8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000013c0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000013c8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000013d0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000013d8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000013e0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000013e8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000013f0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000013f8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00001400] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00001408] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00001410] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00001418] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00001420] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00001428] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00001430] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00001438] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00001440] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00001448] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
+/* [0x00001450] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00001458] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00001460] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00001468] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00001470] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
+/* [0x00001478] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00001480] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00001488] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00001490] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00001498] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000014a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000014a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000014b0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+/* [0x000014b8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+/* [0x000014c0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+/* [0x000014c8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+/* [0x000014d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000014d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000014e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x000014e8] */ 0x4053800e, 0xd00049e1, // nop                     ; mul24 r1, r1 << 8, ra20 << 8
+/* [0x000014f0] */ 0x4c78e38f, 0x10024860, // add r1, r1, ra30        ; mul24 r0, r1, rb14
+/* [0x000014f8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x00001500] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloopb
+/* [0x00001508] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x00001510] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00001518] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00001520] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001528] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00001530] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001538] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_interrupt_exit12
-/* [0x00001550] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00001540] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00001548] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001550] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00001558] */ 0x009e7000, 0xa00009e7, // ldtmu0
 /* [0x00001560] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001568] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001570] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001568] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001570] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001578] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001580] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x00001588] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
@@ -732,11 +732,9 @@ unsigned int rpi_shader[] = {
 /* [0x000015a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x000015b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
 /* [0x000015b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000015c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000015c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000015d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000015d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x000015e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x000015c0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000015c8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000015d0] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 3fa8531..6e552d9 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -4,15 +4,15 @@
 extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
-#define mc_filter_uv (rpi_shader + 148)
-#define mc_filter_uv_b0 (rpi_shader + 338)
-#define mc_filter_uv_b (rpi_shader + 490)
-#define mc_exit (rpi_shader + 666)
-#define mc_interrupt_exit8 (rpi_shader + 684)
-#define mc_setup (rpi_shader + 714)
-#define mc_filter (rpi_shader + 868)
-#define mc_filter_b (rpi_shader + 1108)
-#define mc_interrupt_exit12 (rpi_shader + 1364)
-#define mc_end (rpi_shader + 1402)
+#define mc_filter_uv (rpi_shader + 144)
+#define mc_filter_uv_b0 (rpi_shader + 334)
+#define mc_filter_uv_b (rpi_shader + 486)
+#define mc_exit (rpi_shader + 662)
+#define mc_interrupt_exit8 (rpi_shader + 680)
+#define mc_setup (rpi_shader + 710)
+#define mc_filter (rpi_shader + 864)
+#define mc_filter_b (rpi_shader + 1104)
+#define mc_interrupt_exit12 (rpi_shader + 1360)
+#define mc_end (rpi_shader + 1398)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index a0348a0..38abba2 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -133,8 +133,8 @@ mov ra14, 0
 mov ra15, 0
 
 # Compute part of VPM to use for DMA output
-mov r2, qpu_num
-shl r2, r2, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
+mov r3, unif
+shl r2, r3, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
 and r2, r2, 15
 mov r1, r2
 asr r1, r1, 2
@@ -147,8 +147,7 @@ shl r0, r0, 5
 add rb27, r0, r1
 
 # Compute part of VPM to save data into
-mov r2, qpu_num   # qpu_num = abcd
-shl r2, r2, 1     
+shl r2, r3, 1
 and r2, r2, 15    # r2 = bcd0
 mov r1, r2        # r1 = bcd0
 asr r1, r1, 2     # r1 = bc
@@ -181,9 +180,6 @@ add t0s, r2, r1
 mov rb12,unif # offset before shift
 mov rb13,unif # offset after shift 
 
-# Dump padding words
-mov r0, unif
-
 # submit texture requests for second line
 max r1, ra_y, 0
 min r1, r1, rb_frame_height_minus_1
-- 
1.9.1


From a4b5097b7133f5a3b6e78e69d62b1ec55d024da6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 23 May 2015 13:20:21 +0100
Subject: [PATCH 55/77] Add new cache flushing routine

---
 libavcodec/hevc.c          |  8 +++--
 libavcodec/hevc_filter.c   | 41 +++++++++++-----------
 libavcodec/rpi_qpu.c       | 17 +++++++--
 libavcodec/rpi_qpu.h       |  2 ++
 libavcodec/rpi_user_vcsm.h | 86 ++++++++++++++++++++++++++--------------------
 5 files changed, 92 insertions(+), 62 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index dac9860..1792150 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -3691,9 +3691,13 @@ static int decode_nal_units(HEVCContext *s, const uint8_t *buf, int length)
     }
 
 fail:
-    if (s->ref && s->threads_type == FF_THREAD_FRAME)
+    if (s->ref && s->threads_type == FF_THREAD_FRAME) {
+#ifdef RPI_INTER_QPU
+        void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n);
+        ff_hevc_flush_chroma(s, &s->ref->tf, s->sps->height);
+#endif
         ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);
-
+    }
     return ret;
 }
 
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 66476b6..0c59f5c 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -882,36 +882,35 @@ static int ff_hevc_buf_base(AVBufferRef *bref) {
   return p->vc & 0x3fffffff;
 }
 
-static void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
+void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n);
+void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
 {
     if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
             s->nal_unit_type == NAL_TSA_N   ||
             s->nal_unit_type == NAL_STSA_N  ||
             s->nal_unit_type == NAL_RADL_N  ||
             s->nal_unit_type == NAL_RASL_N )) {  
-#define RPI_FAST_CACHEFLUSH            
 #ifdef RPI_FAST_CACHEFLUSH
-        struct vcsm_user_clean_invalid_s iocache = {}; 
-        int curr_y = f->progress->data[0];
+        struct vcsm_user_clean_invalid_s iocache = {};
+        int curr_y = ((int *)f->progress->data)[0];
+        int curr_uv = curr_y >> s->sps->vshift[1];
+        int n_uv = n >> s->sps->vshift[1];
         int sz,base;
-        if (curr_y < 0) curr_y = 0;
-        if (n<=curr_y) return; // Should not happen
-        sz = s->frame->linesize[1] * (n-curr_y);
-        base = s->frame->linesize[1] * curr_y;
-        iocache.s[0].cmd = 3; // Flush L1 cache
-        iocache.s[0].addr = 0; 
-        iocache.s[0].size  = 0;
-
-        iocache.s[1].cmd = 2;
-        iocache.s[1].addr = ff_hevc_buf_base(s->frame->buf[1]) + base;
+        if (curr_uv < 0) curr_uv = 0;
+        if (n_uv<=curr_uv) { assert(0); return; } // Should not happen
+        sz = s->frame->linesize[1] * (n_uv-curr_uv);
+        base = s->frame->linesize[1] * curr_uv;
+        GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[1]);
+        iocache.s[0].handle = p->vcsm_handle;
+        iocache.s[0].cmd = 3; // clean+invalidate
+        iocache.s[0].addr = p->arm + base;
+        iocache.s[0].size  = sz;
+        p = av_buffer_pool_opaque(s->frame->buf[2]);
+        iocache.s[1].handle = p->vcsm_handle;
+        iocache.s[1].cmd = 3; // clean+invalidate
+        iocache.s[1].addr = p->arm + base;
         iocache.s[1].size  = sz;
-        
-        iocache.s[2].cmd = 2;
-        iocache.s[2].addr = ff_hevc_buf_base(s->frame->buf[2]) + base;
-        iocache.s[2].size  = sz;
-
-        vcsm_clean_invalid( gpu_get_mailbox(), &iocache );
-
+        vcsm_clean_invalid( &iocache );
 #else            
         flush_buffer(s->frame->buf[1]);
         flush_buffer(s->frame->buf[2]);
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index d56fd01..1e3a2d6 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -208,6 +208,7 @@ static void gpu_unlock(void) {
 }
 
 static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb) {
+  p->numbytes = numbytes;
   p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
   assert(p->vcsm_handle);
   p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
@@ -240,13 +241,25 @@ int gpu_get_mailbox(void)
   return gpu->mb;
 }
 
+// Call this to clean and invalidate a region of memory
 void gpu_cache_flush(GPU_MEM_PTR_T *p)
 {
-  void *tmp = vcsm_lock(p->vcsm_handle); 
-  vcsm_unlock_ptr(tmp);
+#define RPI_FAST_CACHEFLUSH
+#ifdef RPI_FAST_CACHEFLUSH
+    struct vcsm_user_clean_invalid_s iocache = {};
+    iocache.s[0].handle = p->vcsm_handle;
+    iocache.s[0].cmd = 3; // clean+invalidate
+    iocache.s[0].addr = p->arm;
+    iocache.s[0].size  = p->numbytes;
+    vcsm_clean_invalid( &iocache );
+#else
+    void *tmp = vcsm_lock(p->vcsm_handle);
+    vcsm_unlock_ptr(tmp);
+#endif
 }
 
 static int gpu_malloc_cached_internal(int numbytes, GPU_MEM_PTR_T *p) {
+  p->numbytes = numbytes;
   p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" );
   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" ); 
   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index 9e5ebe7..fafe780 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -1,6 +1,8 @@
 #ifndef RPI_QPU_H
 #define RPI_QPU_H
 
+#define RPI_FAST_CACHEFLUSH
+
 typedef struct gpu_mem_ptr_s {
   unsigned char *arm; // Pointer to memory mapped on ARM side
   int vc_handle;   // Videocore handle of relocatable memory
diff --git a/libavcodec/rpi_user_vcsm.h b/libavcodec/rpi_user_vcsm.h
index 95b3125..94e6e79 100644
--- a/libavcodec/rpi_user_vcsm.h
+++ b/libavcodec/rpi_user_vcsm.h
@@ -1,29 +1,41 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+/*****************************************************************************
+* Copyright 2001 - 2011 Broadcom Corporation.  All rights reserved.
+*
+* This program is the proprietary software of Broadcom Corporation and/or
+* its licensors, and may only be used, duplicated, modified or distributed
+* pursuant to the terms and conditions of a separate, written license
+* agreement executed between you and Broadcom (an "Authorized License").
+* Except as set forth in an Authorized License, Broadcom grants no license
+* (express or implied), right to use, or waiver of any kind with respect to
+* the Software, and Broadcom expressly reserves all rights in and to the
+* Software and all intellectual property rights therein.  IF YOU HAVE NO
+* AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY
+* WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF
+* THE SOFTWARE.
+*
+* Except as expressly set forth in the Authorized License,
+* 1. This program, including its structure, sequence and organization,
+*    constitutes the valuable trade secrets of Broadcom, and you shall use
+*    all reasonable efforts to protect the confidentiality thereof, and to
+*    use this information only in connection with your use of Broadcom
+*    integrated circuit products.
+* 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+*    AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
+*    WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
+*    RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL
+*    IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS
+*    FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS,
+*    QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU
+*    ASSUME THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+* 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
+*    LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
+*    OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+*    YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN
+*    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS
+*    OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER
+*    IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+*    ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+*****************************************************************************/
 
 #ifndef __USER_VCSM__H__INCLUDED__
 #define __USER_VCSM__H__INCLUDED__
@@ -424,21 +436,21 @@ int vcsm_unlock_hdl_sp( unsigned int handle, int cache_no_flush );
 **
 ** structure contains a list of flush/invalidate commands. Commands are:
 ** 0: nop
-** 1: invalidate given physical range in L2
-** 2: clean      given physical range in L2
-** 3: clean+invalidate all of L1
-** 4: flush      all of L2 and all of L1
+** 1: invalidate       given virtual range in L1/L2
+** 2: clean            given virtual range in L1/L2
+** 3: clean+invalidate given virtual range in L1/L2
+** 4: flush all L1/L2
 */
 struct vcsm_user_clean_invalid_s {
-    struct {
-       unsigned int cmd;
-       unsigned int addr;
-       unsigned int size;
-    } s[8];
+   struct {
+      unsigned int cmd;
+      unsigned int handle;
+      unsigned int addr;
+      unsigned int size;
+   } s[8];
 };
 
-int vcsm_clean_invalid( unsigned int handle, struct vcsm_user_clean_invalid_s *s );
-
+int vcsm_clean_invalid( struct vcsm_user_clean_invalid_s *s );
 
 #ifdef __cplusplus
 }
-- 
1.9.1


From 0c4c2a62cda51d2ea4e48ce38b4508adf69d8891 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 23 May 2015 21:10:10 +0100
Subject: [PATCH 56/77] Fix multi mailbox extra transform call

---
 libavcodec/hevc.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 1792150..b504e01 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -2986,7 +2986,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 #ifdef RPI_INTER_QPU
         rpi_execute_inter_qpu(s);
 #endif
+#ifndef RPI_MULTI_MAILBOX
         rpi_execute_transform(s);
+#endif
         rpi_execute_inter_cmds(s);
         vpu_wait(s->vpu_id);
         rpi_execute_pred_cmds(s);
-- 
1.9.1


From 61a9545c818f756131b7308902ac429983a64426 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 27 May 2015 16:44:29 +0100
Subject: [PATCH 57/77] Added support for running luma prediction on QPUs

---
 libavcodec/hevc.c          |  249 ++++++++-
 libavcodec/hevc.h          |   28 +-
 libavcodec/hevc_filter.c   |   23 +-
 libavcodec/rpi_qpu.c       |  158 ++++--
 libavcodec/rpi_qpu.h       |    8 +-
 libavcodec/rpi_shader.c    | 1313 ++++++++++++++++++++++----------------------
 libavcodec/rpi_shader.h    |   21 +-
 libavcodec/rpi_shader.qasm |  901 +++++++++++++++---------------
 8 files changed, 1481 insertions(+), 1220 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index b504e01..c3feb6a 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -50,6 +50,11 @@
     // Define RPI_MULTI_MAILBOX to use the updated mailbox that can launch both QPU and VPU
     #define RPI_MULTI_MAILBOX
   #endif
+  
+  // Define RPI_CACHE_UNIF_MVS to write motion vector uniform stream to cached memory
+  // RPI_CACHE_UNIF_MVS doesn't seem to make much difference, so left undefined.
+  
+  
 #endif
 
 // #define DISABLE_MC
@@ -72,6 +77,13 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 // The QPU code for UV blocks only works up to a block width of 8
 #define RPI_CHROMA_BLOCK_WIDTH 8
 
+// Split image of 2048 into parts 64 wide
+// So some QPUs will have 3 blocks of 64 to do, and others 2 blocks for an image 2048 wide with 32 blocks across
+// Each block of 64*64
+// Smallest CTU size is 16x16, so smallest block is 8x8
+// Corresponds to a total of 83kbytes over all 12 QPUs
+#define RPI_LUMA_COMMAND_WORDS 9
+#define Y_COMMANDS_PER_QPU ((1+3*(64*64)/(8*8)) * RPI_LUMA_COMMAND_WORDS)
 
 #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
 
@@ -1978,12 +1990,48 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int y0_c = y0 >> s->sps->vshift[1];
         int nPbW_c = nPbW >> s->sps->hshift[1];
         int nPbH_c = nPbH >> s->sps->vshift[1];
-
-        RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref0->frame,
+        
+#ifdef RPI_LUMA_QPU
+        if (s->enable_rpi) {
+            int reflist = 0;
+            const Mv *mv         = &current_mv.mv[reflist];
+            int mx          = mv->x & 3;
+            int my          = mv->y & 3;
+            int my_mx = (my<<8) + mx;
+            int my2_mx2_my_mx = (my_mx << 16) + my_mx;
+            int x1 = x0 + (mv->x >> 2);
+            int y1 = y0 + (mv->y >> 2);
+            int chan = x0>>6; // 64 wide blocks per QPU
+            int weight_flag = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
+                              (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);    
+            uint32_t *y = s->y_mvs[chan % 12];      
+            for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+              for(int start_x=0;start_x < nPbW;start_x+=16) {
+                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
+                  *y++ = ( (nPbW<16 ? nPbW : 16) << 16 ) + (nPbH<16 ? nPbH : 16);
+                  *y++ = my2_mx2_my_mx;
+                  if (weight_flag) {
+                      *y++ = (s->sh.luma_offset_l0[current_mv.ref_idx[reflist]] << 16) + (s->sh.luma_weight_l0[current_mv.ref_idx[reflist]] & 0xffff);
+                  } else {
+                      *y++ = 1; // Weight of 1 and offset of 0
+                  }
+                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
+                }
+            }
+            s->y_mvs[chan % 12] = y;
+        } else 
+#endif
+        {
+            RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref0->frame,
                     &current_mv.mv[0], x0, y0, nPbW, nPbH,
                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],
                     s->sh.luma_offset_l0[current_mv.ref_idx[0]]);
-
+        }
+        
         if (s->sps->chroma_format_idc) {
 #ifdef RPI_INTER_QPU
             if (s->enable_rpi) {
@@ -2041,12 +2089,49 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int y0_c = y0 >> s->sps->vshift[1];
         int nPbW_c = nPbW >> s->sps->hshift[1];
         int nPbH_c = nPbH >> s->sps->vshift[1];
+        
+#ifdef RPI_LUMA_QPU
+        if (s->enable_rpi) {
+            int reflist = 1;
+            const Mv *mv    = &current_mv.mv[reflist];
+            int mx          = mv->x & 3;
+            int my          = mv->y & 3;
+            int my_mx = (my<<8) + mx;
+            int my2_mx2_my_mx = (my_mx << 16) + my_mx;
+            int x1 = x0 + (mv->x >> 2);
+            int y1 = y0 + (mv->y >> 2);
+            int chan = x0>>6; // 64 wide blocks per QPU
+            int weight_flag = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
+                              (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);    
+            uint32_t *y = s->y_mvs[chan % 12];      
+            for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+              for(int start_x=0;start_x < nPbW;start_x+=16) {
+                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
+                  *y++ = ( (nPbW<16 ? nPbW : 16) << 16 ) + (nPbH<16 ? nPbH : 16);
+                  *y++ = my2_mx2_my_mx;
+                  if (weight_flag) {
+                      *y++ = (s->sh.luma_offset_l0[current_mv.ref_idx[reflist]] << 16) + (s->sh.luma_weight_l0[current_mv.ref_idx[reflist]] & 0xffff);
+                  } else {
+                      *y++ = 1; // Weight of 1 and offset of 0
+                  }
+                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
+                }
+            }
+            s->y_mvs[chan % 12] = y;
+        } else 
+#endif
 
-        RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref1->frame,
+        {
+            RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref1->frame,
                     &current_mv.mv[1], x0, y0, nPbW, nPbH,
                     s->sh.luma_weight_l1[current_mv.ref_idx[1]],
                     s->sh.luma_offset_l1[current_mv.ref_idx[1]]);
-
+        }
+        
         if (s->sps->chroma_format_idc) {
 #ifdef RPI_INTER_QPU
             if (s->enable_rpi) {
@@ -2079,8 +2164,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = rpi_filter_coefs[_mx][0];
                       *u++ = rpi_filter_coefs[_my][0];
                       if (weight_flag) {
-                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[1]][0] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[1]][0] & 0xffff);
-                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[1]][1] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[1]][1] & 0xffff);
+                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[reflist]][0] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[reflist]][0] & 0xffff);
+                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[reflist]][1] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[reflist]][1] & 0xffff);
                       } else {
                           *u++ = 1; // Weight of 1 and offset of 0
                           *u++ = 1;
@@ -2106,11 +2191,46 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int y0_c = y0 >> s->sps->vshift[1];
         int nPbW_c = nPbW >> s->sps->hshift[1];
         int nPbH_c = nPbH >> s->sps->vshift[1];
-
-        RPI_REDIRECT(luma_mc_bi)(s, dst0, s->frame->linesize[0], ref0->frame,
+        
+#ifdef RPI_LUMA_QPU
+        if (s->enable_rpi) {
+            const Mv *mv    = &current_mv.mv[0];
+            int mx          = mv->x & 3;
+            int my          = mv->y & 3;
+            int my_mx = (my<<8) + mx;
+            const Mv *mv2    = &current_mv.mv[1];
+            int mx2          = mv2->x & 3;
+            int my2          = mv2->y & 3;
+            int my2_mx2 = (my2<<8) + mx2;
+            int my2_mx2_my_mx = (my2_mx2 << 16) + my_mx;
+            int x1 = x0 + (mv->x >> 2);
+            int y1 = y0 + (mv->y >> 2);
+            int x2 = x0 + (mv2->x >> 2);
+            int y2 = y0 + (mv2->y >> 2);
+            int chan = x0>>6; // 64 wide blocks per QPU
+            uint32_t *y = s->y_mvs[chan % 12];      
+            for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+              for(int start_x=0;start_x < nPbW;start_x+=8) { // B blocks work 8 at a time
+                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y2 - 3 + start_y) << 16) + ( (x2 - 3 + start_x) & 0xffff); // Second fetch is for ref1
+                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
+                  *y++ = ( (nPbW<8 ? nPbW : 8) << 16 ) + (nPbH<16 ? nPbH : 16);
+                  *y++ = my2_mx2_my_mx;
+                  *y++ = 1; // B frame weighted prediction not supported
+                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
+                  y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter_b;
+                }
+            }
+            s->y_mvs[chan % 12] = y;
+        } else 
+#endif
+        {
+            RPI_REDIRECT(luma_mc_bi)(s, dst0, s->frame->linesize[0], ref0->frame,
                    &current_mv.mv[0], x0, y0, nPbW, nPbH,
                    ref1->frame, &current_mv.mv[1], &current_mv);
-
+        }
+        
         if (s->sps->chroma_format_idc) {
 #ifdef RPI_INTER_QPU
             if (s->enable_rpi) {
@@ -2798,7 +2918,6 @@ static void rpi_inter_clear(HEVCContext *s)
         *s->u_mvs[i]++ = pic_height;
         *s->u_mvs[i]++ = s->frame->linesize[1];
         *s->u_mvs[i]++ = s->frame->linesize[2];
-        *s->u_mvs[i]++ = i;
         if (weight_flag) {
             *s->u_mvs[i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
             *s->u_mvs[i]++ = s->sh.chroma_log2_weight_denom + 6;
@@ -2806,14 +2925,41 @@ static void rpi_inter_clear(HEVCContext *s)
             *s->u_mvs[i]++ = 1 << 5;
             *s->u_mvs[i]++ = 6;
         }
+        *s->u_mvs[i]++ = i;  // Select section of VPM (avoid collisions with 3d unit)
     }
+    
+#ifdef RPI_LUMA_QPU
+    for(i=0;i<12;i++) {
+        s->y_mvs[i] = s->y_mvs_base[i];
+        *s->y_mvs[i]++ = 0; // y_x
+        *s->y_mvs[i]++ = 0; // ref_y_base
+        *s->y_mvs[i]++ = 0; // y2_x2
+        *s->y_mvs[i]++ = 0; // ref_y2_base
+        *s->y_mvs[i]++ = (s->sps->width << 16) + s->sps->height;
+        *s->y_mvs[i]++ = s->frame->linesize[0]; // pitch
+        *s->y_mvs[i]++ = s->frame->linesize[0]; // dst_pitch
+        if (weight_flag) {
+            int offset = 1 << (s->sh.luma_log2_weight_denom + 6 - 1);
+            int shift = s->sh.luma_log2_weight_denom + 6;
+            *s->y_mvs[i]++ = (offset << 16) + shift;
+        } else {
+            int offset = 1 << 5;
+            int shift = 6;
+            *s->y_mvs[i]++ = (offset << 16) + shift;
+        }
+        *s->y_mvs[i]++ = 0; // Next kernel
+    }
+#endif
 }
 
 static void rpi_execute_inter_qpu(HEVCContext *s)
 {
     int k;
     int i;
-    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;
+    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;  
+#ifdef RPI_LUMA_QPU
+    uint32_t *y_unif_vc = (uint32_t *)s->y_unif_mvs_ptr.vc;
+#endif
     if (s->sh.slice_type == I_SLICE) {
 #ifdef RPI_MULTI_MAILBOX
       rpi_execute_transform(s);
@@ -2829,8 +2975,23 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
              
     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
 
+#ifdef RPI_LUMA_QPU
+    for(k=0;k<12;k++) {
+        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+1] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
+        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for second request        
+        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+        assert(s->y_mvs[k] - s->y_mvs_base[k] < Y_COMMANDS_PER_QPU);
+    }
+    s->y_mvs[12-1][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT12); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+#endif
+
+
 #ifdef RPI_MULTI_MAILBOX
+#ifdef RPI_CACHE_UNIF_MVS
+    gpu_cache_flush3(&s->coeffs_buf_accelerated,&s->y_unif_mvs_ptr, &s->unif_mvs_ptr);
+#else
     gpu_cache_flush(&s->coeffs_buf_accelerated);
+#endif
     s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0,
                                    qpu_get_fn(QPU_MC_SETUP_UV),
                                    (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
@@ -2840,7 +3001,27 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
                                    (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
                                    (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
                                    (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-                                   (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
+                                   (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+#ifdef RPI_LUMA_QPU                                  
+                                   qpu_get_fn(QPU_MC_SETUP),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[0 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[1 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[2 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[3 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[4 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[5 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[6 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[7 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[8 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[9 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[10 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[11 ] - (uint32_t*)s->y_unif_mvs_ptr.arm))
+#else                              
+                                   0,
+                                   0,0,0,0,
+                                   0,0,0,0,
+                                   0,0,0,0
+#endif                                   
                                  );
     for(i=0;i<4;i++)
         s->num_coeffs[i] = 0;
@@ -2856,6 +3037,8 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
       (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
       );
 #endif
+
+
 }
 #endif
 
@@ -3695,8 +3878,7 @@ static int decode_nal_units(HEVCContext *s, const uint8_t *buf, int length)
 fail:
     if (s->ref && s->threads_type == FF_THREAD_FRAME) {
 #ifdef RPI_INTER_QPU
-        void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n);
-        ff_hevc_flush_chroma(s, &s->ref->tf, s->sps->height);
+        ff_hevc_flush_buffer(s, &s->ref->tf, s->sps->height);
 #endif
         ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);
     }
@@ -3887,7 +4069,6 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
 
 #ifdef RPI
     av_freep(&s->unif_mv_cmds);
-    av_freep(&s->unif_xfm_cmds);
     av_freep(&s->univ_pred_cmds);
     
 #ifdef RPI_INTER_QPU
@@ -3896,7 +4077,12 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
         s->unif_mvs = 0;
     }
 #endif
-    //gpu_free(&s->dummy);
+#ifdef RPI_LUMA_QPU
+    if (s->y_unif_mvs) {
+        gpu_free( &s->y_unif_mvs_ptr );
+        s->y_unif_mvs = 0;
+    }
+#endif
     
 #ifdef EARLY_MALLOC
     printf("hevc_decode_free\n");
@@ -3984,9 +4170,6 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     s->unif_mv_cmds = av_mallocz(sizeof(HEVCMvCmd)*RPI_MAX_MV_CMDS);
     if (!s->unif_mv_cmds)
         goto fail;
-    s->unif_xfm_cmds = av_mallocz(sizeof(HEVCXfmCmd)*RPI_MAX_XFM_CMDS);
-    if (!s->unif_xfm_cmds)
-        goto fail;
     s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
     if (!s->univ_pred_cmds)
         goto fail;
@@ -4000,7 +4183,11 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     {
         int uv_commands_per_qpu = UV_COMMANDS_PER_QPU;
         uint32_t *p;
+#ifdef RPI_CACHE_UNIF_MVS        
+        gpu_malloc_cached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
+#else
         gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
+#endif
         s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
     
         // Set up initial locations for uniform streams
@@ -4015,6 +4202,28 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
         
     }
 #endif
+#ifdef RPI_LUMA_QPU
+    {
+        int y_commands_per_qpu = Y_COMMANDS_PER_QPU;
+        uint32_t *p;
+#ifdef RPI_CACHE_UNIF_MVS
+        gpu_malloc_cached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr );
+#else
+        gpu_malloc_uncached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr );
+#endif
+        s->y_unif_mvs = (uint32_t *) s->y_unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
+    
+        // Set up initial locations for uniform streams
+        p = s->y_unif_mvs;
+        for(i = 0; i < 12; i++) {
+            s->y_mvs_base[i] = p;
+            p += y_commands_per_qpu;
+        }
+        s->mc_filter = qpu_get_fn(QPU_MC_FILTER);
+        s->mc_filter_b = qpu_get_fn(QPU_MC_FILTER_B);
+        
+    }
+#endif
     //gpu_malloc_uncached(2048*64,&s->dummy);
     
 #ifdef EARLY_MALLOC 
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 70303cc..e3414b7 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -42,9 +42,13 @@
 #ifdef RPI
 
   #include "rpi_qpu.h"
-  // Use QPU for inter prediction
+  // Define RPI_INTER_QPU to use QPU for chroma inter prediction
   #define RPI_INTER_QPU
-
+  
+  #ifdef RPI_INTER_QPU
+    // Define RPI_LUMA_QPU to also use QPU for luma inter prediction
+    #define RPI_LUMA_QPU
+  #endif
 #endif
 
 #define MAX_DPB_SIZE 16 // A.4.1
@@ -805,7 +809,6 @@ typedef struct HEVCLocalContext {
 
 // Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane, * 2 for bi
 #define RPI_MAX_MV_CMDS   (2*16*3*(RPI_MAX_WIDTH/4))
-#define RPI_MAX_XFM_CMDS  (16*3*(RPI_MAX_WIDTH/4))
 // Each block can have an intra prediction and a transform_add command
 #define RPI_MAX_PRED_CMDS (2*16*3*(RPI_MAX_WIDTH/4))
 // Worst case is 16x16 CTUs
@@ -840,9 +843,6 @@ typedef struct HEVCMvCmd {
     int8_t ref_idx[2];
 } HEVCMvCmd;
 
-// Command for transform to process a block of coefficients
-typedef struct HEVCXfmCmd {
-} HEVCXfmCmd;
 
 // Command for intra prediction and transform_add of predictions to coefficients
 #define RPI_PRED_TRANSFORM_ADD 0
@@ -888,8 +888,7 @@ typedef struct HEVCContext {
 
 #ifdef RPI
     int enable_rpi;
-    HEVCMvCmd *unif_mv_cmds;  // TODO rename
-    HEVCXfmCmd *unif_xfm_cmds;
+    HEVCMvCmd *unif_mv_cmds;
     HEVCPredCmd *univ_pred_cmds;
     int buf_width;
     GPU_MEM_PTR_T coeffs_buf_default;
@@ -916,6 +915,15 @@ typedef struct HEVCContext {
     uint32_t mc_filter_uv_b0;
     uint32_t mc_filter_uv_b;
 #endif
+#ifdef RPI_LUMA_QPU
+    GPU_MEM_PTR_T y_unif_mvs_ptr;
+    uint32_t *y_unif_mvs; // Base of memory for motion vector commands
+    uint32_t *y_mvs_base[12];
+    uint32_t *y_mvs[12];
+    // Function pointers
+    uint32_t mc_filter;
+    uint32_t mc_filter_b;
+#endif
     
 #endif
 
@@ -1150,6 +1158,10 @@ void ff_hevc_hls_filters(HEVCContext *s, int x_ctb, int y_ctb, int ctb_size);
 void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                                  int log2_trafo_size, enum ScanType scan_idx,
                                  int c_idx);
+                                 
+#ifdef RPI_INTER_QPU
+extern void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n);
+#endif                                 
 
 void ff_hevc_hls_mvd_coding(HEVCContext *s, int x0, int y0, int log2_cb_size);
 
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 0c59f5c..979ad61 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -882,8 +882,7 @@ static int ff_hevc_buf_base(AVBufferRef *bref) {
   return p->vc & 0x3fffffff;
 }
 
-void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n);
-void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
+void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
 {
     if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
             s->nal_unit_type == NAL_TSA_N   ||
@@ -910,10 +909,24 @@ void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
         iocache.s[1].cmd = 3; // clean+invalidate
         iocache.s[1].addr = p->arm + base;
         iocache.s[1].size  = sz;
+        
+#ifdef RPI_LUMA_QPU
+        p = av_buffer_pool_opaque(s->frame->buf[0]);
+        sz = s->frame->linesize[0] * (n-curr_y);
+        base = s->frame->linesize[0] * curr_y;
+        iocache.s[2].handle = p->vcsm_handle;
+        iocache.s[2].cmd = 3; // clean+invalidate
+        iocache.s[2].addr = p->arm + base;
+        iocache.s[2].size  = sz;
+#endif
         vcsm_clean_invalid( &iocache );
 #else            
         flush_buffer(s->frame->buf[1]);
         flush_buffer(s->frame->buf[2]);
+#ifdef RPI_LUMA_QPU
+        flush_buffer(s->frame->buf[1]);
+#endif
+
 #endif
         //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
         //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
@@ -936,7 +949,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
             sao_filter_CTB(s, x, y - ctb_size);
             if (s->threads_type & FF_THREAD_FRAME ) {
 #ifdef RPI_INTER_QPU
-                ff_hevc_flush_chroma(s,&s->ref->tf, y);
+                ff_hevc_flush_buffer(s,&s->ref->tf, y);
 #endif
                 ff_thread_report_progress(&s->ref->tf, y, 0);
             }
@@ -945,7 +958,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
             sao_filter_CTB(s, x , y);
             if (s->threads_type & FF_THREAD_FRAME ) {
 #ifdef RPI_INTER_QPU
-                ff_hevc_flush_chroma(s, &s->ref->tf, y + ctb_size);
+                ff_hevc_flush_buffer(s, &s->ref->tf, y + ctb_size);
 #endif
                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
             }
@@ -955,7 +968,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
         //int currh = s->ref->tf.progress->data[0];
         //if (((y + ctb_size)&63)==0)
 #ifdef RPI_INTER_QPU
-        ff_hevc_flush_chroma(s, &s->ref->tf, y + ctb_size - 4);
+        ff_hevc_flush_buffer(s, &s->ref->tf, y + ctb_size - 4);
 #endif
         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
     }
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 1e3a2d6..f8aca57 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -1,8 +1,10 @@
 // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
 // define RPI_TIME_TOTAL_QPU to print out how much time is spent in the QPU code
-#define RPI_TIME_TOTAL_QPU
+//#define RPI_TIME_TOTAL_QPU
 // define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
 //#define RPI_TIME_TOTAL_VPU
+// define RPI_TIME_TOTAL_POSTED to print out how much time is spent in the multi execute QPU/VPU combined
+//#define RPI_TIME_TOTAL_POSTED
 // define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
 #define RPI_ASYNC
 
@@ -91,7 +93,8 @@ struct GPU
   int open_count; // Number of allocated video buffers
   int      mb; // Mailbox handle
   int      vc; // Address in GPU memory
-  int mail[12]; // These are used to pass pairs of code/unifs to the QPUs
+  int mail[12*2]; // These are used to pass pairs of code/unifs to the QPUs for the first QPU task
+  int mail2[12*2]; // These are used to pass pairs of code/unifs to the QPUs for the second QPU task
 };
 
 // Stop more than one thread trying to allocate memory or use the processing resources at once
@@ -99,7 +102,7 @@ static pthread_mutex_t gpu_mutex = PTHREAD_MUTEX_INITIALIZER;
 static volatile struct GPU* gpu = NULL;
 static GPU_MEM_PTR_T gpu_mem_ptr;
 
-#if defined(RPI_TIME_TOTAL_QPU) || defined(RPI_TIME_TOTAL_VPU)
+#if defined(RPI_TIME_TOTAL_QPU) || defined(RPI_TIME_TOTAL_VPU) || defined(RPI_TIME_TOTAL_POSTED)
 static unsigned int Microseconds(void) {
     struct timespec ts;
     unsigned int x;
@@ -120,7 +123,7 @@ static pthread_cond_t post_cond_head = PTHREAD_COND_INITIALIZER;
 static pthread_cond_t post_cond_tail = PTHREAD_COND_INITIALIZER;
 static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-static int vpu_cmds[MAXCMDS][16];
+static int vpu_cmds[MAXCMDS][32];
 static volatile int vpu_async_tail=0; // Contains the number of posted jobs
 static volatile int vpu_async_head=0;
 #endif
@@ -244,7 +247,6 @@ int gpu_get_mailbox(void)
 // Call this to clean and invalidate a region of memory
 void gpu_cache_flush(GPU_MEM_PTR_T *p)
 {
-#define RPI_FAST_CACHEFLUSH
 #ifdef RPI_FAST_CACHEFLUSH
     struct vcsm_user_clean_invalid_s iocache = {};
     iocache.s[0].handle = p->vcsm_handle;
@@ -258,6 +260,34 @@ void gpu_cache_flush(GPU_MEM_PTR_T *p)
 #endif
 }
 
+void gpu_cache_flush3(GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2)
+{
+#ifdef RPI_FAST_CACHEFLUSH
+    struct vcsm_user_clean_invalid_s iocache = {};
+    iocache.s[0].handle = p0->vcsm_handle;
+    iocache.s[0].cmd = 3; // clean+invalidate
+    iocache.s[0].addr = (int) p0->arm;
+    iocache.s[0].size  = p0->numbytes;
+    iocache.s[1].handle = p1->vcsm_handle;
+    iocache.s[1].cmd = 3; // clean+invalidate
+    iocache.s[1].addr = (int) p1->arm;
+    iocache.s[1].size  = p1->numbytes;
+    iocache.s[2].handle = p2->vcsm_handle;
+    iocache.s[2].cmd = 3; // clean+invalidate
+    iocache.s[2].addr = (int) p2->arm;
+    iocache.s[2].size  = p2->numbytes;
+    vcsm_clean_invalid( &iocache );
+#else
+    void *tmp;
+    tmp = vcsm_lock(p0->vcsm_handle);
+    vcsm_unlock_ptr(tmp);
+    tmp = vcsm_lock(p1->vcsm_handle);
+    vcsm_unlock_ptr(tmp);
+    tmp = vcsm_lock(p2->vcsm_handle);
+    vcsm_unlock_ptr(tmp);
+#endif
+}
+
 static int gpu_malloc_cached_internal(int numbytes, GPU_MEM_PTR_T *p) {
   p->numbytes = numbytes;
   p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" );
@@ -354,9 +384,19 @@ unsigned int vpu_get_constants(void) {
 #ifdef RPI_ASYNC
 
 static void *vpu_start(void *arg) {
+#ifdef RPI_TIME_TOTAL_POSTED
+  int last_time=0;
+  long long on_time=0;
+  long long off_time=0;
+  int start_time;
+  int end_time;
+  int count=0;
+#endif
   while(1) {
+    int i;
     int *p;
     int qpu_code;
+    int qpu_codeb;
     pthread_mutex_lock(&post_mutex);
     while( vpu_async_tail - vpu_async_head <= 0)
     {
@@ -370,24 +410,49 @@ static void *vpu_start(void *arg) {
       break; // Last job
     }
     qpu_code = p[7];
+    qpu_codeb = p[16];
     //if (p[7]) {
         //GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
         //gpu_cache_flush(buf);
-    //}
+    //}    
+    
+#ifdef RPI_TIME_TOTAL_POSTED
+    start_time = Microseconds();
+    if (last_time==0)
+      last_time = start_time;
+    off_time += start_time-last_time;
+#endif
+    
     if (!qpu_code) {
       vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
     } else {
-      int i;
       for(i=0;i<8;i++) {
         gpu->mail[i*2] = p[8+i];
         gpu->mail[i*2 + 1] = qpu_code;  
       }
-     
-      execute_multi(gpu->mb,8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
-                              0, 0, 0, 0,
+      for(i=0;i<12;i++) {
+        gpu->mail2[i*2] = p[17+i];
+        gpu->mail2[i*2 + 1] = qpu_codeb;  
+      }
+#if (0)
+      vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
+      execute_qpu(gpu->mb,8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */);
+#else 
+      execute_multi(gpu->mb,
+                              12,gpu->vc + offsetof(struct GPU, mail2), 1, 5000,
+                              8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
                               p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
                               0,    0   , 0   , 0   , 0   , 0   , 0); // VPU1
+#endif
     }
+#ifdef RPI_TIME_TOTAL_POSTED
+    end_time = Microseconds();
+    last_time = end_time;
+    on_time += end_time - start_time;
+    count++;
+    if ((count&0x7f)==0)
+      printf("Posted %d On=%dms, Off=%dms\n",count,(int)(on_time/1000),(int)(off_time/1000));
+#endif
     pthread_mutex_lock(&post_mutex);
     vpu_async_head++;
     pthread_cond_broadcast(&post_cond_head);
@@ -433,7 +498,9 @@ int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned
 }
 
 int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, 
-                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8)
+                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8,
+                      int qpu_codeb, int unifs1b, int unifs2b, int unifs3b, int unifs4b, int unifs5b, int unifs6b, int unifs7b, int unifs8b, int unifs9b, int unifs10b, int unifs11b, int unifs12b
+                      )
 {
     
   pthread_mutex_lock(&post_mutex);
@@ -461,6 +528,21 @@ int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2,
     p[13] = unifs6;
     p[14] = unifs7;
     p[15] = unifs8;
+    
+    p[16] = qpu_codeb;
+    p[17] = unifs1b;
+    p[18] = unifs2b;
+    p[19] = unifs3b;
+    p[20] = unifs4b;
+    p[21] = unifs5b;
+    p[22] = unifs6b;
+    p[23] = unifs7b;
+    p[24] = unifs8b;
+    p[25] = unifs9b;
+    p[26] = unifs10b;
+    p[27] = unifs11b;
+    p[28] = unifs12b;
+    
     if (num<=1)
       pthread_cond_broadcast(&post_cond_tail); // Otherwise the vpu thread must already be awake
     pthread_mutex_unlock(&post_mutex);
@@ -541,27 +623,27 @@ void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int un
   off_time += start_time-last_time;
 #endif
   for(i=0;i<num;i++) {
-    gpu->mail[i*2 + 1] = code;  
+    gpu->mail2[i*2 + 1] = code;  
   }
   for(;i<num+num2;i++) {
-    gpu->mail[i*2 + 1] = code2;  
+    gpu->mail2[i*2 + 1] = code2;  
   }
-  gpu->mail[0 ] = unifs1;
-  gpu->mail[2 ] = unifs2;
-  gpu->mail[4 ] = unifs3;
-  gpu->mail[6 ] = unifs4;
-  gpu->mail[8 ] = unifs5;
-  gpu->mail[10] = unifs6;
-	gpu->mail[12] = unifs7;
-	gpu->mail[14] = unifs8;
-	gpu->mail[16] = unifs9;
-	gpu->mail[18] = unifs10;
-	gpu->mail[20] = unifs11;
-	gpu->mail[22] = unifs12;
+  gpu->mail2[0 ] = unifs1;
+  gpu->mail2[2 ] = unifs2;
+  gpu->mail2[4 ] = unifs3;
+  gpu->mail2[6 ] = unifs4;
+  gpu->mail2[8 ] = unifs5;
+  gpu->mail2[10] = unifs6;
+	gpu->mail2[12] = unifs7;
+	gpu->mail2[14] = unifs8;
+	gpu->mail2[16] = unifs9;
+	gpu->mail2[18] = unifs10;
+	gpu->mail2[20] = unifs11;
+	gpu->mail2[22] = unifs12;
 	execute_qpu(
 		gpu->mb,
 		12 /* Number of QPUs */,
-		gpu->vc + offsetof(struct GPU, mail),
+		gpu->vc + offsetof(struct GPU, mail2),
 		1 /* no flush */,  // Don't flush VPU L1 cache
 		5000 /* timeout ms */);
 #ifdef RPI_TIME_TOTAL_QPU
@@ -632,21 +714,21 @@ unsigned int qpu_get_fn(int num) {
       gpu_unlock();
     }
     switch(num) {
-    //case QPU_MC_SETUP:
-    //  fn = mc_setup;
-    //  break;
-    //case QPU_MC_FILTER:
-    //  fn = mc_filter;
-    //  break;
+    case QPU_MC_SETUP:
+      fn = mc_setup;
+      break;
+    case QPU_MC_FILTER:
+      fn = mc_filter;
+      break;
     case QPU_MC_EXIT:
       fn = mc_exit;
       break;
-    //case QPU_MC_INTERRUPT_EXIT:
-    //  fn = mc_interrupt_exit;
-    //  break;
-    //case QPU_MC_FILTER_B:
-    //  fn = mc_filter_b;
-    //  break;
+    case QPU_MC_INTERRUPT_EXIT12:
+      fn = mc_interrupt_exit12;
+      break;
+    case QPU_MC_FILTER_B:
+      fn = mc_filter_b;
+      break;
     //case QPU_MC_FILTER_HONLY:
     //  fn = mc_filter_honly;
     //  break;
diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
index fafe780..a753fbd 100644
--- a/libavcodec/rpi_qpu.h
+++ b/libavcodec/rpi_qpu.h
@@ -1,6 +1,7 @@
 #ifndef RPI_QPU_H
 #define RPI_QPU_H
 
+// Define RPI_FAST_CACHEFLUSH to use the VCSM cache flush code
 #define RPI_FAST_CACHEFLUSH
 
 typedef struct gpu_mem_ptr_s {
@@ -16,6 +17,7 @@ extern int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p);
 extern int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p);
 extern void gpu_free(GPU_MEM_PTR_T *p);
 extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
+extern void gpu_cache_flush3(GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
 
 // QPU specific functions
 extern void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
@@ -26,7 +28,7 @@ enum {
   QPU_MC_SETUP,
   QPU_MC_FILTER,
   QPU_MC_EXIT,
-  QPU_MC_INTERRUPT_EXIT,
+  QPU_MC_INTERRUPT_EXIT12,
   QPU_MC_FILTER_B,
   QPU_MC_FILTER_HONLY,
   QPU_MC_SETUP_UV,
@@ -44,7 +46,9 @@ extern unsigned int vpu_get_constants(void);
 extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
 extern int vpu_post_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf);
 int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, 
-                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
+                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8,
+                      int qpu_codeb, int unifs1b, int unifs2b, int unifs3b, int unifs4b, int unifs5b, int unifs6b, int unifs7b, int unifs8b, int unifs9b, int unifs10b, int unifs11b, int unifs12b
+                      );
 extern void vpu_wait( int id);
 
 // Simple test of shader code
diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
index a0f0282..e86eb30 100644
--- a/libavcodec/rpi_shader.c
+++ b/libavcodec/rpi_shader.c
@@ -48,693 +48,674 @@ unsigned int rpi_shader[] = {
 /* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
 /* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
 /* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x000000d0] */ 0x15827d80, 0x100208e7, // mov r3, unif
-/* [0x000000d8] */ 0x119c17c0, 0xd00208a7, // shl r2, r3, 1
-/* [0x000000e0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x000000e8] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x000000f0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x000000f8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000100] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000108] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000110] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000118] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
-/* [0x00000120] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
-/* [0x00000128] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00000130] */ 0x119c17c0, 0xd00208a7, // shl r2, r3, 1
-/* [0x00000138] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
-/* [0x00000140] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000148] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000150] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000158] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000160] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000168] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000170] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x00000178] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x00000180] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
-/* [0x00000188] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
-/* [0x00000190] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
-/* [0x00000198] */ 0x15427d80, 0x10020827, // mov r0, ra_x
-/* [0x000001a0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
-/* [0x000001a8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
-/* [0x000001b0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
-/* [0x000001b8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x000001c0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000001c8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000001d0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
+/* [0x000000d0] */ 0x15427d80, 0x10020827, // mov r0, ra_x
+/* [0x000000d8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+/* [0x000000e0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
+/* [0x000000e8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+/* [0x000000f0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x000000f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000100] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000108] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
+/* [0x00000110] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000118] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+/* [0x00000120] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
+/* [0x00000128] */ 0x0c9e7440, 0x10020f27, // add t1s, r2, r1
+/* [0x00000130] */ 0x00000008, 0xe00208a7, // mov r2,8
+/* [0x00000138] */ 0x11827c80, 0x10021327, // shl rb12,unif, r2
+/* [0x00000140] */ 0x0c827c80, 0x10021367, // add rb13,unif,r2
+/* [0x00000148] */ 0x15827d80, 0x100208a7, // mov r2, unif
+/* [0x00000150] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+/* [0x00000158] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+/* [0x00000160] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000168] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000170] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000178] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000180] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000188] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000190] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000198] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x000001a0] */ 0x0f9c11c0, 0xd00208a7, // asr r2, r0, 1
+/* [0x000001a8] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+/* [0x000001b0] */ 0x0c9e7440, 0x10021567, // add rb21, r2, r1
+/* [0x000001b8] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x000001c0] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x000001c8] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x000001d0] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
 /* [0x000001d8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x000001e0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
-/* [0x000001e8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
-/* [0x000001f0] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
-/* [0x000001f8] */ 0x15827d80, 0x10021327, // mov rb12,unif
-/* [0x00000200] */ 0x15827d80, 0x10021367, // mov rb13,unif
-/* [0x00000208] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000210] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000218] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000220] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000228] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000230] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
-/* [0x00000238] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+/* [0x000001e0] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x000001e8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000001f0] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x000001f8] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
+/* [0x00000200] */ 0x0c627380, 0x10020f27, // add t1s, r1, ra_frame_base
 // ::mc_filter_uv
-/* [0x00000240] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000248] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000250] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000258] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000260] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000268] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000270] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000278] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000280] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
-/* [0x00000288] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000290] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
-/* [0x00000298] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000002a0] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000002a8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000002b0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000002b8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000002c0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000002c8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000002d0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000002d8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000002e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000002e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000002f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000002f8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000300] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000308] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000310] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000318] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000320] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000328] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000330] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000338] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x00000340] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000348] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000350] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
-/* [0x00000358] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000360] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
-/* [0x00000368] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000370] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
-/* [0x00000378] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000380] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
-/* [0x00000388] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000390] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000208] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000210] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000218] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000220] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000228] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000230] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000238] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000240] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000248] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x00000250] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000258] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x00000260] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000268] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000270] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000278] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000280] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000288] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000290] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000298] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000002a0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000002a8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x000002b0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x000002b8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x000002c0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000002c8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000002d0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000002d8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000002e0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000002e8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000002f0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000002f8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000300] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000308] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000310] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000318] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+/* [0x00000320] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000328] */ 0x0f9e7080, 0x100208e7, // asr r3, r0, r2
+/* [0x00000330] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000338] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
+/* [0x00000340] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000348] */ 0x0f9e7080, 0x100608e7, // asr.ifnz r3, r0, r2
+/* [0x00000350] */ 0x119c87c0, 0xd00213a7, // shl rb14,r3,8
+/* [0x00000358] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop
-/* [0x00000398] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000003a0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
-/* [0x000003a8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x000003b0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x000003b8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x000003c0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x000003c8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000003d0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000003d8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-/* [0x000003e0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
-/* [0x000003e8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000003f0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000003f8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000400] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000408] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000410] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000418] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000420] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000428] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000430] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000438] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000440] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x00000448] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000450] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000458] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000460] */ 0x00000020, 0xe0021327, // mov rb12,32
-/* [0x00000468] */ 0x00000006, 0xe0021367, // mov rb13,6
-/* [0x00000470] */ 0x00000001, 0xe00213a7, // mov rb14,1
-/* [0x00000478] */ 0x00000000, 0xe00213e7, // mov rb15,0
-/* [0x00000480] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000488] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000490] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000498] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000004a0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000004a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000004b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000004b8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
-/* [0x000004c0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
-/* [0x000004c8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
-/* [0x000004d0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
-/* [0x000004d8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
-/* [0x000004e0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x000004e8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x000004f0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x000004f8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000500] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000508] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000510] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000518] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000520] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000528] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000530] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000360] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000368] */ 0x8e4539bf, 0xb0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
+/* [0x00000370] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00000378] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000380] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000388] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000390] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000398] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000003a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x000003a8] */ 0x0c627c80, 0x10020f27, // add t1s, ra_frame_base, r2
+/* [0x000003b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000003b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000003c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000003c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000003d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000003d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000003e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x000003e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x000003f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000003f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000400] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000408] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000410] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000418] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000420] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000428] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000430] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000438] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000440] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000448] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000450] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000458] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000460] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+/* [0x00000468] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+/* [0x00000470] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+/* [0x00000478] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:uvloop
+/* [0x00000480] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+/* [0x00000488] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00000490] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00000498] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000004a0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004a8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000004b0] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000004b8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000004c0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000004c8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000004d0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000004d8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_uv_b0
-/* [0x00000538] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000540] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00000548] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000550] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000558] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x00000560] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000568] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x00000570] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x00000578] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
-/* [0x00000580] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000588] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
-/* [0x00000590] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
-/* [0x00000598] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000005a0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005a8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000005b0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000005b8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x000005c0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x000005c8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x000005d0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x000005d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x000005e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x000005e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x000005f0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000005f8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000600] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000608] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000610] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000618] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000620] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000628] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000630] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x00000638] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000640] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000648] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x00000650] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000658] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x000004e0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x000004e8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x000004f0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x000004f8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000500] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000508] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000510] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000518] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000520] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x00000528] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000530] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x00000538] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+/* [0x00000540] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x00000548] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000550] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x00000558] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000560] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000568] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x00000570] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x00000578] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000580] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000588] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000590] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000598] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005a0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005a8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005b0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005b8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x000005c0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000005c8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x000005d0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x000005d8] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x000005e0] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005e8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000005f0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x000005f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000600] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b0
-/* [0x00000660] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x00000668] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
-/* [0x00000670] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x00000678] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000680] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000688] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000690] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000698] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x000006a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-/* [0x000006a8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
-/* [0x000006b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000006b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000006c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000006c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000006d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000006d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000006e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000006e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000006f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x000006f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000700] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000708] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000710] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000718] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00000720] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00000728] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00000730] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x00000738] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x00000740] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x00000748] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x00000750] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
-/* [0x00000758] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
-/* [0x00000760] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
-/* [0x00000768] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000770] */ 0x009e7000, 0x100009e7, // nop
-/* [0x00000778] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000780] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000788] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000790] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000608] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000610] */ 0x8e4539bf, 0xb0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
+/* [0x00000618] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00000620] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00000628] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x00000630] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00000638] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00000640] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x00000648] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x00000650] */ 0x0c627c80, 0x10020f27, // add t1s, ra_frame_base, r2
+/* [0x00000658] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000660] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x00000668] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x00000670] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x00000678] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000680] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000688] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000690] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000698] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x000006a0] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x000006a8] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x000006b0] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x000006b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x000006c0] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x000006c8] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000006d0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000006d8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000006e0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000006e8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000006f0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000006f8] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+/* [0x00000700] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+/* [0x00000708] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+/* [0x00000710] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000718] */ 0x009e7000, 0x100009e7, // nop
+/* [0x00000720] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000728] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000730] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000738] */ 0x009e7000, 0x100009e7, // nop
 // ::mc_filter_uv_b
-/* [0x00000798] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x000007a0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x000007a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000007b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x000007b8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
-/* [0x000007c0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x000007c8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
-/* [0x000007d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
-/* [0x000007d8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
-/* [0x000007e0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x000007e8] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
-/* [0x000007f0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000007f8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000800] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000808] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000810] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000818] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000820] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
-/* [0x00000828] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
-/* [0x00000830] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000838] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
-/* [0x00000840] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
-/* [0x00000848] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
-/* [0x00000850] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000858] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000860] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000868] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
-/* [0x00000870] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000878] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000880] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000888] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000890] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000898] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008a0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000008a8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000008b0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
-/* [0x000008b8] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000008c0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000008c8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
-/* [0x000008d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000008d8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000740] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+/* [0x00000748] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+/* [0x00000750] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+/* [0x00000758] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+/* [0x00000760] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+/* [0x00000768] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000770] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+/* [0x00000778] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+/* [0x00000780] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+/* [0x00000788] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000790] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+/* [0x00000798] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x000007a0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+/* [0x000007a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x000007b0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+/* [0x000007b8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x000007c0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x000007c8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+/* [0x000007d0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+/* [0x000007d8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x000007e0] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+/* [0x000007e8] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+/* [0x000007f0] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+/* [0x000007f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000800] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+/* [0x00000808] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000810] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+/* [0x00000818] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000820] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000828] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000830] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000838] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+/* [0x00000840] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000848] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+/* [0x00000850] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000858] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000860] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000868] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000870] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+/* [0x00000878] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x00000880] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :uvloop_b
-/* [0x000008e0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
-/* [0x000008e8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
-/* [0x000008f0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x000008f8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000900] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
-/* [0x00000908] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000910] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000918] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
-/* [0x00000920] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-/* [0x00000928] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
-/* [0x00000930] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000938] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000940] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000948] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000950] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000958] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000960] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000968] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000970] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00000978] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00000980] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
-/* [0x00000988] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x00000990] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00000998] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x000009a0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x000009a8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x000009b0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000009b8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000009c0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000009c8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000009d0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000009d8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000009e0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
-/* [0x000009e8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
-/* [0x000009f0] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
-/* [0x000009f8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00000a00] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00000a08] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00000a10] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00000a18] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a20] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
-/* [0x00000a28] */ 0x00000010, 0xe0020827, // mov r0, 16
-/* [0x00000a30] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
-/* [0x00000a38] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00000a40] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
-/* [0x00000a48] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00000a50] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00000888] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+/* [0x00000890] */ 0x8e4539bf, 0xb0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
+/* [0x00000898] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x000008a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x000008a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+/* [0x000008b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x000008b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000008c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+/* [0x000008c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+/* [0x000008d0] */ 0x0c627c80, 0x10020f27, // add t1s, ra_frame_base, r2
+/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000008e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000008e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000008f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000008f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x00000900] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00000908] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00000910] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00000918] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00000920] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00000928] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+/* [0x00000930] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x00000938] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00000940] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00000948] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x00000950] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x00000958] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x00000960] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x00000968] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x00000970] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x00000978] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x00000980] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00000988] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+/* [0x00000990] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+/* [0x00000998] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+/* [0x000009a0] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+/* [0x000009a8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x000009b0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x000009b8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x000009c0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000009c8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x000009d0] */ 0x00000010, 0xe0020827, // mov r0, 16
+/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+/* [0x000009e0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x000009e8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+/* [0x000009f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x000009f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_exit
-/* [0x00000a58] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000a60] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
-/* [0x00000a68] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a70] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000a88] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000a90] */ 0x009e7000, 0x100009e7, // nop        ; nop
-/* [0x00000a98] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a08] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+/* [0x00000a10] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a18] */ 0x009e7000, 0xb00009e7, // ldtmu1
+/* [0x00000a20] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a28] */ 0x009e7000, 0xb00009e7, // ldtmu1
+/* [0x00000a30] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000a38] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a40] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_interrupt_exit8
-/* [0x00000aa0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00000aa8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ab0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00000ac8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ad0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00000b00] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x00000b08] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x00000b10] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00000a48] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a58] */ 0x009e7000, 0xb00009e7, // ldtmu1
+/* [0x00000a60] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00000a68] */ 0x009e7000, 0xb00009e7, // ldtmu1
+/* [0x00000a70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000a98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000aa0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00000ab0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_setup
-/* [0x00000b18] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000b20] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00000b28] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000b30] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000b38] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00000b40] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000b48] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
-/* [0x00000b50] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00000b58] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
-/* [0x00000b60] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x00000b68] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000b70] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
-/* [0x00000b78] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
-/* [0x00000b80] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000b88] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000b90] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00000b98] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
-/* [0x00000ba0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
-/* [0x00000ba8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00000bb0] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
-/* [0x00000bb8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
-/* [0x00000bc0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000bc8] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
-/* [0x00000bd0] */ 0x8c9e7452, 0x10025e19, // add t0s, r2, r1 ; mov ra_frame_base2, r2
-/* [0x00000bd8] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
-/* [0x00000be0] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
-/* [0x00000be8] */ 0x15827d80, 0x10021427, // mov rb16, unif
-/* [0x00000bf0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000bf8] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
-/* [0x00000c00] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
-/* [0x00000c08] */ 0x00000001, 0xe0020527, // mov ra20, 1
-/* [0x00000c10] */ 0x00000100, 0xe00205a7, // mov ra22, 256
-/* [0x00000c18] */ 0x00000040, 0xe00207a7, // mov ra30, 64
-/* [0x00000c20] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
-/* [0x00000c28] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
-/* [0x00000c30] */ 0x00000018, 0xe00215e7, // mov rb23, 24
-/* [0x00000c38] */ 0x00000000, 0xe0020227, // mov ra8, 0
-/* [0x00000c40] */ 0x00000000, 0xe0020267, // mov ra9, 0
-/* [0x00000c48] */ 0x00000000, 0xe00202a7, // mov ra10, 0
-/* [0x00000c50] */ 0x00000000, 0xe00202e7, // mov ra11, 0
-/* [0x00000c58] */ 0x00000000, 0xe0020327, // mov ra12, 0
-/* [0x00000c60] */ 0x00000000, 0xe0020367, // mov ra13, 0
-/* [0x00000c68] */ 0x00000000, 0xe00203a7, // mov ra14, 0
-/* [0x00000c70] */ 0x00000000, 0xe00203e7, // mov ra15, 0
-/* [0x00000c78] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000c80] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000c88] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000c90] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000c98] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000ca0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000ca8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000cb0] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
-/* [0x00000cb8] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
-/* [0x00000cc0] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
-/* [0x00000cc8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
-/* [0x00000cd0] */ 0x159e7480, 0x10020867, // mov r1, r2
-/* [0x00000cd8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
-/* [0x00000ce0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
-/* [0x00000ce8] */ 0x159e7480, 0x10020827, // mov r0, r2
-/* [0x00000cf0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
-/* [0x00000cf8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000d00] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
-/* [0x00000d08] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
-/* [0x00000d10] */ 0x15827d80, 0x10021327, // mov rb12,unif
-/* [0x00000d18] */ 0x15827d80, 0x10021367, // mov rb13,unif
-/* [0x00000d20] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000d28] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
-/* [0x00000d30] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000d38] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
-/* [0x00000d40] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000d48] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
-/* [0x00000d50] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
-/* [0x00000d58] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
-/* [0x00000d60] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00000ac0] */ 0x00000010, 0xe00208e7, // mov r3, 16
+/* [0x00000ac8] */ 0x15827d80, 0x10020227, // mov ra8, unif
+/* [0x00000ad0] */ 0x15827d80, 0x10020267, // mov ra9, unif
+/* [0x00000ad8] */ 0x15827d80, 0x100202a7, // mov ra10, unif
+/* [0x00000ae0] */ 0x15827d80, 0x100202e7, // mov ra11, unif
+/* [0x00000ae8] */ 0x15827d80, 0x10020867, // mov r1, unif
+/* [0x00000af0] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
+/* [0x00000af8] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
+/* [0x00000b00] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
+/* [0x00000b08] */ 0x0d9c13c0, 0xd0021667, // sub rb_frame_width_minus_1,r1,1
+/* [0x00000b10] */ 0x0d9c11c0, 0xd00217a7, // sub rb_frame_height_minus_1,r0,1
+/* [0x00000b18] */ 0x15827d80, 0x10021427, // mov rb_pitch, unif
+/* [0x00000b20] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000b28] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+/* [0x00000b30] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+/* [0x00000b38] */ 0x15227d80, 0x10020867, // mov r1, ra8
+/* [0x00000b40] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
+/* [0x00000b48] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
+/* [0x00000b50] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
+/* [0x00000b58] */ 0x0c9a7180, 0x10020827, // add r0, r0, elem_num
+/* [0x00000b60] */ 0x139c01c0, 0xd0020827, // max r0, r0, 0
+/* [0x00000b68] */ 0x922591f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, ra9
+/* [0x00000b70] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000b78] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+/* [0x00000b80] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000b88] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+/* [0x00000b90] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000b98] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000ba0] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+/* [0x00000ba8] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
+/* [0x00000bb0] */ 0x152a7d80, 0x10020867, // mov r1, ra10
+/* [0x00000bb8] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
+/* [0x00000bc0] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
+/* [0x00000bc8] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
+/* [0x00000bd0] */ 0x0c9a7180, 0x10020827, // add r0, r0, elem_num
+/* [0x00000bd8] */ 0x139c01c0, 0xd0020827, // max r0, r0, 0
+/* [0x00000be0] */ 0x922d91f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, ra11
+/* [0x00000be8] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+/* [0x00000bf0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
+/* [0x00000bf8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000c00] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+/* [0x00000c08] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+/* [0x00000c10] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000c18] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+/* [0x00000c20] */ 0x8c9e7452, 0x10025f19, // add t1s, r2, r1 ; mov ra_frame_base2, r2
+/* [0x00000c28] */ 0x00000001, 0xe0020527, // mov ra20, 1
+/* [0x00000c30] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+/* [0x00000c38] */ 0x00000040, 0xe00207a7, // mov ra30, 64
+/* [0x00000c40] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+/* [0x00000c48] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+/* [0x00000c50] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+/* [0x00000c58] */ 0x00000000, 0xe0020227, // mov ra8, 0
+/* [0x00000c60] */ 0x00000000, 0xe0020267, // mov ra9, 0
+/* [0x00000c68] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+/* [0x00000c70] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+/* [0x00000c78] */ 0x00000000, 0xe0020327, // mov ra12, 0
+/* [0x00000c80] */ 0x00000000, 0xe0020367, // mov ra13, 0
+/* [0x00000c88] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+/* [0x00000c90] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+/* [0x00000c98] */ 0x00004000, 0xe00204a7, // mov ra18, 0x4000
+/* [0x00000ca0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+/* [0x00000ca8] */ 0x159e7480, 0x10020867, // mov r1, r2
+/* [0x00000cb0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+/* [0x00000cb8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+/* [0x00000cc0] */ 0x159e7480, 0x10020827, // mov r0, r2
+/* [0x00000cc8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+/* [0x00000cd0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000cd8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+/* [0x00000ce0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+/* [0x00000ce8] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+/* [0x00000cf0] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+/* [0x00000cf8] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+/* [0x00000d00] */ 0x15827d80, 0x10020867, // mov r1, unif
+/* [0x00000d08] */ 0x919c82ff, 0xd0024822, // shl r0,r1,r3 ; mov r2,8
+/* [0x00000d10] */ 0x0f9e70c0, 0x10021367, // asr rb13,r0,r3
+/* [0x00000d18] */ 0x0f9e72c0, 0x10021327, // asr rb12,r1,r3
+/* [0x00000d20] */ 0x0c9cde80, 0x10021367, // add rb13,rb13,r2
+/* [0x00000d28] */ 0x119cce80, 0x10021327, // shl rb12, rb12, r2
+/* [0x00000d30] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+/* [0x00000d38] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+/* [0x00000d40] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+/* [0x00000d48] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+/* [0x00000d50] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+/* [0x00000d58] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
+/* [0x00000d60] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
 /* [0x00000d68] */ 0x0c541dc0, 0xd0020567, // add ra_y2, ra_y2, 1
 /* [0x00000d70] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
-/* [0x00000d78] */ 0x0c667380, 0x10020e27, // add t0s, r1, ra_frame_base2
-// ::mc_filter
+/* [0x00000d78] */ 0x0c667380, 0x10020f27, // add t1s, r1, ra_frame_base2
+// :per_block_setup
 /* [0x00000d80] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 /* [0x00000d88] */ 0x15827d80, 0x100207e7, // mov ra31, unif
 /* [0x00000d90] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
 /* [0x00000d98] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
-/* [0x00000da0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000da8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00000db0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00000db8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00000dc0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00000dc8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00000dd0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
-/* [0x00000dd8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00000de0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
-/* [0x00000de8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00000df0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
-/* [0x00000df8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
-/* [0x00000e00] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00000e08] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
-/* [0x00000e10] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x00000e18] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x00000e20] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000e28] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x00000e30] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x00000e38] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00000e40] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00000e48] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00000e50] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00000e58] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00000e60] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000e68] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00000e70] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000e78] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000e80] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000e88] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000e90] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000e98] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00000ea0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000ea8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000eb0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000eb8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ec0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x00000ec8] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000ed0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000ed8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x00000ee0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000ee8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x00000ef0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000ef8] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f00] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00000f08] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000da0] */ 0x00000010, 0xe00208e7, // mov r3, 16
+/* [0x00000da8] */ 0x15827d80, 0x10020867, // mov r1, unif
+/* [0x00000db0] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
+/* [0x00000db8] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
+/* [0x00000dc0] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
+/* [0x00000dc8] */ 0x0c9a7180, 0x10020827, // add r0, r0, elem_num
+/* [0x00000dd0] */ 0x139c01c0, 0xd0020827, // max r0, r0, 0
+/* [0x00000dd8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000de0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+/* [0x00000de8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+/* [0x00000df0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000df8] */ 0x8c827436, 0x100246a1, // add ra_frame_base_next, r2, r0 ; mov r1, unif
+/* [0x00000e00] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
+/* [0x00000e08] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
+/* [0x00000e10] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
+/* [0x00000e18] */ 0x0c9a7180, 0x10020827, // add r0, r0, elem_num
+/* [0x00000e20] */ 0x139c01c0, 0xd0020827, // max r0, r0, 0
+/* [0x00000e28] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+/* [0x00000e30] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+/* [0x00000e38] */ 0x159e7240, 0x10021067, // mov ra_y2_next, r1
+/* [0x00000e40] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+/* [0x00000e48] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+/* [0x00000e50] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+/* [0x00000e58] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00000e60] */ 0x0e9e70c0, 0x10020867, // shr r1, r0, r3
+/* [0x00000e68] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+/* [0x00000e70] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+/* [0x00000e78] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+/* [0x00000e80] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+/* [0x00000e88] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+/* [0x00000e90] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+/* [0x00000e98] */ 0x119e70c0, 0x10020827, // shl r0, r0, r3
+/* [0x00000ea0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+/* [0x00000ea8] */ 0x95801dbf, 0xd0024821, // mov r0, unif ; mov r1,1
+/* [0x00000eb0] */ 0x4f5971c6, 0x10024260, // asr ra9, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000eb8] */ 0x4f5971c6, 0x10024220, // asr ra8, r0, rb23;      mul24 r0, r0, ra22
+/* [0x00000ec0] */ 0x4f5971c6, 0x10044260, // asr.ifz ra9, r0, rb23;  mul24 r0, r0, ra22
+/* [0x00000ec8] */ 0x0f9d71c0, 0x10040227, // asr.ifz ra8, r0, rb23
+/* [0x00000ed0] */ 0x0d243f80, 0xd0020267, // sub ra9,3,ra9
+/* [0x00000ed8] */ 0x0d203f80, 0xd0020227, // sub ra8,3,ra8
+/* [0x00000ee0] */ 0x11243dc0, 0xd0020267, // shl ra9,ra9,3
+/* [0x00000ee8] */ 0x11203dc0, 0xd0020227, // shl ra8,ra8,3
+/* [0x00000ef0] */ 0x00ffff00, 0xe0020867, // mov r1,0xffff00
+/* [0x00000ef8] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
+/* [0x00000f00] */ 0x0f9d71c0, 0x10020027, // asr ra0, r0, rb23
+/* [0x00000f08] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
 /* [0x00000f10] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
-/* [0x00000f18] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00000f20] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
-/* [0x00000f28] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
-/* [0x00000f30] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00000f38] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
-/* [0x00000f40] */ 0x00000000, 0xe00208e7, // mov r3, 0
+/* [0x00000f18] */ 0x01040400, 0xe0020867, // mov r1,0x1040400
+/* [0x00000f20] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
+/* [0x00000f28] */ 0x0f9d71c0, 0x10020067, // asr ra1, r0, rb23
+/* [0x00000f30] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
+/* [0x00000f38] */ 0x0f9d71c0, 0x10021167, // asr rb5, r0, rb23
+/* [0x00000f40] */ 0xfbf5f600, 0xe0020867, // mov r1,0xfbf5f600
+/* [0x00000f48] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
+/* [0x00000f50] */ 0x0f9d71c0, 0x100200a7, // asr ra2, r0, rb23
+/* [0x00000f58] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
+/* [0x00000f60] */ 0x0f9d71c0, 0x100211a7, // asr rb6, r0, rb23
+/* [0x00000f68] */ 0x11283a40, 0xe0020867, // mov r1,0x11283a40
+/* [0x00000f70] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
+/* [0x00000f78] */ 0x0f9d71c0, 0x100200e7, // asr ra3, r0, rb23
+/* [0x00000f80] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
+/* [0x00000f88] */ 0x0f9d71c0, 0x100211e7, // asr rb7, r0, rb23
+/* [0x00000f90] */ 0x3a281100, 0xe0020867, // mov r1,0x3a281100
+/* [0x00000f98] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
+/* [0x00000fa0] */ 0x0f9d71c0, 0x10020127, // asr ra4, r0, rb23
+/* [0x00000fa8] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
+/* [0x00000fb0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+/* [0x00000fb8] */ 0xf6f5fb00, 0xe0020867, // mov r1,0xf6f5fb00
+/* [0x00000fc0] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
+/* [0x00000fc8] */ 0x0f9d71c0, 0x10020167, // asr ra5, r0, rb23
+/* [0x00000fd0] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
+/* [0x00000fd8] */ 0x0f9d71c0, 0x10021267, // asr rb9, r0, rb23
+/* [0x00000fe0] */ 0x04040100, 0xe0020867, // mov r1,0x4040100
+/* [0x00000fe8] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
+/* [0x00000ff0] */ 0x0f9d71c0, 0x100201a7, // asr ra6, r0, rb23
+/* [0x00000ff8] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
+/* [0x00001000] */ 0x0f9d71c0, 0x100212a7, // asr rb10, r0, rb23
+/* [0x00001008] */ 0xffff0000, 0xe0020867, // mov r1,0xffff0000
+/* [0x00001010] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
+/* [0x00001018] */ 0x0f9d71c0, 0x100201e7, // asr ra7, r0, rb23
+/* [0x00001020] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
+/* [0x00001028] */ 0x0f9d71c0, 0x100212e7, // asr rb11, r0, rb23
+/* [0x00001030] */ 0x15827d80, 0x10020827, // mov r0, unif
+/* [0x00001038] */ 0x0f9e70c0, 0x100213e7, // asr rb15, r0, r3
+/* [0x00001040] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+/* [0x00001048] */ 0x119e70c0, 0x10020827, // shl r0, r0, r3
+/* [0x00001050] */ 0x8f9c00ff, 0xd0024823, // asr r0, r0, r3 ; mov r3, 0
+/* [0x00001058] */ 0x119c81c0, 0xd00213a7, // shl rb14, r0, 8
+// ::mc_filter
 // :yloop
-/* [0x00000f48] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
-/* [0x00000f50] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
-/* [0x00000f58] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x00000f60] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00000f68] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
-/* [0x00000f70] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
-/* [0x00000f78] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00000f80] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000f88] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
-/* [0x00000f90] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
-/* [0x00000f98] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
-/* [0x00000fa0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00000fa8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
-/* [0x00000fb0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
-/* [0x00000fb8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00000fc0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x00000fc8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x00000fd0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x00000fd8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x00000fe0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x00000fe8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x00000ff0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x00000ff8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00001000] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00001008] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00001010] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00001018] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00001020] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00001028] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00001030] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00001038] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00001040] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00001048] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
-/* [0x00001050] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00001058] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00001060] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00001068] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00001070] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
-/* [0x00001078] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00001080] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00001088] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00001090] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00001098] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000010a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000010a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000010b0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
-/* [0x000010b8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
-/* [0x000010c0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
-/* [0x000010c8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
-/* [0x000010d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000010d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000010e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000010e8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
-/* [0x000010f0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
-/* [0x000010f8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
-/* [0x00001100] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
-/* [0x00001108] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
-/* [0x00001110] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00001118] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00001120] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001128] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00001130] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00001138] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00001060] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+/* [0x00001068] */ 0x8e4539bf, 0xb0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu1
+/* [0x00001070] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00001078] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00001080] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+/* [0x00001088] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+/* [0x00001090] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00001098] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000010a0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+/* [0x000010a8] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+/* [0x000010b0] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+/* [0x000010b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000010c0] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+/* [0x000010c8] */ 0xec654c8f, 0x10024f21, // add t1s, ra_frame_base2, r2   ; v8subs r1, r1, rb20
+/* [0x000010d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000010d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000010e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000010e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000010f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000010f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x00001100] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00001108] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00001110] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00001118] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00001120] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00001128] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00001130] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00001138] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00001140] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00001148] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00001150] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00001158] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00001160] */ 0x8d2487f6, 0xd00279c8, // sub.setf -, r3, 8    ; mov ra8, ra9
+/* [0x00001168] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00001170] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00001178] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00001180] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00001188] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
+/* [0x00001190] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00001198] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x000011a0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000011a8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000011b0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000011b8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000011c0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000011c8] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+/* [0x000011d0] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+/* [0x000011d8] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+/* [0x000011e0] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+/* [0x000011e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000011f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000011f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+/* [0x00001200] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+/* [0x00001208] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+/* [0x00001210] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+/* [0x00001218] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
+/* [0x00001220] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+/* [0x00001228] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00001230] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00001238] */ 0xfffffb28, 0xf0f809e7, // brr -, r:per_block_setup
+/* [0x00001240] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00001248] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001250] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_filter_b
-/* [0x00001140] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x00001148] */ 0x15827d80, 0x100207e7, // mov ra31, unif
-/* [0x00001150] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
-/* [0x00001158] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
-/* [0x00001160] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x00001168] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
-/* [0x00001170] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x00001178] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
-/* [0x00001180] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
-/* [0x00001188] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x00001190] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
-/* [0x00001198] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
-/* [0x000011a0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
-/* [0x000011a8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
-/* [0x000011b0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
-/* [0x000011b8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
-/* [0x000011c0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
-/* [0x000011c8] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
-/* [0x000011d0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
-/* [0x000011d8] */ 0x00000010, 0xe00208a7, // mov r2, 16
-/* [0x000011e0] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x000011e8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
-/* [0x000011f0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
-/* [0x000011f8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
-/* [0x00001200] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
-/* [0x00001208] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
-/* [0x00001210] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
-/* [0x00001218] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
-/* [0x00001220] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00001228] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
-/* [0x00001230] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001238] */ 0x00000001, 0xe0020867, // mov r1, 1
-/* [0x00001240] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x00001248] */ 0x409f3001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 13, r1 << 13
-/* [0x00001250] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001258] */ 0x409f2001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 14, r1 << 14
-/* [0x00001260] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001268] */ 0x409f1001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 15, r1 << 15
-/* [0x00001270] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001278] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
-/* [0x00001280] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x00001288] */ 0x409f7001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 9, r1 << 9
-/* [0x00001290] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001298] */ 0x409f6001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 10, r1 << 10
-/* [0x000012a0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000012a8] */ 0x409f5001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 11, r1 << 11
-/* [0x000012b0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000012b8] */ 0x409f4001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 12, r1 << 12
-/* [0x000012c0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
-/* [0x000012c8] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x000012d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000012d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
-/* [0x000012e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
-/* [0x000012e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
-/* [0x000012f0] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x000012f8] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001300] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001308] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
-/* [0x00001310] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
-/* [0x00001318] */ 0x15827d80, 0x10020827, // mov r0, unif
-/* [0x00001320] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
-/* [0x00001328] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
-/* [0x00001330] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
-/* [0x00001338] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
-/* [0x00001340] */ 0x00000000, 0xe00208e7, // mov r3, 0
 // :yloopb
-/* [0x00001348] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
-/* [0x00001350] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
-/* [0x00001358] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-/* [0x00001360] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
-/* [0x00001368] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
-/* [0x00001370] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
-/* [0x00001378] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
-/* [0x00001380] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x00001388] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
-/* [0x00001390] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
-/* [0x00001398] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
-/* [0x000013a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
-/* [0x000013a8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
-/* [0x000013b0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
-/* [0x000013b8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-/* [0x000013c0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
-/* [0x000013c8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-/* [0x000013d0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
-/* [0x000013d8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-/* [0x000013e0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-/* [0x000013e8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-/* [0x000013f0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-/* [0x000013f8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-/* [0x00001400] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-/* [0x00001408] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-/* [0x00001410] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-/* [0x00001418] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-/* [0x00001420] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-/* [0x00001428] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-/* [0x00001430] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-/* [0x00001438] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-/* [0x00001440] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
-/* [0x00001448] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
-/* [0x00001450] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
-/* [0x00001458] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
-/* [0x00001460] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
-/* [0x00001468] */ 0x15367d80, 0x10020327, // mov ra12, ra13
-/* [0x00001470] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
-/* [0x00001478] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
-/* [0x00001480] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
-/* [0x00001488] */ 0x159e7000, 0x100203e7, // mov ra15, r0
-/* [0x00001490] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
-/* [0x00001498] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
-/* [0x000014a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
-/* [0x000014a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
-/* [0x000014b0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
-/* [0x000014b8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
-/* [0x000014c0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
-/* [0x000014c8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
-/* [0x000014d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
-/* [0x000014d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-/* [0x000014e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
-/* [0x000014e8] */ 0x4053800e, 0xd00049e1, // nop                     ; mul24 r1, r1 << 8, ra20 << 8
-/* [0x000014f0] */ 0x4c78e38f, 0x10024860, // add r1, r1, ra30        ; mul24 r0, r1, rb14
-/* [0x000014f8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
-/* [0x00001500] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloopb
-/* [0x00001508] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
-/* [0x00001510] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
-/* [0x00001518] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
-/* [0x00001520] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
-/* [0x00001528] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
-/* [0x00001530] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
-/* [0x00001538] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+/* [0x00001258] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+/* [0x00001260] */ 0x8e4539bf, 0xb0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu1
+/* [0x00001268] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+/* [0x00001270] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+/* [0x00001278] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+/* [0x00001280] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+/* [0x00001288] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+/* [0x00001290] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x00001298] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+/* [0x000012a0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+/* [0x000012a8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+/* [0x000012b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+/* [0x000012b8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+/* [0x000012c0] */ 0xec654c8f, 0x10024f21, // add t1s, ra_frame_base2, r2   ; v8subs r1, r1, rb20
+/* [0x000012c8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+/* [0x000012d0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+/* [0x000012d8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+/* [0x000012e0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+/* [0x000012e8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+/* [0x000012f0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+/* [0x000012f8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+/* [0x00001300] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+/* [0x00001308] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+/* [0x00001310] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+/* [0x00001318] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+/* [0x00001320] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+/* [0x00001328] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+/* [0x00001330] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+/* [0x00001338] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+/* [0x00001340] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+/* [0x00001348] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+/* [0x00001350] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+/* [0x00001358] */ 0x8d2487f6, 0xd00279c8, // sub.setf -, r3, 8    ; mov ra8, ra9
+/* [0x00001360] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+/* [0x00001368] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+/* [0x00001370] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+/* [0x00001378] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+/* [0x00001380] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
+/* [0x00001388] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+/* [0x00001390] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+/* [0x00001398] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+/* [0x000013a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+/* [0x000013a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+/* [0x000013b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+/* [0x000013b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+/* [0x000013c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+/* [0x000013c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+/* [0x000013d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+/* [0x000013d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+/* [0x000013e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+/* [0x000013e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+/* [0x000013f0] */ 0x0f9ce3c0, 0xd0020827, // asr r0, r1, 14
+/* [0x000013f8] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+/* [0x00001400] */ 0x405b8006, 0xd00049e0, // nop                     ; mul24 r0, r0 << 8, ra22 << 8
+/* [0x00001408] */ 0x0c4a7380, 0x10020867, // add r1, r1, ra18
+/* [0x00001410] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+/* [0x00001418] */ 0xfffffe20, 0xf06809e7, // brr.anyn -, r:yloopb
+/* [0x00001420] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+/* [0x00001428] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+/* [0x00001430] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+/* [0x00001438] */ 0xfffff928, 0xf0f809e7, // brr -, r:per_block_setup
+/* [0x00001440] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+/* [0x00001448] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+/* [0x00001450] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
 // ::mc_interrupt_exit12
-/* [0x00001540] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
-/* [0x00001548] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001550] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001558] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001560] */ 0x009e7000, 0xa00009e7, // ldtmu0
-/* [0x00001568] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001570] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001578] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001580] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001588] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001590] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x00001598] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000015a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000015a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000015b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000015b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
-/* [0x000015c0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
-/* [0x000015c8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
-/* [0x000015d0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+/* [0x00001458] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x00001460] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001468] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001470] */ 0x009e7000, 0xb00009e7, // ldtmu1
+/* [0x00001478] */ 0x009e7000, 0xb00009e7, // ldtmu1
+/* [0x00001480] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001488] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001490] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x00001498] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000014a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000014a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000014b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000014b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000014c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000014c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000014d0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+/* [0x000014d8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x000014e0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x000014e8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+// ::mc_exit1
+/* [0x000014f0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+/* [0x000014f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001500] */ 0x009e7000, 0xb00009e7, // ldtmu1
+/* [0x00001508] */ 0x009e7000, 0xa00009e7, // ldtmu0
+/* [0x00001510] */ 0x009e7000, 0xb00009e7, // ldtmu1
+/* [0x00001518] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+/* [0x00001520] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+/* [0x00001528] */ 0x009e7000, 0x100009e7, // nop        ; nop
 // ::mc_end
 };
 #ifdef __HIGHC__
diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
index 6e552d9..760bd17 100644
--- a/libavcodec/rpi_shader.h
+++ b/libavcodec/rpi_shader.h
@@ -4,15 +4,16 @@
 extern unsigned int rpi_shader[];
 
 #define mc_setup_uv (rpi_shader + 0)
-#define mc_filter_uv (rpi_shader + 144)
-#define mc_filter_uv_b0 (rpi_shader + 334)
-#define mc_filter_uv_b (rpi_shader + 486)
-#define mc_exit (rpi_shader + 662)
-#define mc_interrupt_exit8 (rpi_shader + 680)
-#define mc_setup (rpi_shader + 710)
-#define mc_filter (rpi_shader + 864)
-#define mc_filter_b (rpi_shader + 1104)
-#define mc_interrupt_exit12 (rpi_shader + 1360)
-#define mc_end (rpi_shader + 1398)
+#define mc_filter_uv (rpi_shader + 130)
+#define mc_filter_uv_b0 (rpi_shader + 312)
+#define mc_filter_uv_b (rpi_shader + 464)
+#define mc_exit (rpi_shader + 640)
+#define mc_interrupt_exit8 (rpi_shader + 658)
+#define mc_setup (rpi_shader + 688)
+#define mc_filter (rpi_shader + 1048)
+#define mc_filter_b (rpi_shader + 1174)
+#define mc_interrupt_exit12 (rpi_shader + 1302)
+#define mc_exit1 (rpi_shader + 1340)
+#define mc_end (rpi_shader + 1356)
 
 #endif
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 38abba2..8e720ed 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -21,6 +21,7 @@
 #
 # ra16                                          clipped(row start address+elem_num)&~3
 # ra17                                          per-channel shifts
+# ra18                                          0x4000
 # ra19                                          next ra17
 #
 # rb16                                          pitch
@@ -86,7 +87,7 @@
 
 
 ################################################################################
-# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
+# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, offset, denom, vpm_id)
 ::mc_setup_uv
 
 # Read starting kernel
@@ -132,36 +133,6 @@ mov ra13, 0
 mov ra14, 0    
 mov ra15, 0
 
-# Compute part of VPM to use for DMA output
-mov r3, unif
-shl r2, r3, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
-and r2, r2, 15
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
-shl r0, r0, 5
-add rb27, r0, r1
-
-# Compute part of VPM to save data into
-shl r2, r3, 1
-and r2, r2, 15    # r2 = bcd0
-mov r1, r2        # r1 = bcd0
-asr r1, r1, 2     # r1 = bc
-shl r1, r1, 6     # r1 = bc000000
-mov r0, r2        # r0 = bcd0
-and r0, r0, 3     # r0 = d0
-add r0, r0, r1    # r0 = bc0000d0
-mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
-add rb28, r0, r1    
-asr r0, r0, 1     # r0 = bc0000d
-# Prepare VPM command for 16bit intermediates
-mov r1, vpm_setup(0, 2, h16p(0, 0))  # 2 is stride - stride acts on ADDR which is Y[5:0],H[0] for 16 bit
-add rb21, r0, r1
-
 # Compute base address for first and second access
 mov r0, ra_x           # Load x
 max r0, r0, 0; mov r1, ra_y # Load y
@@ -175,10 +146,31 @@ min r1, r1, rb_frame_height_minus_1
 # submit texture requests for first line
 add r2, r2, r0 ; mul24 r1, r1, rb_pitch
 add t0s, r0, r1 ; mov ra_frame_base, r2
-add t0s, r2, r1
+add t1s, r2, r1
 
-mov rb12,unif # offset before shift
-mov rb13,unif # offset after shift 
+mov r2,8
+shl rb12,unif, r2 # offset before shift
+add rb13,unif,r2  # offset after shift 
+
+# Compute part of VPM to use for DMA output
+mov r2, unif
+shl r2, r2, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
+and r2, r2, 15
+mov r1, r2
+asr r1, r1, 2
+shl r1, r1, 6
+mov r0, r2
+and r0, r0, 3
+add r0, r0, r1 
+
+mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
+add rb28, r0, r1  # VPM 8bit storage
+asr r2, r0, 1     # r0 = bc0000d
+mov r1, vpm_setup(0, 2, h16p(0, 0))  # 2 is stride - stride acts on ADDR which is Y[5:0],H[0] for 16 bit
+add rb21, r2, r1  # VPM for 16bit intermediates
+mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+shl r0, r0, 5
+add rb27, r0, r1  # DMA out
 
 # submit texture requests for second line
 max r1, ra_y, 0
@@ -187,7 +179,7 @@ add ra_y, ra_y, 1
 bra -, ra31
 nop ; mul24 r1, r1, rb_pitch
 add t0s, r1, ra_x
-add t0s, r1, ra_frame_base
+add t1s, r1, ra_frame_base
 
 
 
@@ -248,17 +240,15 @@ mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 mov r0, unif # U offset/weight
 asr rb15, r0, r2  # Compute offset from MSBs
 shl r0, r0, r2
-asr rb14, r0, r2  # Compute weight from LSBs
+asr r3, r0, r2  # Compute weight from LSBs
 mov r0, unif # V offset/weight
 asr.ifnz rb15, r0, r2
 shl r0, r0, r2
-asr.ifnz rb14, r0, r2 
+asr.ifnz r3, r0, r2 
+shl rb14,r3,8 # Scale up weights so we can use mul24 in signed fashion
 
 # r2 is elem_num
 # r3 is loop counter
-
-mov r5rep, -8 
-
 # retrieve texture results and pick out bytes
 # then submit two more texture requests
 
@@ -269,7 +259,7 @@ mov r3, 0
 # then submit two more texture requests
 
 sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0  
+shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1  
 mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
 mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
 shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
@@ -278,7 +268,7 @@ max r2, ra_y, 0  # y
 min r2, r2, rb_frame_height_minus_1
 add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
 add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-add t0s, ra_frame_base, r2   
+add t1s, ra_frame_base, r2   
 
 # generate seven shifted versions
 # interleave with scroll of vertical context
@@ -300,11 +290,6 @@ brr.anyn -, r:uvloop
 mov ra13, ra14       # Delay slot 1
 mov ra14, ra15       # Delay slot 2
 mov ra15, r0         # Delay slot 3
-
-mov rb12,32 # TODO remove these to make P weighted prediction work properly
-mov rb13,6
-mov rb14,1
-mov rb15,0
  
 # apply vertical filter and write to VPM
 
@@ -412,7 +397,7 @@ mov r3, 0
 # then submit two more texture requests
 
 sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0  
+shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1  
 mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
 mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
 shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
@@ -421,7 +406,7 @@ max r2, ra_y, 0  # y
 min r2, r2, rb_frame_height_minus_1
 add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
 add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-add t0s, ra_frame_base, r2   
+add t1s, ra_frame_base, r2   
 
 # generate seven shifted versions
 # interleave with scroll of vertical context
@@ -542,7 +527,7 @@ mov r3, 0
 # then submit two more texture requests
 
 sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
-shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0  
+shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1  
 mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
 mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
 shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
@@ -551,7 +536,7 @@ max r2, ra_y, 0  # y
 min r2, r2, rb_frame_height_minus_1
 add ra_y, ra_y, 1         ; mul24 r2, r2, r3                     
 add t0s, ra_x, r2    ; v8subs r1, r1, rb20
-add t0s, ra_frame_base, r2   
+add t1s, ra_frame_base, r2   
 
 # generate seven shifted versions
 # interleave with scroll of vertical context
@@ -617,9 +602,9 @@ mov  -, vw_wait # wait on the VDW
 mov -,srel(0)
 
 ldtmu0
+ldtmu1
 ldtmu0
-ldtmu0
-ldtmu0
+ldtmu1
 
 nop        ; nop ; thrend
 nop        ; nop # delay slot 1
@@ -630,9 +615,9 @@ nop        ; nop # delay slot 2
 mov  -, vw_wait # wait on the VDW
 
 ldtmu0
+ldtmu1
 ldtmu0
-ldtmu0
-ldtmu0
+ldtmu1
 
 mov -,sacq(0) # 1 
 mov -,sacq(0) # 2 
@@ -656,200 +641,249 @@ nop        ; nop # delay slot 2
 # For P frames we make the second x,y coordinates offset by +8 
 
 ################################################################################
-# mc_setup(next_kernel, x, y, ref_y_base, x2, y2, ref_y2_base, frame_width, frame_height, pitch, dst_pitch, offset, shift, pad2)
+# mc_setup(y_x, ref_y_base, y2_x2, ref_y2_base, frame_width_height, pitch, dst_pitch, offset_shift, next_kernel)
 ::mc_setup
-
-# Read starting kernel
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-mov ra31, unif
-
-# Compute base address for first and second access
-add r0, unif, elem_num # Load x
-max r0, r0, 0; mov r1, unif # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
-shl ra_xshift_next, r0, 3 # Compute shifts
-add ra_y, r1, 1
-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
-add r2, r2, r0  # r2 is address for frame0 (not including y offset)
-max r1, r1, 0
-min r1, r1, rb_frame_height_minus_1
-nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
-add t0s, r2, r1 ; mov ra_frame_base, r2
-
-add r0, unif, elem_num # Load x
-max r0, r0, 0; mov r1, unif # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
-shl rx_xshift2_next, r0, 3 # Compute shifts
-add ra_y2, r1, 1
-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
-add r2, r2, r0  # r2 is address for frame1 (not including y offset)
-max r1, r1, 0
-min r1, r1, rb_frame_height_minus_1
-nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
-add t0s, r2, r1 ; mov ra_frame_base2, r2
-
-
+  mov r3, 16
+  
+  # Need to save these because we need to know the frame dimensions before computing texture coordinates
+  mov ra8, unif
+  mov ra9, unif
+  mov ra10, unif
+  mov ra11, unif
+  
 # Read image dimensions
-sub rb25,unif,1
-sub rb30,unif,1
-
+  mov r1, unif # width_height
+  shl r0,r1,r3
+  asr r1,r1,r3 # width
+  asr r0,r0,r3 # height
+  sub rb_frame_width_minus_1,r1,1
+  sub rb_frame_height_minus_1,r0,1
+  
 # get source pitch
-mov rb16, unif
+  mov rb_pitch, unif
 
 # get destination pitch
-mov r0, unif
-mov r1, vdw_setup_1(0)
-add rb24, r1, r0
+  mov r0, unif
+  mov r1, vdw_setup_1(0)
+  add rb24, r1, r0
+
+# Compute base address for first and second access  
+  mov r1, ra8 # y_x
+  shl r0,r1,r3 # r0 is x<<16
+  asr r1,r1,r3 # r1 is y
+  asr r0,r0,r3 # r0 is x
+  add r0, r0, elem_num # Load x
+  max r0, r0, 0 
+  min r0, r0, rb_frame_width_minus_1 ; mov r2, ra9  # Load the frame base
+  shl ra_xshift_next, r0, 3 # Compute shifts
+  add ra_y, r1, 1
+  and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+  add r2, r2, r0  # r2 is address for frame0 (not including y offset)
+  max r1, r1, 0
+  min r1, r1, rb_frame_height_minus_1
+  nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
+  add t0s, r2, r1 ; mov ra_frame_base, r2
+
+  mov r1, ra10 # y_x
+  shl r0,r1,r3 # r0 is x<<16
+  asr r1,r1,r3 # r1 is y
+  asr r0,r0,r3 # r0 is x
+  add r0, r0, elem_num # Load x
+  max r0, r0, 0
+  min r0, r0, rb_frame_width_minus_1 ; mov r2, ra11  # Load the frame base
+  shl rx_xshift2_next, r0, 3 # Compute shifts
+  add ra_y2, r1, 1
+  and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+  add r2, r2, r0  # r2 is address for frame1 (not including y offset)
+  max r1, r1, 0
+  min r1, r1, rb_frame_height_minus_1
+  nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
+  add t1s, r2, r1 ; mov ra_frame_base2, r2
+
 
 # load constants
 
-mov ra20, 1
-mov ra22, 256
-mov ra30, 64
+  mov ra20, 1
+  mov ra22, 256
+  mov ra30, 64
 
-mov rb20, 0xffffff00
-mov rb22, 255
-mov rb23, 24
+  mov rb20, 0xffffff00
+  mov rb22, 255
+  mov rb23, 24
 
 # touch vertical context to keep simulator happy
 
-mov ra8, 0
-mov ra9, 0
-mov ra10, 0    
-mov ra11, 0
-mov ra12, 0    
-mov ra13, 0
-mov ra14, 0    
-mov ra15, 0
-
-# Compute part of VPM to use for DMA output
-mov r2, qpu_num
-mov r1, r2
-asr r1, r1, 2
-shl r1, r1, 6
-mov r0, r2
-and r0, r0, 3
-add r0, r0, r1 
-mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
-shl r0, r0, 5
-add rb27, r0, r1
-
-# Compute part of VPM to save data into
-mov r2, qpu_num   # qpu_num = abcd
-mov r1, r2        
-asr r1, r1, 2     
-shl r1, r1, 6     
-mov r0, r2        
-and r0, r0, 3     
-add r0, r0, r1    
-mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
-add rb28, r0, r1  
-
-mov rb12,unif # offset before shift
-mov rb13,unif # shift 
-
-# Dump padding words
-mov r0, unif
+  mov ra8, 0
+  mov ra9, 0
+  mov ra10, 0    
+  mov ra11, 0
+  mov ra12, 0    
+  mov ra13, 0
+  mov ra14, 0    
+  mov ra15, 0
+  mov ra18, 0x4000
+
+# Compute part of VPM to use
+  mov r2, qpu_num
+  mov r1, r2
+  asr r1, r1, 2
+  shl r1, r1, 6
+  mov r0, r2
+  and r0, r0, 3
+  add r0, r0, r1 
+  mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
+  add rb28, r0, r1  # VPM for saving data
+  mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+  shl r0, r0, 5
+  add rb27, r0, r1  # Command for dma output
+
+# Weighted prediction denom
+
+  mov r1, unif # offset_shift
+  shl r0,r1,r3 ; mov r2,8
+  asr rb13,r0,r3 # shift
+  asr rb12,r1,r3 # offset
+  add rb13,rb13,r2    # mul24 is unsigned so scale up into high bits
+  shl rb12, rb12, r2 # Account for larger shift
 
 # submit texture requests for second line
-max r1, ra_y, 0
-min r1, r1, rb_frame_height_minus_1
-add ra_y, ra_y, 1
-nop ; mul24 r1, r1, rb_pitch
-add t0s, r1, ra_frame_base
-
-max r1, ra_y2, 0
-min r1, r1, rb_frame_height_minus_1
-bra -, ra31
-add ra_y2, ra_y2, 1           # Delay 1
-nop ; mul24 r1, r1, rb_pitch  # Delay 2
-add t0s, r1, ra_frame_base2   # Delay 3
-
-
-################################################################################
-
-# mc_filter(next_kernel, x, y, frame_base, x2, y2, frame_base2, height, hcoeffs[0], hcoeffs2[0], hcoeffs[1], hcoeffs2[1], vcoeffs[0], vcoeffs2[0], vcoeffs[1], vcoeffs2[1], offsetweight0, offsetweight1, this_dst)
-# In a P block, only the first half of coefficients contain used information.
-# At this point we have already issued two pairs of texture requests for the current block
-# ra_x, ra_x16_base point to the current coordinates for this block
-::mc_filter
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-mov ra31, unif
+  max r1, ra_y, 0
+  min r1, r1, rb_frame_height_minus_1
+  add ra_y, ra_y, 1
+  nop ; mul24 r1, r1, rb_pitch
+  add t0s, r1, ra_frame_base
+
+  max r1, ra_y2, 0
+  min r1, r1, rb_frame_height_minus_1
+  add ra_y2, ra_y2, 1
+  nop ; mul24 r1, r1, rb_pitch  
+  add t1s, r1, ra_frame_base2  
+  
+# FALL THROUGHT TO PER-BLOCK SETUP
+  
+# Start of per-block setup code
+# P and B blocks share the same setup code to save on Icache space
+:per_block_setup
+  mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+  mov ra31, unif
 
 # per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-mov rx_xshift2, rx_xshift2_next
+  mov ra_xshift, ra_xshift_next 
+  mov rx_xshift2, rx_xshift2_next
 
 # get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num # Load x
-max r0, r0, 0; mov r1, unif # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
-shl ra_xshift_next, r0, 3 # Compute shifts
-mov ra_y_next, r1
-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
-add ra_frame_base_next, r2, r0  # r2 is address for frame0 (not including y offset)
-
-add r0, unif, elem_num # Load x
-max r0, r0, 0   ; mov r1, unif # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
-shl rx_xshift2_next, r0, 3 # Compute shifts
-add ra_y2_next, r1, 1
-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
-add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
+  mov r3, 16
+  mov r1, unif # y_x
+  shl r0,r1,r3 # r0 is x<<16
+  asr r1,r1,r3 # r1 is y
+  asr r0,r0,r3 # r0 is x
+  add r0, r0, elem_num # Load x
+  max r0, r0, 0
+  min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+  shl ra_xshift_next, r0, 3 # Compute shifts
+  mov ra_y_next, r1
+  and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+  add ra_frame_base_next, r2, r0 ; mov r1, unif # y2_x2
+
+  shl r0,r1,r3 # r0 is x2<<16
+  asr r1,r1,r3 # r1 is y2
+  asr r0,r0,r3 # r0 is x2
+  add r0, r0, elem_num # Load x
+  max r0, r0, 0
+  min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+  shl rx_xshift2_next, r0, 3 # Compute shifts
+  mov ra_y2_next, r1
+  and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+  add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
  
-
 # set up VPM write
-mov vw_setup, rb28
+  mov vw_setup, rb28
 
 # get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
-shl r0, r0, 7
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
+  mov r0, unif
+  shr r1, r0, r3 # Extract width
+  sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+  and r0, r0, rb22 # Extract height
+  add rb17, r0, 5
+  add rb18, r0, 7
+  shl r0, r0, 7
+  add r0, r0, r1 # Combine width and height of destination area
+  shl r0, r0, r3 # Shift into bits 16 upwards of the vdw_setup0 register
+  add rb26, r0, rb27
 
 # get filter coefficients and discard unused B frame values
-mov r0, unif
-mov.ifnz -, unif # Alternate coefficients are unused for P frames
-asr ra3, r0, rb23;      mul24 r0, r0, ra22 # These may need some pre-rotation to be used in B frames correctly
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-mov.ifnz -, unif
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-asr ra4, r0, rb23;      mov r0, unif
-mov.ifnz -, unif
-asr rb11, r0, rb23;     mul24 r0, r0, ra22
-asr rb10, r0, rb23;     mul24 r0, r0, ra22
-asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-mov.ifnz -, unif
-asr rb7, r0, rb23;      mul24 r0, r0, ra22
-asr rb6, r0, rb23;      mul24 r0, r0, ra22
-asr rb5, r0, rb23;      mul24 r0, r0, ra22
-asr rb4, r0, rb23
-
-mov r0, unif # Frame0 offset/weight
-mov.ifnz -, unif # Frame1 offset/weight unused
-asr rb15, r0, r2  # Compute offset from MSBs
-shl r0, r0, r2
-asr rb14, r0, r2  # Compute weight from LSBs
-
-# r3 is loop counter
-
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
+  mov r0, unif ; mov r1,1  # Packed filter offsets, unpack into ra8... (to be used for vertical context later)
+  asr ra9, r0, rb23;      mul24 r0, r0, ra22 # my2
+  asr ra8, r0, rb23;      mul24 r0, r0, ra22 # mx2
+  asr.ifz ra9, r0, rb23;  mul24 r0, r0, ra22 # my:my2
+  asr.ifz ra8, r0, rb23                      # mx:mx2
+  sub ra9,3,ra9
+  sub ra8,3,ra8
+  shl ra9,ra9,3   # Scale up by 8   
+  shl ra8,ra8,3   # Scale up by 8
+# Now if we want aligned we have a mul of 1, so put 0 coefficients at the top
+  mov r1,0xffff00
+  shl r0, r1, ra8
+  asr ra0, r0, rb23   
+  shl r0, r1, ra9 
+  asr rb4, r0, rb23
+  
+  mov r1,0x1040400
+  shl r0, r1, ra8
+  asr ra1, r0, rb23   
+  shl r0, r1, ra9 
+  asr rb5, r0, rb23  
+  
+  mov r1,0xfbf5f600   
+  shl r0, r1, ra8
+  asr ra2, r0, rb23   
+  shl r0, r1, ra9 
+  asr rb6, r0, rb23  
+  
+  mov r1,0x11283a40   
+  shl r0, r1, ra8
+  asr ra3, r0, rb23   
+  shl r0, r1, ra9 
+  asr rb7, r0, rb23   
+  
+  mov r1,0x3a281100   
+  shl r0, r1, ra8
+  asr ra4, r0, rb23  
+  shl r0, r1, ra9 
+  asr rb8, r0, rb23   
+    
+  mov r1,0xf6f5fb00   
+  shl r0, r1, ra8
+  asr ra5, r0, rb23  
+  shl r0, r1, ra9 
+  asr rb9, r0, rb23   
+    
+  mov r1,0x4040100    
+  shl r0, r1, ra8
+  asr ra6, r0, rb23  
+  shl r0, r1, ra9 
+  asr rb10, r0, rb23  
+    
+  mov r1,0xffff0000   
+  shl r0, r1, ra8
+  asr ra7, r0, rb23   
+  shl r0, r1, ra9 
+  asr rb11, r0, rb23
+
+# Extract weighted prediction information
+  mov r0, unif      # offset/weight  TODO move up
+  asr rb15, r0, r3  # Compute offset from MSBs                                   
+  bra -, ra31
+  shl r0, r0, r3    #                                                            Delay 1
+  asr r0, r0, r3 ; mov r3, 0 # Compute weight from LSBs and reset loop counter   Delay 2
+  shl rb14, r0, 8 # Use a larger shift to avoid unsigned multiply problem        Delay 3
+  
+################################################################################
+# mc_filter(y_x, frame_base, y2_x2, frame_base2, width_height, my2_mx2_my_mx, offsetweight0, this_dst, next_kernel)
+# In a P block, y2_x2 should be y_x+8
+# At this point we have already issued two pairs of texture requests for the current block
 
-mov r3, 0
+::mc_filter
 
 :yloop
 # retrieve texture results and pick out bytes
@@ -858,91 +892,90 @@ mov r3, 0
 # If we knew there was no clipping then this code would get simpler.
 # Perhaps we could add on the pitch and clip using larger values?
 
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
-shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0  
-mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, rx_xshift2       
-mov.ifz ra_y2, ra_y2_next
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1            ; mul24 r2, r2, r3                     
-add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
-
-max r2, ra_y2, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3                     
-add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+  sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+  shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu1  
+  mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+  mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+  shr r1, r4, rx_xshift2       
+  mov.ifz ra_y2, ra_y2_next
+
+  max r2, ra_y, 0  # y
+  min r2, r2, rb_frame_height_minus_1
+  add ra_y, ra_y, 1            ; mul24 r2, r2, r3                     
+  add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
+
+  max r2, ra_y2, 0  # y
+  min r2, r2, rb_frame_height_minus_1
+  add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3                     
+  add t1s, ra_frame_base2, r2   ; v8subs r1, r1, rb20
   
-
 # generate seven shifted versions
 # interleave with scroll of vertical context
 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+  mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 
 # apply horizontal filter         
-nop                  ; mul24 r2, r0, ra0
-nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-nop                  ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-add r0, r2, r3       ; mov r3, rb31
-sub.setf -, r3, 8    ; mov ra12, ra13
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-brr.anyn -, r:yloop
-mov ra13, ra14       # Delay slot 1
-mov ra14, ra15       # Delay slot 2
-mov ra15, r0         # Delay slot 3
+  nop                  ; mul24 r2, r0, ra0
+  nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+  nop                  ; mul24      r3, ra1 << 1, r0 << 1
+  nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+  add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+  nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+  add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+  nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+  add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+  nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+  add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+  nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+  add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+  nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+  add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+  nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+  add r0, r2, r3       ; mov r3, rb31
+  sub.setf -, r3, 8    ; mov ra8, ra9
+  mov ra9, ra10
+  mov ra10, ra11       
+  mov ra11, ra12
+  mov ra12, ra13
+  brr.anyn -, r:yloop
+  mov ra13, ra14       # Delay slot 1
+  mov ra14, ra15       # Delay slot 2
+  mov ra15, r0         # Delay slot 3
  
 # apply vertical filter and write to VPM
 
-nop                     ; mul24 r1, ra14, rb10
-nop                     ; mul24 r0, ra13, rb9
-add r1, r1, r0          ; mul24 r0, ra12, rb8
-add r1, r1, r0          ; mul24 r0, ra15, rb11
-add r1, r1, r0          ; mul24 r0, ra8, rb4
-add r1, r1, r0          ; mul24 r0, ra9, rb5
-add r1, r1, r0          ; mul24 r0, ra10, rb6
-add r1, r1, r0          ; mul24 r0, ra11, rb7
-
-add r1, r1, r0          ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 14
-nop                     ; mul24 r1, r1, rb14
-add r1, r1, rb12
-asr r1, r1, rb13
-brr.anyn -, r:yloop 
-add r1, r1, rb15       # Delay 1
-min r1, r1, rb22       # Delay 2
-max vpm, r1, 0         # Delay 3
+  nop                     ; mul24 r1, ra14, rb10
+  nop                     ; mul24 r0, ra13, rb9
+  add r1, r1, r0          ; mul24 r0, ra12, rb8
+  add r1, r1, r0          ; mul24 r0, ra15, rb11
+  add r1, r1, r0          ; mul24 r0, ra8, rb4
+  add r1, r1, r0          ; mul24 r0, ra9, rb5
+  add r1, r1, r0          ; mul24 r0, ra10, rb6
+  add r1, r1, r0          ; mul24 r0, ra11, rb7
+
+  add r1, r1, r0          ; mov -, vw_wait
+  sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+  asr r1, r1, 14
+  nop                     ; mul24 r1, r1, rb14
+  add r1, r1, rb12
+  asr r1, r1, rb13
+  brr.anyn -, r:yloop 
+  add r1, r1, rb15       # Delay 1
+  min r1, r1, rb22       # Delay 2
+  max vpm, r1, 0         # Delay 3
 
 # DMA out
 
-bra -, ra31
-mov vw_setup, rb26 # VDW setup 0    Delay 1
-mov vw_setup, rb29 # Stride         Delay 2
-mov vw_addr, unif # start the VDW   Delay 3
+  brr -, r:per_block_setup
+  mov vw_setup, rb26 # VDW setup 0    Delay 1
+  mov vw_setup, rb29 # Stride         Delay 2
+  mov vw_addr, unif # start the VDW   Delay 3
 
 
 
 ################################################################################
 
-# mc_filter_b(next_kernel, x, y, frame_base, x2, y2, frame_base2, width_height, hcoeffs[0], hcoeffs2[0], hcoeffs[1], hcoeffs2[1], vcoeffs[0], vcoeffs2[0], vcoeffs[1], vcoeffs2[1], offsetweight0, offsetweight1, this_dst)
+# mc_filter_b(y_x, frame_base, y2_x2, frame_base2, width_height, my2_mx2_my_mx, offsetweight0, this_dst, next_kernel)
 # In a P block, only the first half of coefficients contain used information.
 # At this point we have already issued two pairs of texture requests for the current block
 # May be better to just send 16.16 motion vector and figure out the coefficients inside this block (only 4 cases so can compute hcoeffs in around 24 cycles?)
@@ -952,92 +985,6 @@ mov vw_addr, unif # start the VDW   Delay 3
 # Or possibly by taking advantage of symmetry?
 # From 19->7 32bits per command.
 ::mc_filter_b
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
-mov ra31, unif
-
-# per-channel shifts were calculated on the *previous* invocation
-
-mov ra_xshift, ra_xshift_next
-mov rx_xshift2, rx_xshift2_next
-
-# get base addresses and per-channel shifts for *next* invocation
-add r0, unif, elem_num # Load x
-max r0, r0, 0; mov r1, unif # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
-shl ra_xshift_next, r0, 3 # Compute shifts
-mov ra_y_next, r1
-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
-add ra_frame_base_next, r2, r0  # r2 is address for frame0 (not including y offset)
-
-add r0, unif, elem_num # Load x
-max r0, r0, 0   ; mov r1, unif # Load y
-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
-shl rx_xshift2_next, r0, 3 # Compute shifts
-add ra_y2_next, r1, 1
-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
-add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
- 
-
-# set up VPM write
-mov vw_setup, rb28
-
-# get width,height of block
-mov r2, 16
-mov r0, unif
-shr r1, r0, r2 # Extract width
-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
-and r0, r0, rb22 # Extract height
-add rb17, r0, 5
-add rb18, r0, 7
-shl r0, r0, 7
-add r0, r0, r1 # Combine width and height of destination area
-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
-add rb26, r0, rb27
-
-# get filter coefficients and discard unused B frame values
-mov r0, unif
-mov r1, 1
-mov.ifnz r0, unif # Alternate coefficients are unused for P frames
-nop              ;      mul24 r0, r0 << 13, r1 << 13
-asr ra3, r0, rb23;      mul24 r0, r0, ra22 
-nop              ;      mul24 r0, r0 << 14, r1 << 14
-asr ra2, r0, rb23;      mul24 r0, r0, ra22
-nop              ;      mul24 r0, r0 << 15, r1 << 15 # Adjust such that a rotate of 1 will produce the values with first 8 on left, second 8 on right
-asr ra1, r0, rb23;      mul24 r0, r0, ra22
-asr ra0, r0, rb23;      mov r0, unif
-mov.ifnz r0, unif
-nop              ;      mul24 r0, r0 << 9, r1 << 9
-asr ra7, r0, rb23;      mul24 r0, r0, ra22
-nop              ;      mul24 r0, r0 << 10, r1 << 10
-asr ra6, r0, rb23;      mul24 r0, r0, ra22
-nop              ;      mul24 r0, r0 << 11, r1 << 11
-asr ra5, r0, rb23;      mul24 r0, r0, ra22
-nop              ;      mul24 r0, r0 << 12, r1 << 12
-asr ra4, r0, rb23;      mov r0, unif
-mov.ifnz r0, unif
-asr rb11, r0, rb23;     mul24 r0, r0, ra22
-asr rb10, r0, rb23;     mul24 r0, r0, ra22
-asr rb9, r0, rb23;      mul24 r0, r0, ra22
-asr rb8, r0, rb23;      mov r0, unif
-mov.ifnz r0, unif
-asr rb7, r0, rb23;      mul24 r0, r0, ra22
-asr rb6, r0, rb23;      mul24 r0, r0, ra22
-asr rb5, r0, rb23;      mul24 r0, r0, ra22
-asr rb4, r0, rb23
-
-mov r0, unif # Frame0 offset/weight
-mov.ifnz r0, unif # Frame1 offset/weight unused
-asr rb15, r0, r2  # Compute offset from MSBs
-shl r0, r0, r2
-asr rb14, r0, r2  # Compute weight from LSBs
-
-# r3 is loop counter
-
-# retrieve texture results and pick out bytes
-# then submit two more texture requests
-
-mov r3, 0
-
 :yloopb
 # retrieve texture results and pick out bytes
 # then submit two more texture requests
@@ -1045,112 +992,124 @@ mov r3, 0
 # If we knew there was no clipping then this code would get simpler.
 # Perhaps we could add on the pitch and clip using larger values?
 
-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
-shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0  
-mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
-shr r1, r4, rx_xshift2       
-mov.ifz ra_y2, ra_y2_next
-
-max r2, ra_y, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y, ra_y, 1            ; mul24 r2, r2, r3                     
-add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
-
-max r2, ra_y2, 0  # y
-min r2, r2, rb_frame_height_minus_1
-add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3                     
-add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+  sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+  shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu1  
+  mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+  mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch   
+  shr r1, r4, rx_xshift2       
+  mov.ifz ra_y2, ra_y2_next
+
+  max r2, ra_y, 0  # y
+  min r2, r2, rb_frame_height_minus_1
+  add ra_y, ra_y, 1            ; mul24 r2, r2, r3                     
+  add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
+
+  max r2, ra_y2, 0  # y
+  min r2, r2, rb_frame_height_minus_1
+  add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3                     
+  add t1s, ra_frame_base2, r2   ; v8subs r1, r1, rb20
   
-
 # generate seven shifted versions
 # interleave with scroll of vertical context
 
-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+  mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
 
 # apply horizontal filter         
-nop                  ; mul24 r2, r0, ra0
-nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
-nop                  ; mul24      r3, ra1 << 1, r0 << 1
-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
-add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
-add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
-add r0, r2, r3       ; mov r3, rb31
-sub.setf -, r3, 8    ; mov ra12, ra13
-mov ra9, ra10
-mov ra10, ra11
-mov ra11, ra12
-mov ra12, ra13
-brr.anyn -, r:yloopb
-mov ra13, ra14       # Delay slot 1
-mov ra14, ra15       # Delay slot 2
-mov ra15, r0         # Delay slot 3
- 
-# apply vertical filter and write to VPM
-
-nop                     ; mul24 r1, ra14, rb10
-nop                     ; mul24 r0, ra13, rb9
-add r1, r1, r0          ; mul24 r0, ra12, rb8
-add r1, r1, r0          ; mul24 r0, ra15, rb11
-add r1, r1, r0          ; mul24 r0, ra8, rb4
-add r1, r1, r0          ; mul24 r0, ra9, rb5
-add r1, r1, r0          ; mul24 r0, ra10, rb6
-add r1, r1, r0          ; mul24 r0, ra11, rb7
-
-add r1, r1, r0          ; mov -, vw_wait
-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
-asr r1, r1, 14           
-nop                     ; mul24 r1, r1 << 8, ra20 << 8 # Rotate to align left and right halves
-add r1, r1, ra30        ; mul24 r0, r1, rb14
-add r1, r1, r0
-brr.anyn -, r:yloopb 
-asr r1, r1, 7          # Delay 1
-min r1, r1, rb22       # Delay 2
-max vpm, r1, 0         # Delay 3
+  nop                  ; mul24 r2, r0, ra0
+  nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+  nop                  ; mul24      r3, ra1 << 1, r0 << 1
+  nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+  add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+  nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+  add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+  nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+  add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+  nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+  add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+  nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+  add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+  nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+  add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+  nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+  add r0, r2, r3       ; mov r3, rb31
+  sub.setf -, r3, 8    ; mov ra8, ra9
+  mov ra9, ra10  
+  mov ra10, ra11
+  mov ra11, ra12
+  mov ra12, ra13
+  brr.anyn -, r:yloopb
+  mov ra13, ra14       # Delay slot 1
+  mov ra14, ra15       # Delay slot 2
+  mov ra15, r0         # Delay slot 3
+   
+  # apply vertical filter and write to VPM
+
+  nop                     ; mul24 r1, ra14, rb10
+  nop                     ; mul24 r0, ra13, rb9
+  add r1, r1, r0          ; mul24 r0, ra12, rb8
+  add r1, r1, r0          ; mul24 r0, ra15, rb11
+  add r1, r1, r0          ; mul24 r0, ra8, rb4
+  add r1, r1, r0          ; mul24 r0, ra9, rb5
+  add r1, r1, r0          ; mul24 r0, ra10, rb6
+  add r1, r1, r0          ; mul24 r0, ra11, rb7
+
+  add r1, r1, r0          ; mov -, vw_wait
+  sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+  asr r0, r1, 14 
+  asr r1, r1, 6           # Wait state so we can use the rotate instruction  
+  nop                     ; mul24 r0, r0 << 8, ra22 << 8 # Rotate to align left and right halves
+  add r1, r1, ra18
+  add r1, r1, r0
+  brr.anyn -, r:yloopb 
+  asr r1, r1, 15         # Delay 1
+  min r1, r1, rb22       # Delay 2
+  max vpm, r1, 0         # Delay 3
 
 # DMA out
-bra -, ra31
-mov vw_setup, rb26 # VDW setup 0    Delay 1
-mov vw_setup, rb29 # Stride         Delay 2
-mov vw_addr, unif # start the VDW   Delay 3
+  brr -, r:per_block_setup
+  mov vw_setup, rb26 # VDW setup 0    Delay 1
+  mov vw_setup, rb29 # Stride         Delay 2
+  mov vw_addr, unif # start the VDW   Delay 3
 
 ################################################################################
 
 # mc_interrupt_exit12()
 ::mc_interrupt_exit12 
-mov  -, vw_wait # wait on the VDW
-
-ldtmu0
-ldtmu0
-ldtmu0
-ldtmu0
-
-mov -,sacq(0) # 1 
-mov -,sacq(0) # 2 
-mov -,sacq(0) # 3 
-mov -,sacq(0) # 4 
-mov -,sacq(0) # 5 
-mov -,sacq(0) # 6 
-mov -,sacq(0) # 7 
-mov -,sacq(0) # 8 
-mov -,sacq(0) # 9 
-mov -,sacq(0) # 10 
-mov -,sacq(0) # 11 
-
-nop        ; nop ; thrend
-mov interrupt, 1; nop # delay slot 1
-nop        ; nop # delay slot 2
-
+  mov  -, vw_wait # wait on the VDW
+
+  ldtmu0
+  ldtmu0
+  ldtmu1
+  ldtmu1
+
+  mov -,sacq(0) # 1 
+  mov -,sacq(0) # 2 
+  mov -,sacq(0) # 3 
+  mov -,sacq(0) # 4 
+  mov -,sacq(0) # 5 
+  mov -,sacq(0) # 6 
+  mov -,sacq(0) # 7 
+  mov -,sacq(0) # 8 
+  mov -,sacq(0) # 9 
+  mov -,sacq(0) # 10 
+  mov -,sacq(0) # 11 
+
+  nop        ; nop ; thrend
+  mov interrupt, 1; nop # delay slot 1
+  nop        ; nop # delay slot 2
 
+  
+::mc_exit1
+  mov  -, vw_wait # wait on the VDW
+
+  ldtmu0
+  ldtmu1
+  ldtmu0
+  ldtmu1
+  nop        ; nop ; thrend
+  mov interrupt, 1; nop # delay slot 1
+  nop        ; nop # delay slot 2
+  
+  
 ::mc_end
 # Do not add code here because mc_end must appear after all other code.
-- 
1.9.1


From 76ae1ec2d554c92e25861647ef5da2beaa6a1dd0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 28 May 2015 15:47:31 +0100
Subject: [PATCH 58/77] hack: allocate larger buffer to avoid heap corruption

---
 libavcodec/utils.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libavcodec/utils.c b/libavcodec/utils.c
index 58fd4f5..bea1635 100644
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -535,6 +535,7 @@ static AVBufferRef *rpi_buffer_alloc(int size)
     if (!p)
         return NULL;
         
+    size *= 2;
     if (gpu_malloc_cached(size,p)<0)  // Change this line to choose cached or uncached memory.  The caching here refers to the ARM data cache.
         return NULL;
 
-- 
1.9.1


From e1bd32beef9048f228a8aa3fe3324a5f6509b72b Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 2 Jun 2015 13:41:02 +0100
Subject: [PATCH 59/77] Revert "hack: allocate larger buffer to avoid heap
 corruption"

This reverts commit f06543fd30c83c18a2de794de3ccf9cc5191f379.
---
 libavcodec/utils.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/libavcodec/utils.c b/libavcodec/utils.c
index bea1635..58fd4f5 100644
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -535,7 +535,6 @@ static AVBufferRef *rpi_buffer_alloc(int size)
     if (!p)
         return NULL;
         
-    size *= 2;
     if (gpu_malloc_cached(size,p)<0)  // Change this line to choose cached or uncached memory.  The caching here refers to the ARM data cache.
         return NULL;
 
-- 
1.9.1


From 3301317b1a3c6d5ede6fae76b7bd81eef464ba69 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 2 Jun 2015 10:58:25 +0100
Subject: [PATCH 60/77] Added option to simulate QPUs

---
 libavcodec/hevc.c          | 288 +++++++++++++++++++++++++++++++++++++++++++--
 libavcodec/rpi_qpu.c       |  24 ++--
 libavcodec/rpi_shader.qasm |   6 +-
 libavcodec/utils.c         |   2 +-
 4 files changed, 296 insertions(+), 24 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index c3feb6a..5872640 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -54,6 +54,8 @@
   // Define RPI_CACHE_UNIF_MVS to write motion vector uniform stream to cached memory
   // RPI_CACHE_UNIF_MVS doesn't seem to make much difference, so left undefined.
   
+  // Define RPI_SIMULATE_QPUS for debugging to run QPU code on the ARMs
+  //#define RPI_SIMULATE_QPUS
   
 #endif
 
@@ -122,7 +124,6 @@ static void pic_arrays_free(HEVCContext *s)
 
 #ifdef EARLY_MALLOC
 #else
-    printf("pic_arrays_free\n");
     if (s->coeffs_buf_arm[0]) {
       gpu_free(&s->coeffs_buf_default);
       s->coeffs_buf_arm[0] = 0;
@@ -172,11 +173,9 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
 #ifdef RPI
 #ifdef EARLY_MALLOC
 #else
-    assert(sps);
+    av_assert0(sps);
     int coeffs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
     int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
-    printf("pic_arrays_init\n");
-    printf("Allocated %d\n",coefs_per_row);
     gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
     s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
     if (!s->coeffs_buf_arm[0])
@@ -2952,6 +2951,274 @@ static void rpi_inter_clear(HEVCContext *s)
 #endif
 }
 
+
+#ifdef RPI_SIMULATE_QPUS
+
+static int32_t clipx(int x,int FRAME_WIDTH) 
+{
+	if (x<=0) return 0;
+	if (x>=FRAME_WIDTH) return FRAME_WIDTH-1;
+	return x;
+}
+
+static int32_t clipy(int y,int FRAME_HEIGHT) 
+{
+	if (y<=0) return 0;
+	if (y>=FRAME_HEIGHT) return FRAME_HEIGHT-1;
+	return y;
+}
+
+/*static int32_t filter8(uint8_t *data, int x0, int y0, int pitch, int mx, int my,int round,int denom,int weight,int offset)
+{
+   int32_t vsum = 0;
+   int x, y;
+
+   for (y = 0; y < 8; y++) {
+      int32_t hsum = 0;
+
+      for (x = 0; x < 8; x++)
+         hsum += lumaFilter[mx][x]*data[clipx(x + x0) + clipy(y + y0) * pitch];
+
+      vsum += lumaFilter[my][y]*hsum;
+   }
+   vsum >>= 6;
+   vsum = (((vsum*weight)+round)>>denom)+offset;
+
+   return av_clip_uint8( vsum );
+}*/
+
+static int32_t filter8_chroma(uint8_t *data, int x0, int y0, int pitch, int hcoeffs, int vcoeffs,int offset_weight,int offset_before,int denom,int pic_width, int pic_height)
+{
+  int32_t vsum = 0;
+  int x, y;
+  int chromaFilterH[4];
+  int chromaFilterV[4];
+  int i;
+  int offset_after = offset_weight>>16;
+  int weight = (offset_weight<<16)>>16;
+  for(i=0;i<4;i++) {
+    chromaFilterH[i] = ((hcoeffs>>(8*i))<<24)>>24;
+    chromaFilterV[i] = ((vcoeffs>>(8*i))<<24)>>24;
+  }
+
+   for (y = 0; y < 4; y++) {
+      int32_t hsum = 0;
+
+      for (x = 0; x < 4; x++)
+         hsum += chromaFilterH[x]*data[clipx(x + x0,pic_width) + clipy(y + y0,pic_height) * pitch];
+
+      vsum += chromaFilterV[y]*hsum;
+   }
+   vsum >>= 6;
+   vsum = (((vsum*weight)+offset_before)>>denom)+offset_after;
+
+   return vsum;
+}
+
+int lumaFilter[4][8]={ {0,0,0,64,0,0,0,0},{-1,4,-10,58,17,-5,1,0},{-1,4,-11,40,40,-11,4,-1},{0,1,-5,17,58,-10,4,-1} };
+
+static int32_t filter8_luma(uint8_t *data, int x0, int y0, int pitch, int my_mx,int offset_weight,int offset_before,int denom,int pic_width, int pic_height)
+{
+  int32_t vsum = 0;
+  int x, y;
+  int i;
+  int offset_after = offset_weight>>16;
+  int weight = (offset_weight<<16)>>16;
+
+   for (y = 0; y < 8; y++) {
+      int32_t hsum = 0;
+
+      for (x = 0; x < 8; x++)
+         hsum += lumaFilter[my_mx&3][x]*data[clipx(x + x0,pic_width) + clipy(y + y0,pic_height) * pitch];
+
+      vsum += lumaFilter[(my_mx>>8)&3][y]*hsum;
+   }
+   vsum >>= 6;
+   vsum = (((vsum*weight)+offset_before)>>denom)+offset_after;
+
+   return vsum;
+}
+
+static uint8_t *test_frame(HEVCContext *s,uint32_t p, AVFrame *frame, int cIdx)
+{
+  //int pic_width        = s->sps->width >> s->sps->hshift[cIdx];
+  int pic_height       = s->sps->height >> s->sps->vshift[cIdx];
+  int pitch = frame->linesize[cIdx];
+  uint32_t base = get_vc_address(frame->buf[cIdx]);
+  if (p>=base && p<base+pitch*pic_height) {
+    return frame->data[cIdx] + (p-base);
+  }
+  return NULL;
+}
+
+static uint8_t *compute_arm_addr(HEVCContext *s,uint32_t p, int cIdx)
+{
+  SliceHeader *sh   = &s->sh;
+  uint8_t *arm = test_frame(s,p,s->frame,cIdx);
+  int i;
+  if (arm) return arm;
+  if (sh->slice_type == P_SLICE || sh->slice_type == B_SLICE)
+  {
+    for(i=0;i<sh->nb_refs[L0];i++) {
+      arm = test_frame(s,p,s->ref->refPicList[0].ref[i]->frame,cIdx);
+      if (arm) return arm;
+    }
+  }
+  if (sh->slice_type == B_SLICE) {
+    for(i=0;i<sh->nb_refs[L1];i++) {
+      arm = test_frame(s,p,s->ref->refPicList[1].ref[i]->frame,cIdx);
+      if (arm) return arm;
+    }
+  }
+  printf("Frame 0x%x not found! Exit=%x\n",p,qpu_get_fn(QPU_MC_EXIT));
+  exit(-1);
+  return NULL;
+}
+
+static void rpi_simulate_inter_chroma(HEVCContext *s,uint32_t *p)
+{
+  uint32_t next_kernel;
+  uint32_t x0;
+  uint32_t y0;
+  uint8_t *ref_u_base;
+  uint8_t *ref_v_base;
+  uint32_t frame_width = p[5];
+  uint32_t frame_height = p[6];
+  uint32_t pitch = p[7];
+  uint32_t dst_pitch = p[8];
+  int32_t offset_before = p[9];
+  int32_t denom = p[10];
+  uint32_t vpm_id = p[11];
+  uint32_t tmp_u_dst[256];
+  uint32_t tmp_v_dst[256];
+  while(1) {
+    p += 12;
+    next_kernel = p[0-12];
+    x0 = p[1-12];
+    y0 = p[2-12];
+    if (next_kernel==s->mc_filter_uv || next_kernel==s->mc_filter_uv_b0 || next_kernel==s->mc_filter_uv_b) {
+      int x,y;
+      uint32_t width_height = p[5];
+      uint32_t hcoeffs = p[6];
+      uint32_t vcoeffs = p[7];
+      uint32_t offset_weight_u = p[8];
+      uint32_t offset_weight_v = p[9];
+      uint8_t *this_u_dst;
+      uint8_t *this_v_dst;
+      uint32_t width = width_height >> 16;
+      uint32_t height = (width_height << 16) >> 16;
+      ref_u_base = compute_arm_addr(s,p[3-12],1);
+      ref_v_base = compute_arm_addr(s,p[4-12],2);
+      if (next_kernel!=s->mc_filter_uv_b0)
+      {
+        this_u_dst = compute_arm_addr(s,p[10],1);
+        this_v_dst = compute_arm_addr(s,p[11],2);
+      }
+      for (y=0; y<height; ++y) {
+        for (x=0; x<width; ++x) {
+          if (next_kernel==s->mc_filter_uv) {
+            int32_t refa = filter8_chroma(ref_u_base,x+x0, y+y0, pitch, hcoeffs, vcoeffs, offset_weight_u,offset_before,denom,frame_width,frame_height);
+            int32_t refb = filter8_chroma(ref_v_base,x+x0, y+y0, pitch, hcoeffs, vcoeffs, offset_weight_v,offset_before,denom,frame_width,frame_height);
+            this_u_dst[x+y*dst_pitch] = av_clip_uint8(refa);
+            this_v_dst[x+y*dst_pitch] = av_clip_uint8(refb);
+          } else if (next_kernel==s->mc_filter_uv_b0) {
+            int32_t refa = filter8_chroma(ref_u_base, x+x0, y+y0, pitch, hcoeffs, vcoeffs, 1,0,0,frame_width,frame_height);
+            int32_t refb = filter8_chroma(ref_v_base, x+x0, y+y0, pitch, hcoeffs, vcoeffs, 1,0,0,frame_width,frame_height);
+            tmp_u_dst[x+y*16] = refa;
+            tmp_v_dst[x+y*16] = refb;
+          } else {
+            int32_t refa = filter8_chroma(ref_u_base, x+x0, y+y0, pitch, hcoeffs, vcoeffs, 1, 64 + tmp_u_dst[x+y*16], 7, frame_width, frame_height);
+            int32_t refb = filter8_chroma(ref_v_base, x+x0, y+y0, pitch, hcoeffs, vcoeffs, 1, 64 + tmp_v_dst[x+y*16], 7, frame_width, frame_height);
+            this_u_dst[x+y*dst_pitch] = av_clip_uint8(refa);
+            this_v_dst[x+y*dst_pitch] = av_clip_uint8(refb);
+          }
+        }
+      }
+    } else {
+      av_assert0(next_kernel==qpu_get_fn(QPU_MC_INTERRUPT_EXIT8) || next_kernel==qpu_get_fn(QPU_MC_EXIT) );
+      break;
+    }
+  }
+}
+
+// mc_setup(y_x, ref_y_base, y2_x2, ref_y2_base, frame_width_height, pitch, dst_pitch, offset_shift, next_kernel)
+static void rpi_simulate_inter_luma(HEVCContext *s,uint32_t *p)
+{
+  uint32_t next_kernel;
+  int y_x,y2_x2;
+  uint32_t x0;
+  uint32_t y0;
+  uint32_t x2;
+  uint32_t y2;
+  uint8_t *ref_y_base;
+  uint8_t *ref_y2_base;
+  uint32_t frame_width_height = p[4];
+  uint32_t frame_width = frame_width_height>>16;
+  uint32_t frame_height = (frame_width_height<<16)>>16;
+  uint32_t pitch = p[5];
+  uint32_t dst_pitch = p[6];
+  int offset_shift = p[7];
+  int32_t offset_before = offset_shift>>16;
+  int32_t denom = (offset_shift<<16)>>16;
+  while(1) {
+    p += 9;
+    next_kernel = p[8-9];
+    y_x = p[0-9];
+    x0 = (y_x<<16)>>16;
+    y0 = y_x>>16;
+    y2_x2 = p[2-9];
+    x2 = (y2_x2<<16)>>16;
+    y2 = y2_x2>>16;
+    
+    if (next_kernel==s->mc_filter || next_kernel==s->mc_filter_b) {
+      // y_x, frame_base, y2_x2, frame_base2, width_height, my2_mx2_my_mx, offsetweight0, this_dst, next_kernel)
+      int x,y;
+      uint32_t width_height = p[4];
+      uint32_t my2_mx2_my_mx = p[5];
+      uint32_t offset_weight = p[6];
+      uint8_t *this_dst = compute_arm_addr(s,p[7],0);
+      uint32_t width = width_height >> 16;
+      uint32_t height = (width_height << 16) >> 16;
+      ref_y_base = compute_arm_addr(s,p[1-9],0);
+      ref_y2_base = compute_arm_addr(s,p[3-9],0);
+      for (y=0; y<height; ++y) {
+        for (x=0; x<width; ++x) {
+          if (next_kernel==s->mc_filter) {
+            int32_t refa = filter8_luma(ref_y_base,x+x0, y+y0, pitch, my2_mx2_my_mx, offset_weight,offset_before,denom,frame_width,frame_height);
+            this_dst[x+y*dst_pitch] = av_clip_uint8(refa);
+          } 
+          else {
+            int32_t refa = filter8_luma(ref_y_base, x+x0, y+y0, pitch, my2_mx2_my_mx, 1, 0, 0, frame_width, frame_height);
+            int32_t refb = filter8_luma(ref_y2_base, x+x2, y+y2, pitch, my2_mx2_my_mx>>16, 1, 64 + refa, 7, frame_width, frame_height);
+            this_dst[x+y*dst_pitch] = av_clip_uint8(refb);
+          }
+        }
+      }
+    } else {
+      av_assert0(next_kernel==qpu_get_fn(QPU_MC_INTERRUPT_EXIT12) || next_kernel==qpu_get_fn(QPU_MC_EXIT) );
+      break;
+    }
+  }
+}
+
+static void rpi_simulate_inter_qpu(HEVCContext *s)
+{
+  // First run the transform as normal
+  int i;
+  rpi_execute_transform(s);
+  for(i=0;i<8;i++)
+  {
+    rpi_simulate_inter_chroma(s,s->mvs_base[i]);
+  }
+  for(i=0;i<12;i++)
+  {
+    rpi_simulate_inter_luma(s,s->y_mvs_base[i]);
+  }
+}
+
+#endif
+
+
 static void rpi_execute_inter_qpu(HEVCContext *s)
 {
     int k;
@@ -2970,7 +3237,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for V        
-        assert(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
+        av_assert0(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
     }
              
     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
@@ -2980,11 +3247,16 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
         s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+1] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
         s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for second request        
         s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
-        assert(s->y_mvs[k] - s->y_mvs_base[k] < Y_COMMANDS_PER_QPU);
+        av_assert0(s->y_mvs[k] - s->y_mvs_base[k] < Y_COMMANDS_PER_QPU);
     }
     s->y_mvs[12-1][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT12); // This QPU will signal interrupt when all others are done and have acquired a semaphore
 #endif
 
+#ifdef RPI_SIMULATE_QPUS
+    rpi_simulate_inter_qpu(s);
+    s->vpu_id = -1;
+    return;
+#endif
 
 #ifdef RPI_MULTI_MAILBOX
 #ifdef RPI_CACHE_UNIF_MVS
@@ -3063,7 +3335,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
                     && s->pps->num_tile_rows <= 1 && s->pps->num_tile_columns <= 1;
 #endif                    
                     
-    /*if (!s->enable_rpi) {
+    if (!s->enable_rpi) {
       if (s->pps->cross_component_prediction_enabled_flag)
         printf("Cross component\n");
       if (s->pps->num_tile_rows > 1 || s->pps->num_tile_columns > 1)
@@ -3072,7 +3344,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
         printf("Weighted P slice\n");
       if (s->pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
         printf("Weighted B slice\n");
-    }*/
+    }
                     
 #endif
 
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index f8aca57..37381ca 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -12,7 +12,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stddef.h>
-#include <assert.h>
+#include "libavutil/avassert.h"
 
 #include <pthread.h>
 #include <time.h>
@@ -157,13 +157,13 @@ static int gpu_init(volatile struct GPU **gpu) {
   // Now copy over the QPU code into GPU memory
   {
     int num_bytes = qpu_get_fn(QPU_MC_END) - qpu_get_fn(QPU_MC_SETUP_UV);
-    assert(num_bytes<=QPU_CODE_SIZE*sizeof(unsigned int));
+    av_assert0(num_bytes<=QPU_CODE_SIZE*sizeof(unsigned int));
     memcpy((void*)ptr->qpu_code, rpi_shader, num_bytes);
   }
   // And the VPU code
   {
     int num_bytes = sizeof(rpi_hevc_transform);
-    assert(num_bytes<=VPU_CODE_SIZE*sizeof(unsigned int));
+    av_assert0(num_bytes<=VPU_CODE_SIZE*sizeof(unsigned int));
     memcpy((void*)ptr->vpu_code, rpi_hevc_transform, num_bytes);
   }
   // And the transform coefficients
@@ -213,13 +213,13 @@ static void gpu_unlock(void) {
 static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb) {
   p->numbytes = numbytes;
   p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
-  assert(p->vcsm_handle);
+  av_assert0(p->vcsm_handle);
   p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
-  assert(p->vc_handle);
+  av_assert0(p->vc_handle);
   p->arm = vcsm_lock(p->vcsm_handle);  
-  assert(p->arm);
+  av_assert0(p->arm);
   p->vc = mem_lock(mb, p->vc_handle);
-  assert(p->vc);
+  av_assert0(p->vc);
   return 0;
 }
 
@@ -240,7 +240,7 @@ int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p)
 
 int gpu_get_mailbox(void)
 {
-  assert(gpu);
+  av_assert0(gpu);
   return gpu->mb;
 }
 
@@ -294,13 +294,13 @@ static int gpu_malloc_cached_internal(int numbytes, GPU_MEM_PTR_T *p) {
   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" ); 
   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST_AND_VC, (char *)"Video Frame" );
-  assert(p->vcsm_handle);
+  av_assert0(p->vcsm_handle);
   p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
-  assert(p->vc_handle);
+  av_assert0(p->vc_handle);
   p->arm = vcsm_lock(p->vcsm_handle);  
-  assert(p->arm);
+  av_assert0(p->arm);
   p->vc = mem_lock(gpu->mb, p->vc_handle);
-  assert(p->vc);
+  av_assert0(p->vc);
   return 0;
 }
 
diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
index 8e720ed..0ec1dac 100644
--- a/libavcodec/rpi_shader.qasm
+++ b/libavcodec/rpi_shader.qasm
@@ -149,8 +149,8 @@ add t0s, r0, r1 ; mov ra_frame_base, r2
 add t1s, r2, r1
 
 mov r2,8
-shl rb12,unif, r2 # offset before shift
-add rb13,unif,r2  # offset after shift 
+shl rb12,unif,r2 # offset before shift
+add rb13,unif,r2  # denominator
 
 # Compute part of VPM to use for DMA output
 mov r2, unif
@@ -185,7 +185,7 @@ add t1s, r1, ra_frame_base
 
 ################################################################################
 
-# mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
+# mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, width_height, hcoeffs, vcoeffs, offset_weight_u, offset_weight_v, this_u_dst, this_v_dst)
 
 # At this point we have already issued two pairs of texture requests for the current block
 # ra_x, ra_x16_base point to the current coordinates for this block
diff --git a/libavcodec/utils.c b/libavcodec/utils.c
index 58fd4f5..628661a 100644
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -539,7 +539,7 @@ static AVBufferRef *rpi_buffer_alloc(int size)
         return NULL;
 
     data = p->arm;
-    //printf("Rpi alloc %d/%d ARM=%p VC=%x\n",size,total,p->arm,p->vc);
+    printf("Rpi alloc %d/%d ARM=%p VC=%x->%x\n",size,total,p->arm,p->vc,p->vc+size);
     //memset(data, 64, size);
     
     if (!data)
-- 
1.9.1


From d9602ed224edf85e6b620349762b939ca8b07534 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 2 Jun 2015 13:17:50 +0100
Subject: [PATCH 61/77] Increased motion vector memory and fixed block size
 computation for non-multiple of 2 block sizes

---
 libavcodec/hevc.c | 52 ++++++++++++++++++++++++++++++++--------------------
 1 file changed, 32 insertions(+), 20 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 5872640..b0f11fb 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -81,11 +81,9 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 
 // Split image of 2048 into parts 64 wide
 // So some QPUs will have 3 blocks of 64 to do, and others 2 blocks for an image 2048 wide with 32 blocks across
-// Each block of 64*64
-// Smallest CTU size is 16x16, so smallest block is 8x8
-// Corresponds to a total of 83kbytes over all 12 QPUs
+// For each block of 64*64 the smallest block size is 8x4
 #define RPI_LUMA_COMMAND_WORDS 9
-#define Y_COMMANDS_PER_QPU ((1+3*(64*64)/(8*8)) * RPI_LUMA_COMMAND_WORDS)
+#define Y_COMMANDS_PER_QPU ((1+3*(64*64)/(8*4)) * RPI_LUMA_COMMAND_WORDS)
 
 #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
 
@@ -1947,7 +1945,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
     int i, j;
 
     int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);
-
+    
     if (!skip_flag)
         lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);
 
@@ -2006,11 +2004,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             uint32_t *y = s->y_mvs[chan % 12];      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=16) {
+                  int bw = nPbW-start_x;
+                  int bh = nPbH-start_y;
                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
-                  *y++ = ( (nPbW<16 ? nPbW : 16) << 16 ) + (nPbH<16 ? nPbH : 16);
+                  *y++ = ( (bw<16 ? bw : 16) << 16 ) + (bh<16 ? bh : 16);
                   *y++ = my2_mx2_my_mx;
                   if (weight_flag) {
                       *y++ = (s->sh.luma_offset_l0[current_mv.ref_idx[reflist]] << 16) + (s->sh.luma_weight_l0[current_mv.ref_idx[reflist]] & 0xffff);
@@ -2053,12 +2053,14 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 uint32_t *u = s->u_mvs[chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                      int bw = nPbW_c-start_x;
+                      int bh = nPbH_c-start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
-                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                      *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
                       *u++ = rpi_filter_coefs[_mx][0];
                       *u++ = rpi_filter_coefs[_my][0];
                       if (weight_flag) {
@@ -2105,11 +2107,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             uint32_t *y = s->y_mvs[chan % 12];      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=16) {
+                  int bw = nPbW-start_x;
+                  int bh = nPbH-start_y;
                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
-                  *y++ = ( (nPbW<16 ? nPbW : 16) << 16 ) + (nPbH<16 ? nPbH : 16);
+                  *y++ = ( (bw<16 ? bw : 16) << 16 ) + (bh<16 ? bh : 16);
                   *y++ = my2_mx2_my_mx;
                   if (weight_flag) {
                       *y++ = (s->sh.luma_offset_l0[current_mv.ref_idx[reflist]] << 16) + (s->sh.luma_weight_l0[current_mv.ref_idx[reflist]] & 0xffff);
@@ -2153,12 +2157,14 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 uint32_t *u = s->u_mvs[chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                      int bw = nPbW_c-start_x;
+                      int bh = nPbH_c-start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
-                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                      *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
                       *u++ = rpi_filter_coefs[_mx][0];
                       *u++ = rpi_filter_coefs[_my][0];
@@ -2210,11 +2216,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             uint32_t *y = s->y_mvs[chan % 12];      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=8) { // B blocks work 8 at a time
+                  int bw = nPbW-start_x;
+                  int bh = nPbH-start_y;
                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y2 - 3 + start_y) << 16) + ( (x2 - 3 + start_x) & 0xffff); // Second fetch is for ref1
                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
-                  *y++ = ( (nPbW<8 ? nPbW : 8) << 16 ) + (nPbH<16 ? nPbH : 16);
+                  *y++ = ( (bw<8 ? bw : 8) << 16 ) + (bh<16 ? bh : 16);
                   *y++ = my2_mx2_my_mx;
                   *y++ = 1; // B frame weighted prediction not supported
                   *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
@@ -2257,12 +2265,14 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 uint32_t *u = s->u_mvs[chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                      int bw = nPbW_c-start_x;
+                      int bh = nPbH_c-start_y; 
                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b0;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);  
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
-                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                      *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
                       *u++ = rpi_filter_coefs[_mx][0];
                       *u++ = rpi_filter_coefs[_my][0];
                       u+=2; // Weights not supported in B slices
@@ -2273,7 +2283,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 1 + start_y;
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
-                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                      *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
                       *u++ = rpi_filter_coefs[_mx2][0];
                       *u++ = rpi_filter_coefs[_my2][0];
                       u+=2; // Weights not supported in B slices
@@ -3142,14 +3152,15 @@ static void rpi_simulate_inter_chroma(HEVCContext *s,uint32_t *p)
 }
 
 // mc_setup(y_x, ref_y_base, y2_x2, ref_y2_base, frame_width_height, pitch, dst_pitch, offset_shift, next_kernel)
-static void rpi_simulate_inter_luma(HEVCContext *s,uint32_t *p)
+static void rpi_simulate_inter_luma(HEVCContext *s,uint32_t *p,int chan)
 {
   uint32_t next_kernel;
   int y_x,y2_x2;
-  uint32_t x0;
-  uint32_t y0;
-  uint32_t x2;
-  uint32_t y2;
+  int x0;
+  int y0;
+  int x2;
+  int y2;
+  uint32_t *p0 = p;
   uint8_t *ref_y_base;
   uint8_t *ref_y2_base;
   uint32_t frame_width_height = p[4];
@@ -3179,13 +3190,15 @@ static void rpi_simulate_inter_luma(HEVCContext *s,uint32_t *p)
       uint8_t *this_dst = compute_arm_addr(s,p[7],0);
       uint32_t width = width_height >> 16;
       uint32_t height = (width_height << 16) >> 16;
+      uint8_t *dst_base = s->frame->data[0];
       ref_y_base = compute_arm_addr(s,p[1-9],0);
       ref_y2_base = compute_arm_addr(s,p[3-9],0);
       for (y=0; y<height; ++y) {
         for (x=0; x<width; ++x) {
           if (next_kernel==s->mc_filter) {
             int32_t refa = filter8_luma(ref_y_base,x+x0, y+y0, pitch, my2_mx2_my_mx, offset_weight,offset_before,denom,frame_width,frame_height);
-            this_dst[x+y*dst_pitch] = av_clip_uint8(refa);
+            refa = av_clip_uint8(refa);
+            this_dst[x+y*dst_pitch] = refa;
           } 
           else {
             int32_t refa = filter8_luma(ref_y_base, x+x0, y+y0, pitch, my2_mx2_my_mx, 1, 0, 0, frame_width, frame_height);
@@ -3212,7 +3225,7 @@ static void rpi_simulate_inter_qpu(HEVCContext *s)
   }
   for(i=0;i<12;i++)
   {
-    rpi_simulate_inter_luma(s,s->y_mvs_base[i]);
+    rpi_simulate_inter_luma(s,s->y_mvs_base[i],i);
   }
 }
 
@@ -3254,7 +3267,6 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
 
 #ifdef RPI_SIMULATE_QPUS
     rpi_simulate_inter_qpu(s);
-    s->vpu_id = -1;
     return;
 #endif
 
-- 
1.9.1


From d63f1fe479f7e97700925737a54f0be8294dc42a Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 2 Jun 2015 14:36:54 +0100
Subject: [PATCH 62/77] Added support for skip deblock

---
 libavcodec/hevc.c        | 10 ++++++++++
 libavcodec/hevc.h        |  2 ++
 libavcodec/hevc_filter.c | 16 +++++-----------
 3 files changed, 17 insertions(+), 11 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index b0f11fb..f40d9aa 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -3359,6 +3359,11 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     }
                     
 #endif
+    s->used_for_ref = !(s->nal_unit_type == NAL_TRAIL_N ||
+                        s->nal_unit_type == NAL_TSA_N   ||
+                        s->nal_unit_type == NAL_STSA_N  ||
+                        s->nal_unit_type == NAL_RADL_N  ||
+                        s->nal_unit_type == NAL_RASL_N); 
 
     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
         av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n");
@@ -3499,6 +3504,11 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
 
 #ifdef RPI
     s->enable_rpi = 0;
+    s->used_for_ref = !(s->nal_unit_type == NAL_TRAIL_N ||
+                        s->nal_unit_type == NAL_TSA_N   ||
+                        s->nal_unit_type == NAL_STSA_N  ||
+                        s->nal_unit_type == NAL_RADL_N  ||
+                        s->nal_unit_type == NAL_RASL_N); 
     //printf("Wavefront\n");
 #endif
 
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index e3414b7..09eb4c9 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -885,6 +885,8 @@ typedef struct HEVCContext {
 
     int                 width;
     int                 height;
+    
+    int used_for_ref;
 
 #ifdef RPI
     int enable_rpi;
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 979ad61..528afac 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -511,16 +511,14 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
                 s->sps->pcm.loop_filter_disable_flag) ||
                s->pps->transquant_bypass_enable_flag;
 #ifdef DISABLE_DEBLOCK_NONREF    
-    if (    s->nal_unit_type == NAL_TRAIL_N ||
-            s->nal_unit_type == NAL_TSA_N   ||
-            s->nal_unit_type == NAL_STSA_N  ||
-            s->nal_unit_type == NAL_RADL_N  ||
-            s->nal_unit_type == NAL_RASL_N )
+    if (!s->used_for_ref)
       return; // Don't deblock non-reference frames
 #endif
 #ifdef DISABLE_DEBLOCK
     return;
-#endif               
+#endif
+    if (!s->used_for_ref && s->avctx->skip_loop_filter >= AVDISCARD_NONREF)
+        return;
 
     if (x0) {
         left_tc_offset   = s->deblock[ctb - 1].tc_offset;
@@ -884,11 +882,7 @@ static int ff_hevc_buf_base(AVBufferRef *bref) {
 
 void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
 {
-    if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
-            s->nal_unit_type == NAL_TSA_N   ||
-            s->nal_unit_type == NAL_STSA_N  ||
-            s->nal_unit_type == NAL_RADL_N  ||
-            s->nal_unit_type == NAL_RASL_N )) {  
+    if (s->enable_rpi && s->used_for_ref) {
 #ifdef RPI_FAST_CACHEFLUSH
         struct vcsm_user_clean_invalid_s iocache = {};
         int curr_y = ((int *)f->progress->data)[0];
-- 
1.9.1


From 574548653cee24db699bc0a5e46bc5b021fb5d3c Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Tue, 2 Jun 2015 15:22:52 +0100
Subject: [PATCH 63/77] Added support for skip_frame

---
 libavcodec/hevc.c | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index f40d9aa..2cb4e82 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -3359,11 +3359,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     }
                     
 #endif
-    s->used_for_ref = !(s->nal_unit_type == NAL_TRAIL_N ||
-                        s->nal_unit_type == NAL_TSA_N   ||
-                        s->nal_unit_type == NAL_STSA_N  ||
-                        s->nal_unit_type == NAL_RADL_N  ||
-                        s->nal_unit_type == NAL_RASL_N); 
 
     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
         av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n");
@@ -3845,7 +3840,17 @@ static int decode_nal_unit(HEVCContext *s, const HEVCNAL *nal)
         ret = hls_slice_header(s);
         if (ret < 0)
             return ret;
-
+       
+        s->used_for_ref = !(s->nal_unit_type == NAL_TRAIL_N ||
+                        s->nal_unit_type == NAL_TSA_N   ||
+                        s->nal_unit_type == NAL_STSA_N  ||
+                        s->nal_unit_type == NAL_RADL_N  ||
+                        s->nal_unit_type == NAL_RASL_N);     
+                        
+        if (!s->used_for_ref && s->avctx->skip_frame >= AVDISCARD_NONREF) {
+            s->is_decoded = 0;
+            break;
+        }
         if (s->max_ra == INT_MAX) {
             if (s->nal_unit_type == NAL_CRA_NUT || IS_BLA(s)) {
                 s->max_ra = s->poc;
-- 
1.9.1


From 5a027872618f2446a7d5d1543f596e4a3937bd74 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 3 Jun 2015 09:15:38 +0100
Subject: [PATCH 64/77] Fixed cache flushing of luma when using old method

---
 libavcodec/hevc_filter.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 528afac..ec1953b 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -918,7 +918,7 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
         flush_buffer(s->frame->buf[1]);
         flush_buffer(s->frame->buf[2]);
 #ifdef RPI_LUMA_QPU
-        flush_buffer(s->frame->buf[1]);
+        flush_buffer(s->frame->buf[0]);
 #endif
 
 #endif
-- 
1.9.1


From b7a8190e1b83c856f8acd3640525e1ded53d9f98 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 3 Jun 2015 11:37:27 +0100
Subject: [PATCH 65/77] Option to parallelise coefficient decode and inter
 prediction and deblock for each frame

---
 libavcodec/hevc.c              | 703 +++++++++++++++++++++++++++--------------
 libavcodec/hevc.h              |  76 +++--
 libavcodec/hevc_cabac.c        |  12 +-
 libavcodec/hevcpred_template.c |   5 +-
 4 files changed, 524 insertions(+), 272 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 2cb4e82..ab9f56c 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -41,8 +41,6 @@
 
 #ifdef RPI
   #include "rpi_qpu.h"
-  // For some unknown reason, the code seems to crash if I do a late malloc
-  //#define EARLY_MALLOC
   // Move Inter prediction into separate pass
   #define RPI_INTER
   
@@ -56,6 +54,21 @@
   
   // Define RPI_SIMULATE_QPUS for debugging to run QPU code on the ARMs
   //#define RPI_SIMULATE_QPUS
+  #ifdef RPI_WORKER
+    #include "pthread.h"
+  #endif
+  
+  static void rpi_execute_dblk_cmds(HEVCContext *s);
+  static void rpi_execute_transform(HEVCContext *s);
+  static void rpi_execute_inter_qpu(HEVCContext *s);
+  static void rpi_execute_pred_cmds(HEVCContext *s);
+  static void rpi_execute_inter_cmds(HEVCContext *s);
+  static void rpi_inter_clear(HEVCContext *s);
+  
+  // Define INTER_PASS0 to do inter prediction in first pass
+  //#define INTER_PASS0
+  // Define LAUNCH_PASS0 to launch QPU/VPU from pass0
+  //#define LAUNCH_PASS0
   
 #endif
 
@@ -103,6 +116,143 @@ static uint32_t get_vc_address(AVBufferRef *bref) {
   GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
   return p->vc;
 }
+#endif
+
+
+#ifdef RPI_WORKER
+
+//#define LOG_ENTER printf("Enter %s: p0=%d p1=%d (%d jobs) %p\n", __func__,s->pass0_job,s->pass1_job,s->worker_tail-s->worker_head,s);
+//#define LOG_EXIT printf("Exit %s: p0=%d p1=%d (%d jobs) %p\n", __func__,s->pass0_job,s->pass1_job,s->worker_tail-s->worker_head,s);
+
+#define LOG_ENTER
+#define LOG_EXIT
+
+// Call this when we have completed pass0 and wish to trigger pass1 for the current job
+static void worker_submit_job(HEVCContext *s)
+{
+  LOG_ENTER
+  //pthread_mutex_lock(&s->worker_mutex);
+  s->worker_tail++; // This is the only place that can change tail so we do not need the mutex
+  s->pass0_job = (s->pass0_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+  pthread_cond_broadcast(&s->worker_cond_tail); // Let people know that the tail has moved
+  //pthread_mutex_unlock(&s->worker_mutex);
+  LOG_EXIT
+}
+
+// Call this to say we have completed pass1
+static void worker_complete_middle_job(HEVCContext *s)
+{
+  LOG_ENTER
+  //pthread_mutex_lock(&s->worker_mutex);
+  s->worker_middle++; // This is the only place that can change head so we do not need the mutex
+  s->pass1_job = (s->pass1_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+  pthread_cond_broadcast(&s->worker_cond_middle); // Let people know that the tail has moved
+  //pthread_mutex_unlock(&s->worker_mutex);
+  LOG_EXIT
+}
+
+// Call this to say we have completed pass2
+static void worker_complete_job(HEVCContext *s)
+{
+  LOG_ENTER
+  //pthread_mutex_lock(&s->worker_mutex);
+  s->worker_head++; // This is the only place that can change head so we do not need the mutex
+  s->pass2_job = (s->pass2_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+  pthread_cond_broadcast(&s->worker_cond_head); // Let people know that the tail has moved
+  //pthread_mutex_unlock(&s->worker_mutex);
+  LOG_EXIT
+}
+
+// Call this to wait for all jobs to have completed at the end of a frame
+static void worker_wait(HEVCContext *s)
+{
+  LOG_ENTER
+  pthread_mutex_lock(&s->worker_mutex);
+  while( s->worker_head !=s->worker_tail)
+  {
+    pthread_cond_wait(&s->worker_cond_head, &s->worker_mutex);
+  }
+  pthread_mutex_unlock(&s->worker_mutex);
+  LOG_EXIT
+}
+
+// Call worker_pass0_ready to wait until the s->pass0_job slot becomes
+// available to receive the next job.
+static void worker_pass0_ready(HEVCContext *s)
+{
+  LOG_ENTER
+    pthread_mutex_lock(&s->worker_mutex);
+    // tail is number of submitted jobs
+    // head is number of completed jobs
+    // tail-head is number of outstanding jobs in the queue
+    // we need to ensure there is at least 1 space left for us to use
+    while( s->worker_tail - s->worker_head >= RPI_MAX_JOBS)
+    {
+      // Wait until another job is completed
+      pthread_cond_wait(&s->worker_cond_head, &s->worker_mutex);
+    }
+    pthread_mutex_unlock(&s->worker_mutex);
+  LOG_EXIT
+}
+
+static void *worker_start(void *arg)
+{
+  HEVCContext *s = (HEVCContext *)arg;
+  while(1) {
+    pthread_mutex_lock(&s->worker_mutex);
+
+    while( !s->kill_worker && s->worker_tail - s->worker_middle <= 0)
+    {
+      pthread_cond_wait(&s->worker_cond_tail, &s->worker_mutex);
+    }
+    pthread_mutex_unlock(&s->worker_mutex);
+    
+    if (s->kill_worker) {
+      break;
+    }
+    LOG_ENTER
+    // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+#ifndef LAUNCH_PASS0   
+    rpi_execute_inter_qpu(s);
+#endif
+#ifndef INTER_PASS0
+    // Perform inter prediction
+    rpi_execute_inter_cmds(s);
+#endif
+    // Wait for transform completion
+    vpu_wait(s->vpu_id);
+    
+    worker_complete_middle_job(s);
+    LOG_EXIT
+  }
+  return NULL;
+}
+
+static void *worker_deblock_start(void *arg)
+{
+  HEVCContext *s = (HEVCContext *)arg;
+  while(1) {
+    pthread_mutex_lock(&s->worker_mutex);
+    while( !s->kill_worker && s->worker_middle - s->worker_head <= 0)
+    {
+      pthread_cond_wait(&s->worker_cond_middle, &s->worker_mutex);
+    }
+    pthread_mutex_unlock(&s->worker_mutex);
+    
+    if (s->kill_worker) {
+      break;
+    }
+    LOG_ENTER
+    // Perform intra prediction and residual reconstruction
+    rpi_execute_pred_cmds(s);
+    // Perform deblocking for CTBs in this row
+    rpi_execute_dblk_cmds(s);
+    
+    worker_complete_job(s);
+    LOG_EXIT
+  }
+  return NULL;
+}
 
 #endif
 
@@ -119,19 +269,18 @@ static uint32_t get_vc_address(AVBufferRef *bref) {
 static void pic_arrays_free(HEVCContext *s)
 {
 #ifdef RPI
-
-#ifdef EARLY_MALLOC
-#else
-    if (s->coeffs_buf_arm[0]) {
-      gpu_free(&s->coeffs_buf_default);
-      s->coeffs_buf_arm[0] = 0;
-    }
-    if (s->coeffs_buf_arm[2]) {
-      gpu_free(&s->coeffs_buf_accelerated);
-      s->coeffs_buf_arm[2] = 0;
+    int job;
+    for(job=0;job<RPI_MAX_JOBS;job++) {
+      if (s->coeffs_buf_arm[job][0]) {
+        gpu_free(&s->coeffs_buf_default[job]);
+        s->coeffs_buf_arm[job][0] = 0;
+      }
+      if (s->coeffs_buf_arm[job][2]) {
+        gpu_free(&s->coeffs_buf_accelerated[job]);
+        s->coeffs_buf_arm[job][2] = 0;
+      }
     }
 #endif
-#endif
     av_freep(&s->sao);
     av_freep(&s->deblock);
 
@@ -169,24 +318,26 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
     int min_pu_size      = sps->min_pu_width * sps->min_pu_height;
     
 #ifdef RPI
-#ifdef EARLY_MALLOC
-#else
     av_assert0(sps);
     int coeffs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
     int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
-    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
-    s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
-    if (!s->coeffs_buf_arm[0])
-        goto fail;
-    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
-    s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
-    s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
-    if (!s->coeffs_buf_arm[2])
-        goto fail;    
-    s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
-    s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
-    printf("Done\n");
-#endif
+    int job;
+    for(job=0;job<RPI_MAX_JOBS;job++) {
+      printf("Allocated %d\n",coefs_per_row);
+      for(job=0;job<RPI_MAX_JOBS;job++) {
+        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default[job]);
+        s->coeffs_buf_arm[job][0] = (int16_t*) s->coeffs_buf_default[job].arm;
+        if (!s->coeffs_buf_arm[job][0])
+            goto fail;
+        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated[job]);
+        s->coeffs_buf_arm[job][2] = (int16_t*) s->coeffs_buf_accelerated[job].arm;
+        s->coeffs_buf_vc[job][2] = s->coeffs_buf_accelerated[job].vc;
+        if (!s->coeffs_buf_arm[job][2])
+            goto fail;    
+        s->coeffs_buf_arm[job][3] = coefs_per_row + s->coeffs_buf_arm[job][2];
+        s->coeffs_buf_vc[job][3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[job][2];
+      }
+    }
 #endif
 
     s->bs_width  = (width  >> 2) + 1;
@@ -1000,7 +1151,7 @@ static void rpi_intra_pred(HEVCContext *s, int log2_trafo_size, int x0, int y0,
 {
     if (s->enable_rpi) {
         HEVCLocalContext *lc = s->HEVClc;
-        HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
+        HEVCPredCmd *cmd = s->univ_pred_cmds[s->pass0_job] + s->num_pred_cmds[s->pass0_job]++;
         cmd->type = RPI_PRED_INTRA;
         cmd->size = log2_trafo_size;
         cmd->c_idx = c_idx;
@@ -1460,7 +1611,7 @@ static void rpi_luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
                         AVFrame *ref, const Mv *mv, int x_off, int y_off,
                         int block_w, int block_h, int luma_weight, int luma_offset)
 {
-    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
+    HEVCMvCmd *cmd = s->unif_mv_cmds[s->pass0_job] + s->num_mv_cmds[s->pass0_job]++;
     cmd->cmd = RPI_CMD_LUMA_UNI;
     cmd->dst = dst;
     cmd->dststride = dststride;
@@ -1479,7 +1630,7 @@ static void rpi_luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
                        AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
                        int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)                      
 {  
-    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
+    HEVCMvCmd *cmd = s->unif_mv_cmds[s->pass0_job] + s->num_mv_cmds[s->pass0_job]++;
     cmd->cmd = RPI_CMD_LUMA_BI;
     cmd->dst = dst;
     cmd->dststride = dststride;
@@ -1501,7 +1652,7 @@ static void rpi_chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
                           ptrdiff_t dststride, uint8_t *src0, ptrdiff_t srcstride, int reflist,
                           int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int chroma_weight, int chroma_offset)
 {
-    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
+    HEVCMvCmd *cmd = s->unif_mv_cmds[s->pass0_job] + s->num_mv_cmds[s->pass0_job]++;
     cmd->cmd = RPI_CMD_CHROMA_UNI;
     cmd->dst = dst0;
     cmd->dststride = dststride;
@@ -1519,7 +1670,7 @@ static void rpi_chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
 static void rpi_chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
                          int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int cidx)
 {
-    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
+    HEVCMvCmd *cmd = s->unif_mv_cmds[s->pass0_job] + s->num_mv_cmds[s->pass0_job]++;
     cmd->cmd = RPI_CMD_CHROMA_BI+cidx;
     cmd->dst = dst0;
     cmd->dststride = dststride;
@@ -2001,7 +2152,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             int chan = x0>>6; // 64 wide blocks per QPU
             int weight_flag = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                               (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);    
-            uint32_t *y = s->y_mvs[chan % 12];      
+            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=16) {
                   int bw = nPbW-start_x;
@@ -2021,7 +2172,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
                 }
             }
-            s->y_mvs[chan % 12] = y;
+            s->y_mvs[s->pass0_job][chan % 12] = y;
         } else 
 #endif
         {
@@ -2050,7 +2201,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                                        (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
                 
-                uint32_t *u = s->u_mvs[chan & 7];      
+                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       int bw = nPbW_c-start_x;
@@ -2074,7 +2225,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
                 }
-                s->u_mvs[chan & 7] = u;
+                s->u_mvs[s->pass0_job][chan & 7] = u;
                 return;
             }
 #endif
@@ -2104,7 +2255,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             int chan = x0>>6; // 64 wide blocks per QPU
             int weight_flag = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                               (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);    
-            uint32_t *y = s->y_mvs[chan % 12];      
+            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=16) {
                   int bw = nPbW-start_x;
@@ -2124,7 +2275,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
                 }
             }
-            s->y_mvs[chan % 12] = y;
+            s->y_mvs[s->pass0_job][chan % 12] = y;
         } else 
 #endif
 
@@ -2154,7 +2305,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                                        (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
                 
-                uint32_t *u = s->u_mvs[chan & 7];      
+                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       int bw = nPbW_c-start_x;
@@ -2179,7 +2330,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
                 }
-                s->u_mvs[chan & 7] = u;
+                s->u_mvs[s->pass0_job][chan & 7] = u;
                 return;
             }
 #endif
@@ -2213,7 +2364,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             int x2 = x0 + (mv2->x >> 2);
             int y2 = y0 + (mv2->y >> 2);
             int chan = x0>>6; // 64 wide blocks per QPU
-            uint32_t *y = s->y_mvs[chan % 12];      
+            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=8) { // B blocks work 8 at a time
                   int bw = nPbW-start_x;
@@ -2229,7 +2380,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter_b;
                 }
             }
-            s->y_mvs[chan % 12] = y;
+            s->y_mvs[s->pass0_job][chan % 12] = y;
         } else 
 #endif
         {
@@ -2262,7 +2413,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 
                 int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
 
-                uint32_t *u = s->u_mvs[chan & 7];      
+                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       int bw = nPbW_c-start_x;
@@ -2291,7 +2442,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
                 }
-                s->u_mvs[chan & 7] = u;
+                s->u_mvs[s->pass0_job][chan & 7] = u;
                 return;
             }
 #endif
@@ -2796,40 +2947,54 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
 static void rpi_execute_dblk_cmds(HEVCContext *s)
 {
     int n;
+    int job = s->pass2_job;
     int ctb_size    = 1 << s->sps->log2_ctb_size;
-    int (*p)[2] = s->dblk_cmds;
-    for(n = s->num_dblk_cmds; n>0 ;n--,p++) {
+    int (*p)[2] = s->dblk_cmds[job];
+    for(n = s->num_dblk_cmds[job]; n>0 ;n--,p++) {
         ff_hevc_hls_filters(s, (*p)[0], (*p)[1], ctb_size);
     }
-    s->num_dblk_cmds = 0;
+    s->num_dblk_cmds[job] = 0;
 }        
             
 static void rpi_execute_transform(HEVCContext *s)
 {
     int i=2;
+#ifdef LAUNCH_PASS0
+    int job = s->pass0_job;
+#else    
+    int job = s->pass1_job;
+#endif    
     //int j;
     //int16_t *coeffs = s->coeffs_buf_arm[i];
     //for(j=s->num_coeffs[i]; j > 0; j-= 16*16, coeffs+=16*16) {
     //    s->hevcdsp.idct[4-2](coeffs, 16);
     //}
     
-    gpu_cache_flush(&s->coeffs_buf_accelerated);
-    s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0, &s->coeffs_buf_accelerated);
+    gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
+    s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], 
+                               s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], 
+                               s->num_coeffs[job][3] >> 10, 0, &s->coeffs_buf_accelerated[job]);
     //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
     //gpu_cache_flush(&s->coeffs_buf_accelerated);
     //vpu_wait(s->vpu_id);
     
     for(i=0;i<4;i++)
-        s->num_coeffs[i] = 0;
+        s->num_coeffs[job][i] = 0;
 }
 
 static void rpi_execute_pred_cmds(HEVCContext *s)
 {
   int i;
-  HEVCPredCmd *cmd = s->univ_pred_cmds;
+  int job = s->pass2_job;
+  HEVCPredCmd *cmd = s->univ_pred_cmds[job];
+#ifdef RPI_WORKER
+  HEVCLocalContextIntra *lc = &s->HEVClcIntra;
+#else
   HEVCLocalContext *lc = s->HEVClc;
+#endif
 
-  for(i = s->num_pred_cmds; i > 0; i--, cmd++) {
+  for(i = s->num_pred_cmds[job]; i > 0; i--, cmd++) {
+      //printf("i=%d cmd=%p job1=%d job0=%d\n",i,cmd,s->pass1_job,s->pass0_job);
       if (cmd->type == RPI_PRED_INTRA) {
           lc->tu.intra_pred_mode_c = lc->tu.intra_pred_mode = cmd->mode;
           lc->na.cand_bottom_left  = (cmd->na >> 4) & 1;
@@ -2848,21 +3013,26 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
 #endif
       }
   }
-  s->num_pred_cmds = 0;
+  s->num_pred_cmds[job] = 0;
 }
 
 static void rpi_execute_inter_cmds(HEVCContext *s)
 {
-    HEVCMvCmd *cmd = s->unif_mv_cmds;
+#ifdef INTER_PASS0
+    int job = s->pass0_job;
+#else
+    int job = s->pass1_job;
+#endif    
+    HEVCMvCmd *cmd = s->unif_mv_cmds[job];
     int n,cidx;
     AVFrame myref;
     AVFrame myref1;
     struct MvField mymv;
-    if (s->num_mv_cmds > RPI_MAX_MV_CMDS) { 
+    if (s->num_mv_cmds[job] > RPI_MAX_MV_CMDS) { 
         printf("Overflow inter_cmds\n");
         exit(-1);
     }
-    for(n = s->num_mv_cmds; n>0 ; n--, cmd++) {
+    for(n = s->num_mv_cmds[job]; n>0 ; n--, cmd++) {
         switch(cmd->cmd) {
         case RPI_CMD_LUMA_UNI:
             myref.data[0] = cmd->src;
@@ -2902,7 +3072,28 @@ static void rpi_execute_inter_cmds(HEVCContext *s)
             break; 
         }
     }
-    s->num_mv_cmds = 0;
+    s->num_mv_cmds[job] = 0;
+}
+
+static void rpi_do_all_passes(HEVCContext *s)
+{
+#ifdef RPI_INTER_QPU
+    // Kick off inter prediction on QPUs
+    rpi_execute_inter_qpu(s);
+#else
+    rpi_execute_transform(s);
+#endif            
+    // Perform luma inter prediction
+    rpi_execute_inter_cmds(s);              
+    // Wait for transform completion
+    vpu_wait(s->vpu_id);          
+    // Perform intra prediction and residual reconstruction
+    rpi_execute_pred_cmds(s);
+    // Perform deblocking for CTBs in this row
+    rpi_execute_dblk_cmds(s);
+#ifdef RPI_INTER_QPU
+    rpi_inter_clear(s);
+#endif
 }
 
 #endif
@@ -2910,6 +3101,7 @@ static void rpi_execute_inter_cmds(HEVCContext *s)
 #ifdef RPI_INTER_QPU
 static void rpi_inter_clear(HEVCContext *s)
 {
+    int job = s->pass0_job;
     int i;
     int pic_width        = s->sps->width >> s->sps->hshift[1];
     int pic_height       = s->sps->height >> s->sps->vshift[1];
@@ -2917,51 +3109,50 @@ static void rpi_inter_clear(HEVCContext *s)
                            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
                                        
     for(i=0;i<8;i++) {
-        s->u_mvs[i] = s->mvs_base[i];
-        *s->u_mvs[i]++ = 0;
-        *s->u_mvs[i]++ = 0;
-        *s->u_mvs[i]++ = 0;
-        *s->u_mvs[i]++ = 0;
-        *s->u_mvs[i]++ = 0;
-        *s->u_mvs[i]++ = pic_width;
-        *s->u_mvs[i]++ = pic_height;
-        *s->u_mvs[i]++ = s->frame->linesize[1];
-        *s->u_mvs[i]++ = s->frame->linesize[2];
+        s->u_mvs[job][i] = s->mvs_base[job][i];
+        *s->u_mvs[job][i]++ = 0;
+        *s->u_mvs[job][i]++ = 0;
+        *s->u_mvs[job][i]++ = 0;
+        *s->u_mvs[job][i]++ = 0;
+        *s->u_mvs[job][i]++ = 0;
+        *s->u_mvs[job][i]++ = pic_width;
+        *s->u_mvs[job][i]++ = pic_height;
+        *s->u_mvs[job][i]++ = s->frame->linesize[1];
+        *s->u_mvs[job][i]++ = s->frame->linesize[2];
         if (weight_flag) {
-            *s->u_mvs[i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
-            *s->u_mvs[i]++ = s->sh.chroma_log2_weight_denom + 6;
+            *s->u_mvs[job][i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
+            *s->u_mvs[job][i]++ = s->sh.chroma_log2_weight_denom + 6;
         } else {
-            *s->u_mvs[i]++ = 1 << 5;
-            *s->u_mvs[i]++ = 6;
+            *s->u_mvs[job][i]++ = 1 << 5;
+            *s->u_mvs[job][i]++ = 6;
         }
-        *s->u_mvs[i]++ = i;  // Select section of VPM (avoid collisions with 3d unit)
+        *s->u_mvs[job][i]++ = i;  // Select section of VPM (avoid collisions with 3d unit)
     }
     
 #ifdef RPI_LUMA_QPU
     for(i=0;i<12;i++) {
-        s->y_mvs[i] = s->y_mvs_base[i];
-        *s->y_mvs[i]++ = 0; // y_x
-        *s->y_mvs[i]++ = 0; // ref_y_base
-        *s->y_mvs[i]++ = 0; // y2_x2
-        *s->y_mvs[i]++ = 0; // ref_y2_base
-        *s->y_mvs[i]++ = (s->sps->width << 16) + s->sps->height;
-        *s->y_mvs[i]++ = s->frame->linesize[0]; // pitch
-        *s->y_mvs[i]++ = s->frame->linesize[0]; // dst_pitch
+        s->y_mvs[job][i] = s->y_mvs_base[job][i];
+        *s->y_mvs[job][i]++ = 0; // y_x
+        *s->y_mvs[job][i]++ = 0; // ref_y_base
+        *s->y_mvs[job][i]++ = 0; // y2_x2
+        *s->y_mvs[job][i]++ = 0; // ref_y2_base
+        *s->y_mvs[job][i]++ = (s->sps->width << 16) + s->sps->height;
+        *s->y_mvs[job][i]++ = s->frame->linesize[0]; // pitch
+        *s->y_mvs[job][i]++ = s->frame->linesize[0]; // dst_pitch
         if (weight_flag) {
             int offset = 1 << (s->sh.luma_log2_weight_denom + 6 - 1);
             int shift = s->sh.luma_log2_weight_denom + 6;
-            *s->y_mvs[i]++ = (offset << 16) + shift;
+            *s->y_mvs[job][i]++ = (offset << 16) + shift;
         } else {
             int offset = 1 << 5;
             int shift = 6;
-            *s->y_mvs[i]++ = (offset << 16) + shift;
+            *s->y_mvs[job][i]++ = (offset << 16) + shift;
         }
-        *s->y_mvs[i]++ = 0; // Next kernel
+        *s->y_mvs[job][i]++ = 0; // Next kernel
     }
 #endif
 }
 
-
 #ifdef RPI_SIMULATE_QPUS
 
 static int32_t clipx(int x,int FRAME_WIDTH) 
@@ -3235,10 +3426,15 @@ static void rpi_simulate_inter_qpu(HEVCContext *s)
 static void rpi_execute_inter_qpu(HEVCContext *s)
 {
     int k;
+#ifdef LAUNCH_PASS0
+    int job = s->pass0_job;
+#else    
+    int job = s->pass1_job;
+#endif		
     int i;
-    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;  
+    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr[job].vc;  
 #ifdef RPI_LUMA_QPU
-    uint32_t *y_unif_vc = (uint32_t *)s->y_unif_mvs_ptr.vc;
+    uint32_t *y_unif_vc = (uint32_t *)s->y_unif_mvs_ptr[job].vc;
 #endif
     if (s->sh.slice_type == I_SLICE) {
 #ifdef RPI_MULTI_MAILBOX
@@ -3247,22 +3443,22 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
 #endif
     }
     for(k=0;k<8;k++) {
-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for V        
-        av_assert0(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
+        s->u_mvs[job][k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+        s->u_mvs[job][k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
+        s->u_mvs[job][k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for V        
+        av_assert0(s->u_mvs[job][k] - s->mvs_base[job][k] < UV_COMMANDS_PER_QPU);
     }
              
-    s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+    s->u_mvs[job][8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
 
 #ifdef RPI_LUMA_QPU
     for(k=0;k<12;k++) {
-        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+1] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
-        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for second request        
-        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
-        av_assert0(s->y_mvs[k] - s->y_mvs_base[k] < Y_COMMANDS_PER_QPU);
+        s->y_mvs[job][k][-RPI_LUMA_COMMAND_WORDS+1] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined  
+        s->y_mvs[job][k][-RPI_LUMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for second request        
+        s->y_mvs[job][k][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+        av_assert0(s->y_mvs[job][k] - s->y_mvs_base[job][k] < Y_COMMANDS_PER_QPU);
     }
-    s->y_mvs[12-1][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT12); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+    s->y_mvs[job][12-1][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT12); // This QPU will signal interrupt when all others are done and have acquired a semaphore
 #endif
 
 #ifdef RPI_SIMULATE_QPUS
@@ -3272,34 +3468,34 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
 
 #ifdef RPI_MULTI_MAILBOX
 #ifdef RPI_CACHE_UNIF_MVS
-    gpu_cache_flush3(&s->coeffs_buf_accelerated,&s->y_unif_mvs_ptr, &s->unif_mvs_ptr);
+    gpu_cache_flush3(&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job]);
 #else
-    gpu_cache_flush(&s->coeffs_buf_accelerated);
+    gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
 #endif
-    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0,
+    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
                                    qpu_get_fn(QPU_MC_SETUP_UV),
-                                   (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-                                   (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-                                   (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-                                   (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-                                   (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-                                   (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-                                   (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-                                   (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[job][1 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[job][2 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[job][3 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[job][4 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[job][5 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[job][6 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(unif_vc+(s->mvs_base[job][7 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
 #ifdef RPI_LUMA_QPU                                  
                                    qpu_get_fn(QPU_MC_SETUP),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[0 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[1 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[2 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[3 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[4 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[5 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[6 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[7 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[8 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[9 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[10 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[11 ] - (uint32_t*)s->y_unif_mvs_ptr.arm))
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][0 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][1 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][2 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][3 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][4 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][5 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][6 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][7 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][8 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][9 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][10 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
+                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][11 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm))
 #else                              
                                    0,
                                    0,0,0,0,
@@ -3308,17 +3504,17 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
 #endif                                   
                                  );
     for(i=0;i<4;i++)
-        s->num_coeffs[i] = 0;
+        s->num_coeffs[job][i] = 0;
 #else
     qpu_run_shader8(qpu_get_fn(QPU_MC_SETUP_UV),
-      (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-      (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-      (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-      (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-      (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-      (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-      (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
-      (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
+      (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[job][1 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[job][2 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[job][3 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[job][4 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[job][5 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[job][6 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+      (uint32_t)(unif_vc+(s->mvs_base[job][7 ] - (uint32_t*)s->unif_mvs_ptr[job].arm))
       );
 #endif
 
@@ -3373,6 +3569,11 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
         }
     }
     
+#ifdef RPI_WORKER
+    s->pass0_job = 0;
+    s->pass1_job = 0;
+    s->pass2_job = 0;
+#endif
 #ifdef RPI_INTER_QPU
     rpi_inter_clear(s);
 #endif
@@ -3393,46 +3594,42 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
 
         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);
+
 #ifdef RPI
         if (s->enable_rpi) {
-          s->dblk_cmds[s->num_dblk_cmds][0] = x_ctb;
-          s->dblk_cmds[s->num_dblk_cmds++][1] = y_ctb;
+          s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]][0] = x_ctb;
+          s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]++][1] = y_ctb;
           if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->sps->width) {
-            // Transform all blocks
-            // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
-#ifdef RPI_MULTI_MAILBOX
-            // Kick off inter prediction on QPUs
-            rpi_execute_inter_qpu(s);
-            // Perform luma inter prediction
-            rpi_execute_inter_cmds(s);         
-#else
-            rpi_execute_transform(s);
-            // Perform inter prediction
-            rpi_execute_inter_cmds(s);
+#ifdef RPI_WORKER
+            if (s->used_for_ref) {
+              // Split work load onto separate threads so we make as rapid progress as possible with this frame
+  #ifdef INTER_PASS0
+              rpi_execute_inter_cmds(s);
+  #endif
+  #ifdef LAUNCH_PASS0
+              rpi_execute_inter_qpu(s);
+  #endif 
+              // Pass on this job to worker thread
+              worker_submit_job(s);
+              // Make sure we have space to prepare the next job
+              worker_pass0_ready(s);
+              
+              // Prepare the next batch of commands
 #ifdef RPI_INTER_QPU
-            // Kick off inter prediction on QPUs
-            rpi_execute_inter_qpu(s);
-#endif
+              rpi_inter_clear(s);
 #endif
-
-            // Wait for transform completion
-            vpu_wait(s->vpu_id);
-            
-            // Copy back reconstructed data
-            //memcpy(s->frame->data[0],s->dummy.arm,2048*64);
-            //memcpy(s->frame->data[1],s->dummy.arm,1024*32);
-            //memcpy(s->frame->data[2],s->dummy.arm,1024*32);
-            
-            // Perform intra prediction and residual reconstruction
-            rpi_execute_pred_cmds(s);
-            // Perform deblocking for CTBs in this row
-            rpi_execute_dblk_cmds(s);
-#ifdef RPI_INTER_QPU
-            rpi_inter_clear(s);
+            } else {
+              // Non-ref frame so do it all on this thread
+              rpi_do_all_passes(s);
+            }
+#else
+            rpi_do_all_passes(s);
 #endif
           }
         }
 #endif
+
+
         if (more_data < 0) {
             s->tab_slice_address[ctb_addr_rs] = -1;
             return more_data;
@@ -3449,18 +3646,21 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     }
     
 #ifdef RPI
-    if (s->enable_rpi && s->num_dblk_cmds) {
-#ifdef RPI_INTER_QPU
-        rpi_execute_inter_qpu(s);
-#endif
-#ifndef RPI_MULTI_MAILBOX
-        rpi_execute_transform(s);
+
+#ifdef RPI_WORKER
+    // Wait for the worker to finish all its jobs
+    if (s->enable_rpi) {
+        worker_wait(s);
+        av_assert0(s->pass0_job==s->pass1_job);
+        av_assert0(s->pass1_job==s->pass2_job);
+    }
 #endif
-        rpi_execute_inter_cmds(s);
-        vpu_wait(s->vpu_id);
-        rpi_execute_pred_cmds(s);
-        rpi_execute_dblk_cmds(s);
+
+    // Finish off any half-completed rows
+    if (s->enable_rpi && s->num_dblk_cmds[s->pass0_job]) {
+        rpi_do_all_passes(s);
     }
+
 #endif
 
     if (x_ctb + ctb_size >= s->sps->width &&
@@ -4348,6 +4548,48 @@ fail:
     return AVERROR(ENOMEM);
 }
 
+#ifdef RPI_WORKER
+static av_cold void hevc_init_worker(HEVCContext *s)
+{
+    int err;
+    pthread_cond_init(&s->worker_cond_head, NULL);
+    pthread_cond_init(&s->worker_cond_middle, NULL);
+    pthread_cond_init(&s->worker_cond_tail, NULL);
+    pthread_mutex_init(&s->worker_mutex, NULL);
+
+    s->worker_tail=0;
+    s->worker_middle=0;
+    s->worker_head=0;
+    s->kill_worker=0;
+    err = pthread_create(&s->worker_thread, NULL, worker_start, s);
+    err = pthread_create(&s->worker_deblock_thread, NULL, worker_deblock_start, s);
+    if (err) {
+        printf("Failed to create worker thread\n");
+        exit(-1);
+    }
+}
+
+static av_cold void hevc_exit_worker(HEVCContext *s)
+{
+    void *res;
+    s->kill_worker=1;
+    pthread_cond_broadcast(&s->worker_cond_tail);
+    pthread_cond_broadcast(&s->worker_cond_middle);
+    pthread_join(s->worker_thread, &res); 
+    pthread_join(s->worker_deblock_thread, &res); 
+    
+    pthread_cond_destroy(&s->worker_cond_head);
+    pthread_cond_destroy(&s->worker_cond_middle);
+    pthread_cond_destroy(&s->worker_cond_tail);
+    pthread_mutex_destroy(&s->worker_mutex);
+
+    s->worker_tail=0;
+    s->worker_middle=0;
+    s->worker_head=0;
+    s->kill_worker=0;
+}
+#endif
+
 static av_cold int hevc_decode_free(AVCodecContext *avctx)
 {
     HEVCContext       *s = avctx->priv_data;
@@ -4367,33 +4609,29 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
     av_freep(&s->cabac_state);
 
 #ifdef RPI
-    av_freep(&s->unif_mv_cmds);
-    av_freep(&s->univ_pred_cmds);
+
+#ifdef RPI_WORKER
+    hevc_exit_worker(s);
+#endif
+
+    for(i=0;i<RPI_MAX_JOBS;i++) {
+      av_freep(&s->unif_mv_cmds[i]);
+      av_freep(&s->univ_pred_cmds[i]);
     
 #ifdef RPI_INTER_QPU
-    if (s->unif_mvs) {
-        gpu_free( &s->unif_mvs_ptr );
-        s->unif_mvs = 0;
-    }
+      if (s->unif_mvs[i]) {
+        gpu_free( &s->unif_mvs_ptr[i] );
+        s->unif_mvs[i] = 0;
+      }
 #endif
 #ifdef RPI_LUMA_QPU
-    if (s->y_unif_mvs) {
-        gpu_free( &s->y_unif_mvs_ptr );
-        s->y_unif_mvs = 0;
-    }
+      if (s->y_unif_mvs[i]) {
+        gpu_free( &s->y_unif_mvs_ptr[i] );
+        s->y_unif_mvs[i] = 0;
+      }
 #endif
-    
-#ifdef EARLY_MALLOC
-    printf("hevc_decode_free\n");
-    if (s->coeffs_buf_arm[0]) {
-      gpu_free(&s->coeffs_buf_default);
-      s->coeffs_buf_arm[0] = 0;
     }
-    if (s->coeffs_buf_arm[2]) {
-      gpu_free(&s->coeffs_buf_accelerated);
-      s->coeffs_buf_arm[2] = 0;
-    }
-#endif
+    
 #endif
 
     for (i = 0; i < 3; i++) {
@@ -4456,6 +4694,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
 {
     HEVCContext *s = avctx->priv_data;
     int i;
+    int job;
 
     s->avctx = avctx;
 
@@ -4466,12 +4705,14 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     s->sList[0] = s;
 
 #ifdef RPI
-    s->unif_mv_cmds = av_mallocz(sizeof(HEVCMvCmd)*RPI_MAX_MV_CMDS);
-    if (!s->unif_mv_cmds)
-        goto fail;
-    s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
-    if (!s->univ_pred_cmds)
-        goto fail;
+    for(job=0;job<RPI_MAX_JOBS;job++) {
+        s->unif_mv_cmds[job] = av_mallocz(sizeof(HEVCMvCmd)*RPI_MAX_MV_CMDS);
+        if (!s->unif_mv_cmds[job])
+            goto fail;
+        s->univ_pred_cmds[job] = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
+        if (!s->univ_pred_cmds[job])
+            goto fail;
+    }
         
 #ifdef RPI_INTER_QPU
     // We divide the image into blocks 256 wide and 64 high
@@ -4482,18 +4723,20 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     {
         int uv_commands_per_qpu = UV_COMMANDS_PER_QPU;
         uint32_t *p;
+		for(job=0;job<RPI_MAX_JOBS;job++) {
 #ifdef RPI_CACHE_UNIF_MVS        
-        gpu_malloc_cached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
+          gpu_malloc_cached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr[job] );
 #else
-        gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
+          gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr[job] );
 #endif
-        s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
+          s->unif_mvs[job] = (uint32_t *) s->unif_mvs_ptr[job].arm;
     
-        // Set up initial locations for uniform streams
-        p = s->unif_mvs;
-        for(i = 0; i < 8; i++) {
-            s->mvs_base[i] = p;
+          // Set up initial locations for uniform streams
+          p = s->unif_mvs[job];
+          for(i = 0; i < 8; i++) {
+            s->mvs_base[job][i] = p;
             p += uv_commands_per_qpu;
+          }
         }
         s->mc_filter_uv = qpu_get_fn(QPU_MC_FILTER_UV);
         s->mc_filter_uv_b0 = qpu_get_fn(QPU_MC_FILTER_UV_B0);
@@ -4502,60 +4745,34 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
     }
 #endif
 #ifdef RPI_LUMA_QPU
+    for(job=0;job<RPI_MAX_JOBS;job++)
     {
         int y_commands_per_qpu = Y_COMMANDS_PER_QPU;
         uint32_t *p;
 #ifdef RPI_CACHE_UNIF_MVS
-        gpu_malloc_cached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr );
+        gpu_malloc_cached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr[job] );
 #else
-        gpu_malloc_uncached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr );
+        gpu_malloc_uncached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr[job] );
 #endif
-        s->y_unif_mvs = (uint32_t *) s->y_unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
+        s->y_unif_mvs[job] = (uint32_t *) s->y_unif_mvs_ptr[job].arm;
     
         // Set up initial locations for uniform streams
-        p = s->y_unif_mvs;
+        p = s->y_unif_mvs[job];
         for(i = 0; i < 12; i++) {
-            s->y_mvs_base[i] = p;
+            s->y_mvs_base[job][i] = p;
             p += y_commands_per_qpu;
-        }
-        s->mc_filter = qpu_get_fn(QPU_MC_FILTER);
-        s->mc_filter_b = qpu_get_fn(QPU_MC_FILTER_B);
-        
+        }     
     }
+    s->mc_filter = qpu_get_fn(QPU_MC_FILTER);
+    s->mc_filter_b = qpu_get_fn(QPU_MC_FILTER_B);
 #endif
     //gpu_malloc_uncached(2048*64,&s->dummy);
-    
-#ifdef EARLY_MALLOC 
-    {
-        int coeffs_in_ctb = 64*64;
-        int coefs_per_row = (2048/64) * coeffs_in_ctb * 3;  // Allow space for chroma
-        s->coeffs_buf_arm[0] = 0;
-        s->coeffs_buf_arm[2] = 0;
-        printf("Allocated %d\n",coefs_per_row);
-        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
-        s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
-        if (!s->coeffs_buf_arm[0])
-            goto fail;
-        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
-        s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
-        s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
-        if (!s->coeffs_buf_arm[2])
-            goto fail;    
-        s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
-        s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
-        printf("Done\n");
-#ifdef RPI_PRECLEAR
-        //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
-        memclear16(s->coeffs_buf_arm[0], coefs_per_row);
-        //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
-        memclear16(s->coeffs_buf_arm[2], coefs_per_row);
-        //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
-        memclear16(s->coeffs_buf_arm[3], coefs_per_row);
-#endif
-    }
-#endif
 
     s->enable_rpi = 0;
+	
+#ifdef RPI_WORKER
+    hevc_init_worker(s);
+#endif
     
 #endif
 
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 09eb4c9..06f07d9 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -49,6 +49,12 @@
     // Define RPI_LUMA_QPU to also use QPU for luma inter prediction
     #define RPI_LUMA_QPU
   #endif
+  
+  // By passing jobs to a worker thread we hope to be able to catch up during slow frames
+  #define RPI_MAX_JOBS 2
+  // Define RPI_WORKER to launch a worker thread for pixel processing tasks
+  #define RPI_WORKER
+  
 #endif
 
 #define MAX_DPB_SIZE 16 // A.4.1
@@ -802,6 +808,13 @@ typedef struct HEVCLocalContext {
     int boundary_flags;
 } HEVCLocalContext;
 
+#ifdef RPI_WORKER
+typedef struct HEVCLocalContextIntra {
+    TransformUnit tu;
+    NeighbourAvailable na;
+} HEVCLocalContextIntra;
+#endif
+
 #ifdef RPI
 
 // RPI_MAX_WIDTH is maximum width in pixels supported by the accelerated code
@@ -870,7 +883,7 @@ typedef struct HEVCPredCmd {
 
 typedef struct HEVCContext {
 #ifdef RPI
-    int dblk_cmds[RPI_MAX_DEBLOCK_CMDS][2];
+    int dblk_cmds[RPI_MAX_JOBS][RPI_MAX_DEBLOCK_CMDS][2];
 #endif
     const AVClass *c;  // needed by private avoptions
     AVCodecContext *avctx;
@@ -879,7 +892,9 @@ typedef struct HEVCContext {
 
     HEVCLocalContext    *HEVClcList[MAX_NB_THREADS];
     HEVCLocalContext    *HEVClc;
-
+#ifdef RPI_WORKER
+    HEVCLocalContextIntra HEVClcIntra;
+#endif
     uint8_t             threads_type;
     uint8_t             threads_number;
 
@@ -890,41 +905,58 @@ typedef struct HEVCContext {
 
 #ifdef RPI
     int enable_rpi;
-    HEVCMvCmd *unif_mv_cmds;
-    HEVCPredCmd *univ_pred_cmds;
+    HEVCMvCmd *unif_mv_cmds[RPI_MAX_JOBS];
+    HEVCPredCmd *univ_pred_cmds[RPI_MAX_JOBS];
     int buf_width;
-    GPU_MEM_PTR_T coeffs_buf_default;
-    GPU_MEM_PTR_T coeffs_buf_accelerated;
-    int16_t *coeffs_buf_arm[4];
-    unsigned int coeffs_buf_vc[4];
-    int num_coeffs[4];
-    int num_xfm_cmds;
-    int num_mv_cmds;
-    int num_pred_cmds;
-    int num_dblk_cmds;
+    GPU_MEM_PTR_T coeffs_buf_default[RPI_MAX_JOBS];
+    GPU_MEM_PTR_T coeffs_buf_accelerated[RPI_MAX_JOBS];
+    int16_t *coeffs_buf_arm[RPI_MAX_JOBS][4];
+    unsigned int coeffs_buf_vc[RPI_MAX_JOBS][4];
+    int num_coeffs[RPI_MAX_JOBS][4];
+    int num_xfm_cmds[RPI_MAX_JOBS];
+    int num_mv_cmds[RPI_MAX_JOBS];
+    int num_pred_cmds[RPI_MAX_JOBS];
+    int num_dblk_cmds[RPI_MAX_JOBS];
     int vpu_id;
     //GPU_MEM_PTR_T dummy;
+    int pass0_job; // Pass0 does coefficient decode
+    int pass1_job; // Pass1 does pixel processing
+    int pass2_job; // Pass2 does reconstruction and deblocking
 #ifdef RPI_INTER_QPU
-    GPU_MEM_PTR_T unif_mvs_ptr;
-    uint32_t *unif_mvs; // Base of memory for motion vector commands
+    GPU_MEM_PTR_T unif_mvs_ptr[RPI_MAX_JOBS];
+    uint32_t *unif_mvs[RPI_MAX_JOBS]; // Base of memory for motion vector commands
     
     // _base pointers are to the start of the row
-    uint32_t *mvs_base[8];
+    uint32_t *mvs_base[RPI_MAX_JOBS][8];
     // these pointers are to the next free space
-    uint32_t *u_mvs[8];
+    uint32_t *u_mvs[RPI_MAX_JOBS][8];
     // Function pointers
     uint32_t mc_filter_uv;
     uint32_t mc_filter_uv_b0;
     uint32_t mc_filter_uv_b;
 #endif
 #ifdef RPI_LUMA_QPU
-    GPU_MEM_PTR_T y_unif_mvs_ptr;
-    uint32_t *y_unif_mvs; // Base of memory for motion vector commands
-    uint32_t *y_mvs_base[12];
-    uint32_t *y_mvs[12];
+    GPU_MEM_PTR_T y_unif_mvs_ptr[RPI_MAX_JOBS];
+    uint32_t *y_unif_mvs[RPI_MAX_JOBS]; // Base of memory for motion vector commands
+    uint32_t *y_mvs_base[RPI_MAX_JOBS][12];
+    uint32_t *y_mvs[RPI_MAX_JOBS][12];
     // Function pointers
     uint32_t mc_filter;
-    uint32_t mc_filter_b;
+    uint32_t mc_filter_b;	
+#endif
+
+#ifdef RPI_WORKER
+    pthread_t worker_thread;
+    pthread_t worker_deblock_thread;
+    pthread_cond_t worker_cond_head;
+    pthread_cond_t worker_cond_tail;
+    pthread_cond_t worker_cond_middle;
+    pthread_mutex_t worker_mutex;
+
+    int worker_tail; // Contains the number of posted jobs
+    int worker_head; // Contains the number of completed jobs
+    int worker_middle; // Contains the number of completed jobs
+    int kill_worker; // set to 1 to terminate the worker
 #endif
     
 #endif
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index 7f50567..c550743 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1099,11 +1099,11 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     if (s->enable_rpi) {
         int n = trafo_size * trafo_size;
         if (use_vpu) {
-            coeffs = s->coeffs_buf_arm[log2_trafo_size - 2] + s->num_coeffs[log2_trafo_size - 2];
-            s->num_coeffs[log2_trafo_size - 2] += n;
+            coeffs = s->coeffs_buf_arm[s->pass0_job][log2_trafo_size - 2] + s->num_coeffs[s->pass0_job][log2_trafo_size - 2];
+            s->num_coeffs[s->pass0_job][log2_trafo_size - 2] += n;
         } else {
-            coeffs = s->coeffs_buf_arm[0] + s->num_coeffs[0];
-            s->num_coeffs[0] += n;
+            coeffs = s->coeffs_buf_arm[s->pass0_job][0] + s->num_coeffs[s->pass0_job][0];
+            s->num_coeffs[s->pass0_job][0] += n;
         }
     }
     // We now do the memset after transform_add while we know the data is cached.
@@ -1556,7 +1556,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                 s->hevcdsp.transform_rdpcm(coeffs, log2_trafo_size, mode);
             }
         } else if (lc->cu.pred_mode == MODE_INTRA && c_idx == 0 && log2_trafo_size == 2) {
-            s->hevcdsp.idct_4x4_luma(coeffs);
+           s->hevcdsp.idct_4x4_luma(coeffs);
         } else {
 #ifdef RPI
             if (!use_vpu) {
@@ -1601,7 +1601,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     }
 #ifdef RPI
     if (s->enable_rpi) {
-        HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
+        HEVCPredCmd *cmd = s->univ_pred_cmds[s->pass0_job] + s->num_pred_cmds[s->pass0_job]++;
         cmd->type = RPI_PRED_TRANSFORM_ADD;
         cmd->size = log2_trafo_size;
         cmd->buf = coeffs;
diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
index d90bdad..3f436f6 100644
--- a/libavcodec/hevcpred_template.c
+++ b/libavcodec/hevcpred_template.c
@@ -71,8 +71,11 @@ do {                                  \
                 AV_WN4P(&ptr[i], a);                                           \
             else                                                               \
                 a = PIXEL_SPLAT_X4(ptr[i + 3])
-
+#ifdef RPI_WORKER
+    HEVCLocalContextIntra *lc = &s->HEVClcIntra;
+#else
     HEVCLocalContext *lc = s->HEVClc;
+#endif
     int i;
     int hshift = s->sps->hshift[c_idx];
     int vshift = s->sps->vshift[c_idx];
-- 
1.9.1


From f2f3f4364b9debbfae67da01c4d47008c56d67b5 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 3 Jun 2015 13:43:48 +0100
Subject: [PATCH 66/77] Avoid lockup bug with RPI_WORKER enabled

---
 libavcodec/hevc.c       | 23 +++++++++++------------
 libavcodec/hevc_cabac.c |  1 -
 2 files changed, 11 insertions(+), 13 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index ab9f56c..6e87d77 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -131,11 +131,11 @@ static uint32_t get_vc_address(AVBufferRef *bref) {
 static void worker_submit_job(HEVCContext *s)
 {
   LOG_ENTER
-  //pthread_mutex_lock(&s->worker_mutex);
-  s->worker_tail++; // This is the only place that can change tail so we do not need the mutex
+  pthread_mutex_lock(&s->worker_mutex);
+  s->worker_tail++;
   s->pass0_job = (s->pass0_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
   pthread_cond_broadcast(&s->worker_cond_tail); // Let people know that the tail has moved
-  //pthread_mutex_unlock(&s->worker_mutex);
+  pthread_mutex_unlock(&s->worker_mutex);
   LOG_EXIT
 }
 
@@ -143,11 +143,11 @@ static void worker_submit_job(HEVCContext *s)
 static void worker_complete_middle_job(HEVCContext *s)
 {
   LOG_ENTER
-  //pthread_mutex_lock(&s->worker_mutex);
-  s->worker_middle++; // This is the only place that can change head so we do not need the mutex
+  pthread_mutex_lock(&s->worker_mutex);
+  s->worker_middle++;
   s->pass1_job = (s->pass1_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
-  pthread_cond_broadcast(&s->worker_cond_middle); // Let people know that the tail has moved
-  //pthread_mutex_unlock(&s->worker_mutex);
+  pthread_cond_broadcast(&s->worker_cond_middle); // Let people know that the middle has moved
+  pthread_mutex_unlock(&s->worker_mutex);
   LOG_EXIT
 }
 
@@ -155,11 +155,11 @@ static void worker_complete_middle_job(HEVCContext *s)
 static void worker_complete_job(HEVCContext *s)
 {
   LOG_ENTER
-  //pthread_mutex_lock(&s->worker_mutex);
-  s->worker_head++; // This is the only place that can change head so we do not need the mutex
+  pthread_mutex_lock(&s->worker_mutex);
+  s->worker_head++;
   s->pass2_job = (s->pass2_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
-  pthread_cond_broadcast(&s->worker_cond_head); // Let people know that the tail has moved
-  //pthread_mutex_unlock(&s->worker_mutex);
+  pthread_cond_broadcast(&s->worker_cond_head); // Let people know that the head has moved
+  pthread_mutex_unlock(&s->worker_mutex);
   LOG_EXIT
 }
 
@@ -3530,7 +3530,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     int x_ctb       = 0;
     int y_ctb       = 0;
     int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
-
 #ifdef RPI
 #ifdef RPI_INTER_QPU
     s->enable_rpi = s->sps->width <= RPI_MAX_WIDTH
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index c550743..79fe95c 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1545,7 +1545,6 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                 for (i = 0; i < 8; i++)
                     FFSWAP(int16_t, coeffs[i], coeffs[16 - i - 1]);
             }
-
             s->hevcdsp.transform_skip(coeffs, log2_trafo_size);
 
             if (explicit_rdpcm_flag || (s->sps->implicit_rdpcm_enabled_flag &&
-- 
1.9.1


From 325e5f6a1b96779e4de3c5f92c9f10cd49aa3ac3 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 3 Jun 2015 15:37:19 +0100
Subject: [PATCH 67/77] Added code to flush buffers at start of frame

---
 libavcodec/hevc.c | 74 ++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 73 insertions(+), 1 deletion(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 6e87d77..4b636e5 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -41,6 +41,7 @@
 
 #ifdef RPI
   #include "rpi_qpu.h"
+  #include "rpi_user_vcsm.h"
   // Move Inter prediction into separate pass
   #define RPI_INTER
   
@@ -3472,6 +3473,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
 #else
     gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
 #endif
+
     s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
                                    qpu_get_fn(QPU_MC_SETUP_UV),
                                    (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
@@ -3522,6 +3524,71 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
 }
 #endif
 
+#ifdef RPI
+
+static void flush_buffer(AVBufferRef *bref) {
+    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+    gpu_cache_flush(p);
+}
+
+static void flush_frame(HEVCContext *s,AVFrame *frame) 
+{ 
+#if 1
+    struct vcsm_user_clean_invalid_s iocache = {};
+    int n = s->sps->height;
+    int curr_y = 0;
+    int curr_uv = 0;
+    int n_uv = n >> s->sps->vshift[1];
+    int sz,base;
+    sz = s->frame->linesize[1] * (n_uv-curr_uv);
+    base = s->frame->linesize[1] * curr_uv;
+    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
+    iocache.s[0].handle = p->vcsm_handle;
+    iocache.s[0].cmd = 3; // clean+invalidate
+    iocache.s[0].addr = p->arm + base;
+    iocache.s[0].size  = sz;
+    p = av_buffer_pool_opaque(frame->buf[2]);
+    iocache.s[1].handle = p->vcsm_handle;
+    iocache.s[1].cmd = 3; // clean+invalidate
+    iocache.s[1].addr = p->arm + base;
+    iocache.s[1].size  = sz;
+    p = av_buffer_pool_opaque(frame->buf[0]);
+    sz = s->frame->linesize[0] * (n-curr_y);
+    base = s->frame->linesize[0] * curr_y;
+    iocache.s[2].handle = p->vcsm_handle;
+    iocache.s[2].cmd = 3; // clean+invalidate
+    iocache.s[2].addr = p->arm + base;
+    iocache.s[2].size  = sz;
+    vcsm_clean_invalid( &iocache );
+#else            
+    flush_buffer(frame->buf[0]);
+    flush_buffer(frame->buf[1]);
+    flush_buffer(frame->buf[2]);
+#endif
+}
+
+static void flush_all(HEVCContext *s)
+{
+#if 0
+    struct vcsm_user_clean_invalid_s iocache = {};
+    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[0]);
+    iocache.s[0].handle = p->vcsm_handle;
+    iocache.s[0].cmd = 4; // Flush all
+    iocache.s[0].addr = p->arm;
+    iocache.s[0].size  = 4096;
+    vcsm_clean_invalid( &iocache );
+#else 
+  int i,k;
+  for(i=0;i<2;i++) {
+    for (k = 0; k < s->sh.nb_refs[i]; k++) {
+      flush_frame(s,s->ref->refPicList[i].ref[k]->frame);
+    }
+  }
+  flush_frame(s,s->frame);
+#endif
+}     
+#endif
+
 static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 {
     HEVCContext *s  = avctxt->priv_data;
@@ -3552,9 +3619,13 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
       if (s->pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
         printf("Weighted B slice\n");
     }
-                    
+    
+    // Now flush all reference frames and our destination frame to get everything ready for decode
+    flush_all(s);         
 #endif
 
+    //printf("L0=%d L1=%d\n",s->sh.nb_refs[L1],s->sh.nb_refs[L1]);
+
     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
         av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n");
         return AVERROR_INVALIDDATA;
@@ -3625,6 +3696,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
             rpi_do_all_passes(s);
 #endif
           }
+
         }
 #endif
 
-- 
1.9.1


From 54b7a761483793fca38d8627237ca0a0feb70746 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Wed, 3 Jun 2015 16:42:24 +0100
Subject: [PATCH 68/77] Reduce the amount that needs to be flushed

---
 libavcodec/hevc.c | 45 ++++++++++++++++-----------------------------
 1 file changed, 16 insertions(+), 29 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 4b636e5..e7be402 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -3533,7 +3533,7 @@ static void flush_buffer(AVBufferRef *bref) {
 
 static void flush_frame(HEVCContext *s,AVFrame *frame) 
 { 
-#if 1
+#ifdef RPI_FAST_CACHEFLUSH
     struct vcsm_user_clean_invalid_s iocache = {};
     int n = s->sps->height;
     int curr_y = 0;
@@ -3566,27 +3566,7 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
     flush_buffer(frame->buf[2]);
 #endif
 }
-
-static void flush_all(HEVCContext *s)
-{
-#if 0
-    struct vcsm_user_clean_invalid_s iocache = {};
-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[0]);
-    iocache.s[0].handle = p->vcsm_handle;
-    iocache.s[0].cmd = 4; // Flush all
-    iocache.s[0].addr = p->arm;
-    iocache.s[0].size  = 4096;
-    vcsm_clean_invalid( &iocache );
-#else 
-  int i,k;
-  for(i=0;i<2;i++) {
-    for (k = 0; k < s->sh.nb_refs[i]; k++) {
-      flush_frame(s,s->ref->refPicList[i].ref[k]->frame);
-    }
-  }
-  flush_frame(s,s->frame);
-#endif
-}     
+ 
 #endif
 
 static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
@@ -3618,10 +3598,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
         printf("Weighted P slice\n");
       if (s->pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
         printf("Weighted B slice\n");
-    }
-    
-    // Now flush all reference frames and our destination frame to get everything ready for decode
-    flush_all(s);         
+    }  
 #endif
 
     //printf("L0=%d L1=%d\n",s->sh.nb_refs[L1],s->sh.nb_refs[L1]);
@@ -3736,7 +3713,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 
     if (x_ctb + ctb_size >= s->sps->width &&
         y_ctb + ctb_size >= s->sps->height)
-        ff_hevc_hls_filter(s, x_ctb, y_ctb, ctb_size);
+        ff_hevc_hls_filter(s, x_ctb, y_ctb, ctb_size); 
 
     return ctb_addr_ts;
 }
@@ -4042,6 +4019,11 @@ static int hevc_frame_start(HEVCContext *s)
 
     if (!s->avctx->hwaccel)
         ff_thread_finish_setup(s->avctx);
+        
+#ifdef RPI_INTER_QPU
+    // Invalidate the output data buffer so it is ready for the QPUs to write into it.
+    flush_frame(s,s->frame); 
+#endif
 
     return 0;
 
@@ -4445,12 +4427,18 @@ static int decode_nal_units(HEVCContext *s, const uint8_t *buf, int length)
         }
     }
 
-fail:
+fail: 
+
     if (s->ref && s->threads_type == FF_THREAD_FRAME) {
 #ifdef RPI_INTER_QPU
         ff_hevc_flush_buffer(s, &s->ref->tf, s->sps->height);
 #endif
         ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);
+    } else if (s->ref) {
+#ifdef RPI_INTER_QPU
+      // When running single threaded we need to flush the whole frame
+      flush_frame(s,s->frame);  
+#endif
     }
     return ret;
 }
@@ -4542,7 +4530,6 @@ static int hevc_decode_frame(AVCodecContext *avctx, void *data, int *got_output,
         *got_output = ret;
         return 0;
     }
-
     s->ref = NULL;
     ret    = decode_nal_units(s, avpkt->data, avpkt->size);
     if (ret < 0)
-- 
1.9.1


From ed332a1c6b5a2b3534e1aecf4d4f88e16299fdd7 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 4 Jun 2015 07:59:28 +0100
Subject: [PATCH 69/77] Corrected support for disabled rpi when using
 RPI_WORKER

---
 libavcodec/hevc.h              | 22 ++++++++++++----------
 libavcodec/hevcpred_template.c |  2 +-
 2 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 06f07d9..bd8b316 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -765,7 +765,17 @@ typedef struct HEVCNAL {
     const uint8_t *raw_data;
 } HEVCNAL;
 
+#ifdef RPI_WORKER
+typedef struct HEVCLocalContextIntra {
+    TransformUnit tu;
+    NeighbourAvailable na;
+} HEVCLocalContextIntra;
+#endif
+
 typedef struct HEVCLocalContext {
+    TransformUnit tu;
+    NeighbourAvailable na;  // WARNING tu and na must be the first two fields to match HEVCLocalContextIntra
+
     uint8_t cabac_state[HEVC_CONTEXTS];
 
     uint8_t stat_coeff[4];
@@ -780,8 +790,7 @@ typedef struct HEVCLocalContext {
 
     int qPy_pred;
 
-    TransformUnit tu;
-
+    
     uint8_t ctb_left_flag;
     uint8_t ctb_up_flag;
     uint8_t ctb_up_right_flag;
@@ -797,8 +806,7 @@ typedef struct HEVCLocalContext {
     int ct_depth;
     CodingUnit cu;
     PredictionUnit pu;
-    NeighbourAvailable na;
-
+    
 #define BOUNDARY_LEFT_SLICE     (1 << 0)
 #define BOUNDARY_LEFT_TILE      (1 << 1)
 #define BOUNDARY_UPPER_SLICE    (1 << 2)
@@ -808,12 +816,6 @@ typedef struct HEVCLocalContext {
     int boundary_flags;
 } HEVCLocalContext;
 
-#ifdef RPI_WORKER
-typedef struct HEVCLocalContextIntra {
-    TransformUnit tu;
-    NeighbourAvailable na;
-} HEVCLocalContextIntra;
-#endif
 
 #ifdef RPI
 
diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
index 3f436f6..d2be290 100644
--- a/libavcodec/hevcpred_template.c
+++ b/libavcodec/hevcpred_template.c
@@ -72,7 +72,7 @@ do {                                  \
             else                                                               \
                 a = PIXEL_SPLAT_X4(ptr[i + 3])
 #ifdef RPI_WORKER
-    HEVCLocalContextIntra *lc = &s->HEVClcIntra;
+    HEVCLocalContextIntra *lc = s->enable_rpi ? &s->HEVClcIntra : (HEVCLocalContextIntra *)s->HEVClc ;
 #else
     HEVCLocalContext *lc = s->HEVClc;
 #endif
-- 
1.9.1


From 229fa16b6ae10977187624da249facd765831cb0 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Thu, 4 Jun 2015 11:52:55 +0100
Subject: [PATCH 70/77] Draft support for tiles

---
 libavcodec/hevc.c              | 149 +++++++++++++++++++++++------------------
 libavcodec/hevc.h              |  18 ++++-
 libavcodec/hevc_filter.c       |   2 +-
 libavcodec/hevcpred_template.c |   2 +-
 libavcodec/rpi_qpu.c           |   2 +-
 5 files changed, 104 insertions(+), 69 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index e7be402..def076c 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -61,10 +61,10 @@
   
   static void rpi_execute_dblk_cmds(HEVCContext *s);
   static void rpi_execute_transform(HEVCContext *s);
-  static void rpi_execute_inter_qpu(HEVCContext *s);
+  static void rpi_launch_vpu_qpu(HEVCContext *s);
   static void rpi_execute_pred_cmds(HEVCContext *s);
   static void rpi_execute_inter_cmds(HEVCContext *s);
-  static void rpi_inter_clear(HEVCContext *s);
+  static void rpi_begin(HEVCContext *s);
   
   // Define INTER_PASS0 to do inter prediction in first pass
   //#define INTER_PASS0
@@ -88,16 +88,18 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
 
 #ifdef RPI_INTER_QPU
 
+// Each luma QPU processes 2*RPI_NUM_CHUNKS 64x64 blocks
+// Each chroma QPU processes 3*RPI_NUM_CHUNKS 64x64 blocks, but requires two commands for B blocks
+// For each block of 64*64 the smallest block size is 8x4
+// We also need an extra command for the setup information
+
 #define RPI_CHROMA_COMMAND_WORDS 12
-#define UV_COMMANDS_PER_QPU ((1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS)       
+#define UV_COMMANDS_PER_QPU ((1 + 3*RPI_NUM_CHUNKS*(64*64)*2/(8*4)) * RPI_CHROMA_COMMAND_WORDS)       
 // The QPU code for UV blocks only works up to a block width of 8
 #define RPI_CHROMA_BLOCK_WIDTH 8
 
-// Split image of 2048 into parts 64 wide
-// So some QPUs will have 3 blocks of 64 to do, and others 2 blocks for an image 2048 wide with 32 blocks across
-// For each block of 64*64 the smallest block size is 8x4
 #define RPI_LUMA_COMMAND_WORDS 9
-#define Y_COMMANDS_PER_QPU ((1+3*(64*64)/(8*4)) * RPI_LUMA_COMMAND_WORDS)
+#define Y_COMMANDS_PER_QPU ((1+2*RPI_NUM_CHUNKS*(64*64)/(8*4)) * RPI_LUMA_COMMAND_WORDS)
 
 #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
 
@@ -214,7 +216,7 @@ static void *worker_start(void *arg)
     LOG_ENTER
     // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
 #ifndef LAUNCH_PASS0   
-    rpi_execute_inter_qpu(s);
+    rpi_launch_vpu_qpu(s);
 #endif
 #ifndef INTER_PASS0
     // Perform inter prediction
@@ -320,9 +322,14 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
     
 #ifdef RPI
     av_assert0(sps);
-    int coeffs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
-    int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
+    int coefs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
+    int coefs_per_luma = 64*64*24*RPI_NUM_CHUNKS;
+    int coefs_per_chroma = (coefs_per_luma * 2) >> sps->vshift[1] >> sps->hshift[1];
+    int coefs_per_row = coefs_per_luma + coefs_per_chroma;
     int job;
+    s->max_ctu_count = coefs_per_luma / coefs_in_ctb;
+    s->ctu_per_y_chan = s->max_ctu_count / 12;
+    s->ctu_per_uv_chan = s->max_ctu_count / 8;
     for(job=0;job<RPI_MAX_JOBS;job++) {
       printf("Allocated %d\n",coefs_per_row);
       for(job=0;job<RPI_MAX_JOBS;job++) {
@@ -2150,10 +2157,9 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             int my2_mx2_my_mx = (my_mx << 16) + my_mx;
             int x1 = x0 + (mv->x >> 2);
             int y1 = y0 + (mv->y >> 2);
-            int chan = x0>>6; // 64 wide blocks per QPU
             int weight_flag = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                               (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);    
-            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];      
+            uint32_t *y = s->curr_y_mvs;      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=16) {
                   int bw = nPbW-start_x;
@@ -2173,7 +2179,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
                 }
             }
-            s->y_mvs[s->pass0_job][chan % 12] = y;
+            s->curr_y_mvs = y;
         } else 
 #endif
         {
@@ -2197,12 +2203,10 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
 
                 int x1_c = x0_c + (mv->x >> (2 + hshift));
                 int y1_c = y0_c + (mv->y >> (2 + hshift));
-                //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
-                int chan = x0>>8;
                 int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                                        (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
                 
-                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];      
+                uint32_t *u = s->curr_u_mvs;      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       int bw = nPbW_c-start_x;
@@ -2226,7 +2230,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
                 }
-                s->u_mvs[s->pass0_job][chan & 7] = u;
+                s->curr_u_mvs = u;
                 return;
             }
 #endif
@@ -2253,10 +2257,9 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             int my2_mx2_my_mx = (my_mx << 16) + my_mx;
             int x1 = x0 + (mv->x >> 2);
             int y1 = y0 + (mv->y >> 2);
-            int chan = x0>>6; // 64 wide blocks per QPU
             int weight_flag = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                               (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);    
-            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];      
+            uint32_t *y = s->curr_y_mvs;      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=16) {
                   int bw = nPbW-start_x;
@@ -2276,7 +2279,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
                 }
             }
-            s->y_mvs[s->pass0_job][chan % 12] = y;
+            s->curr_y_mvs = y;
         } else 
 #endif
 
@@ -2301,12 +2304,10 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
 
                 int x1_c = x0_c + (mv->x >> (2 + hshift));
                 int y1_c = y0_c + (mv->y >> (2 + hshift));
-                //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
-                int chan = x0>>8;
                 int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
                                        (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag);
                 
-                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];      
+                uint32_t *u = s->curr_u_mvs;      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       int bw = nPbW_c-start_x;
@@ -2331,7 +2332,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
                 }
-                s->u_mvs[s->pass0_job][chan & 7] = u;
+                s->curr_u_mvs = u;
                 return;
             }
 #endif
@@ -2364,8 +2365,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
             int y1 = y0 + (mv->y >> 2);
             int x2 = x0 + (mv2->x >> 2);
             int y2 = y0 + (mv2->y >> 2);
-            int chan = x0>>6; // 64 wide blocks per QPU
-            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];      
+            uint32_t *y = s->curr_y_mvs;      
             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
               for(int start_x=0;start_x < nPbW;start_x+=8) { // B blocks work 8 at a time
                   int bw = nPbW-start_x;
@@ -2381,7 +2381,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter_b;
                 }
             }
-            s->y_mvs[s->pass0_job][chan % 12] = y;
+            s->curr_y_mvs = y;
         } else 
 #endif
         {
@@ -2412,9 +2412,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                 int x2_c = x0_c + (mv2->x >> (2 + hshift));
                 int y2_c = y0_c + (mv2->y >> (2 + hshift));
                 
-                int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
-
-                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];      
+                
+                uint32_t *u = s->curr_u_mvs;      
                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {  
                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
                       int bw = nPbW_c-start_x;
@@ -2443,7 +2442,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
                     }
                 }
-                s->u_mvs[s->pass0_job][chan & 7] = u;
+                s->curr_u_mvs = u;
                 return;
             }
 #endif
@@ -3078,12 +3077,8 @@ static void rpi_execute_inter_cmds(HEVCContext *s)
 
 static void rpi_do_all_passes(HEVCContext *s)
 {
-#ifdef RPI_INTER_QPU
-    // Kick off inter prediction on QPUs
-    rpi_execute_inter_qpu(s);
-#else
-    rpi_execute_transform(s);
-#endif            
+    // Kick off QPUs and VPUs
+    rpi_launch_vpu_qpu(s);            
     // Perform luma inter prediction
     rpi_execute_inter_cmds(s);              
     // Wait for transform completion
@@ -3092,18 +3087,18 @@ static void rpi_do_all_passes(HEVCContext *s)
     rpi_execute_pred_cmds(s);
     // Perform deblocking for CTBs in this row
     rpi_execute_dblk_cmds(s);
-#ifdef RPI_INTER_QPU
-    rpi_inter_clear(s);
-#endif
+    // Prepare next batch
+    rpi_begin(s);
 }
 
 #endif
 
-#ifdef RPI_INTER_QPU
-static void rpi_inter_clear(HEVCContext *s)
+#ifdef RPI
+static void rpi_begin(HEVCContext *s)
 {
     int job = s->pass0_job;
     int i;
+#ifdef RPI_INTER_QPU
     int pic_width        = s->sps->width >> s->sps->hshift[1];
     int pic_height       = s->sps->height >> s->sps->vshift[1];
     int weight_flag      = (s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||
@@ -3129,6 +3124,8 @@ static void rpi_inter_clear(HEVCContext *s)
         }
         *s->u_mvs[job][i]++ = i;  // Select section of VPM (avoid collisions with 3d unit)
     }
+    s->curr_u_mvs = s->u_mvs[job][0];
+#endif
     
 #ifdef RPI_LUMA_QPU
     for(i=0;i<12;i++) {
@@ -3151,8 +3148,11 @@ static void rpi_inter_clear(HEVCContext *s)
         }
         *s->y_mvs[job][i]++ = 0; // Next kernel
     }
+    s->curr_y_mvs = s->y_mvs[job][0];
 #endif
+    s->ctu_count = 0;
 }
+#endif
 
 #ifdef RPI_SIMULATE_QPUS
 
@@ -3423,8 +3423,9 @@ static void rpi_simulate_inter_qpu(HEVCContext *s)
 
 #endif
 
+#ifdef RPI_INTER_QPU
 
-static void rpi_execute_inter_qpu(HEVCContext *s)
+static void rpi_launch_vpu_qpu(HEVCContext *s)
 {
     int k;
 #ifdef LAUNCH_PASS0
@@ -3522,6 +3523,15 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
 
 
 }
+#else
+
+#ifdef RPI
+static void rpi_launch_vpu_qpu(HEVCContext *s)
+{
+  rpi_execute_transform(s);
+}
+#endif
+  
 #endif
 
 #ifdef RPI
@@ -3579,28 +3589,19 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
 #ifdef RPI
 #ifdef RPI_INTER_QPU
-    s->enable_rpi = s->sps->width <= RPI_MAX_WIDTH
-                    && !s->pps->cross_component_prediction_enabled_flag
-                    && s->pps->num_tile_rows <= 1 && s->pps->num_tile_columns <= 1
+    s->enable_rpi = !s->pps->cross_component_prediction_enabled_flag
                     && !(s->pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE);
 #else
-    s->enable_rpi = s->sps->width <= RPI_MAX_WIDTH
-                    && !s->pps->cross_component_prediction_enabled_flag
-                    && s->pps->num_tile_rows <= 1 && s->pps->num_tile_columns <= 1;
+    s->enable_rpi = !s->pps->cross_component_prediction_enabled_flag;
 #endif                    
                     
     if (!s->enable_rpi) {
       if (s->pps->cross_component_prediction_enabled_flag)
         printf("Cross component\n");
-      if (s->pps->num_tile_rows > 1 || s->pps->num_tile_columns > 1)
-        printf("Tiles\n");
-      if (s->pps->weighted_pred_flag && s->sh.slice_type == P_SLICE)
-        printf("Weighted P slice\n");
       if (s->pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
         printf("Weighted B slice\n");
     }  
 #endif
-
     //printf("L0=%d L1=%d\n",s->sh.nb_refs[L1],s->sh.nb_refs[L1]);
 
     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
@@ -3621,10 +3622,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     s->pass1_job = 0;
     s->pass2_job = 0;
 #endif
-#ifdef RPI_INTER_QPU
-    rpi_inter_clear(s);
+#ifdef RPI
+    rpi_begin(s);
 #endif
-
     while (more_data && ctb_addr_ts < s->sps->ctb_size) {
         int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];
 
@@ -3639,14 +3639,37 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
         s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;
         s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;
         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
-
+        
+#ifdef RPI_INTER_QPU
+        s->curr_u_mvs = s->u_mvs[s->pass0_job][s->ctu_count / s->ctu_per_uv_chan];
+#endif
+#ifdef RPI_LUMA_QPU
+        s->curr_y_mvs = s->y_mvs[s->pass0_job][s->ctu_count / s->ctu_per_y_chan];
+#endif
+        
         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);
+        
+#ifdef RPI_INTER_QPU
+        s->u_mvs[s->pass0_job][s->ctu_count / s->ctu_per_uv_chan] = s->curr_u_mvs;
+#endif
+#ifdef RPI_LUMA_QPU
+        s->y_mvs[s->pass0_job][s->ctu_count / s->ctu_per_y_chan] = s->curr_y_mvs;
+#endif
 
 #ifdef RPI
         if (s->enable_rpi) {
+          //av_assert0(s->num_dblk_cmds[s->pass0_job]>=0);
+          //av_assert0(s->num_dblk_cmds[s->pass0_job]<RPI_MAX_DEBLOCK_CMDS);
+          //av_assert0(s->pass0_job<RPI_MAX_JOBS);
+          //av_assert0(s->pass0_job>=0);
+          //av_assert0(s->magic_top == 0xaffe);
+          //av_assert0(s->magic_bottom == 0xaffe);
           s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]][0] = x_ctb;
           s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]++][1] = y_ctb;
-          if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->sps->width) {
+          s->ctu_count++;
+          //printf("%d %d/%d job=%d\n",s->ctu_count,s->num_dblk_cmds[s->pass0_job],RPI_MAX_DEBLOCK_CMDS,s->pass0_job);
+          
+          if ( s->ctu_count >= s->max_ctu_count ) {
 #ifdef RPI_WORKER
             if (s->used_for_ref) {
               // Split work load onto separate threads so we make as rapid progress as possible with this frame
@@ -3654,7 +3677,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
               rpi_execute_inter_cmds(s);
   #endif
   #ifdef LAUNCH_PASS0
-              rpi_execute_inter_qpu(s);
+              rpi_launch_vpu_qpu(s);
   #endif 
               // Pass on this job to worker thread
               worker_submit_job(s);
@@ -3662,9 +3685,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
               worker_pass0_ready(s);
               
               // Prepare the next batch of commands
-#ifdef RPI_INTER_QPU
-              rpi_inter_clear(s);
-#endif
+              rpi_begin(s);
             } else {
               // Non-ref frame so do it all on this thread
               rpi_do_all_passes(s);
@@ -3705,7 +3726,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 #endif
 
     // Finish off any half-completed rows
-    if (s->enable_rpi && s->num_dblk_cmds[s->pass0_job]) {
+    if (s->enable_rpi && s->ctu_count) {
         rpi_do_all_passes(s);
     }
 
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index bd8b316..b9095a1 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -819,8 +819,15 @@ typedef struct HEVCLocalContext {
 
 #ifdef RPI
 
+// The processing is done in chunks
+// Each chunk corresponds to 24 64x64 luma blocks (24 so it is divisible by 8 for chroma and 12 for luma)
+// This is a distance of 1536 pixels across the screen
+// Increasing RPI_NUM_CHUNKS will reduce time spent activating QPUs and cache flushing, 
+// but allocate more memory and increase the latency before data in the next frame can be processed
+#define RPI_NUM_CHUNKS 1 
+  
 // RPI_MAX_WIDTH is maximum width in pixels supported by the accelerated code
-#define RPI_MAX_WIDTH 2048
+#define RPI_MAX_WIDTH (RPI_NUM_CHUNKS*64*24)
 
 // Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane, * 2 for bi
 #define RPI_MAX_MV_CMDS   (2*16*3*(RPI_MAX_WIDTH/4))
@@ -885,6 +892,7 @@ typedef struct HEVCPredCmd {
 
 typedef struct HEVCContext {
 #ifdef RPI
+    int magic_top; // Unclear why this is necessary - avoids segmentation fault when decoding Dumb and dumber
     int dblk_cmds[RPI_MAX_JOBS][RPI_MAX_DEBLOCK_CMDS][2];
 #endif
     const AVClass *c;  // needed by private avoptions
@@ -924,6 +932,10 @@ typedef struct HEVCContext {
     int pass0_job; // Pass0 does coefficient decode
     int pass1_job; // Pass1 does pixel processing
     int pass2_job; // Pass2 does reconstruction and deblocking
+    int ctu_count; // Number of CTUs done in pass0 so far
+    int max_ctu_count; // Number of CTUs when we trigger a round of processing
+    int ctu_per_y_chan; // Number of CTUs per luma QPU 
+    int ctu_per_uv_chan; // Number of CTUs per chroma QPU 
 #ifdef RPI_INTER_QPU
     GPU_MEM_PTR_T unif_mvs_ptr[RPI_MAX_JOBS];
     uint32_t *unif_mvs[RPI_MAX_JOBS]; // Base of memory for motion vector commands
@@ -932,6 +944,7 @@ typedef struct HEVCContext {
     uint32_t *mvs_base[RPI_MAX_JOBS][8];
     // these pointers are to the next free space
     uint32_t *u_mvs[RPI_MAX_JOBS][8];
+    uint32_t *curr_u_mvs; // Current uniform stream to use for chroma
     // Function pointers
     uint32_t mc_filter_uv;
     uint32_t mc_filter_uv_b0;
@@ -942,9 +955,10 @@ typedef struct HEVCContext {
     uint32_t *y_unif_mvs[RPI_MAX_JOBS]; // Base of memory for motion vector commands
     uint32_t *y_mvs_base[RPI_MAX_JOBS][12];
     uint32_t *y_mvs[RPI_MAX_JOBS][12];
+    uint32_t *curr_y_mvs; // Current uniform stream for luma
     // Function pointers
     uint32_t mc_filter;
-    uint32_t mc_filter_b;	
+    uint32_t mc_filter_b;
 #endif
 
 #ifdef RPI_WORKER
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index ec1953b..5cb660f 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -890,7 +890,7 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
         int n_uv = n >> s->sps->vshift[1];
         int sz,base;
         if (curr_uv < 0) curr_uv = 0;
-        if (n_uv<=curr_uv) { assert(0); return; } // Should not happen
+        if (n_uv<=curr_uv) { return; }
         sz = s->frame->linesize[1] * (n_uv-curr_uv);
         base = s->frame->linesize[1] * curr_uv;
         GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[1]);
diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
index d2be290..5c2bcef 100644
--- a/libavcodec/hevcpred_template.c
+++ b/libavcodec/hevcpred_template.c
@@ -72,7 +72,7 @@ do {                                  \
             else                                                               \
                 a = PIXEL_SPLAT_X4(ptr[i + 3])
 #ifdef RPI_WORKER
-    HEVCLocalContextIntra *lc = s->enable_rpi ? &s->HEVClcIntra : (HEVCLocalContextIntra *)s->HEVClc ;
+    HEVCLocalContextIntra *lc = (s->enable_rpi) ? &s->HEVClcIntra : (HEVCLocalContextIntra *)s->HEVClc ;
 #else
     HEVCLocalContext *lc = s->HEVClc;
 #endif
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index 37381ca..ec78823 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -414,7 +414,7 @@ static void *vpu_start(void *arg) {
     //if (p[7]) {
         //GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
         //gpu_cache_flush(buf);
-    //}    
+    //}   
     
 #ifdef RPI_TIME_TOTAL_POSTED
     start_time = Microseconds();
-- 
1.9.1


From 651f0f1ec313c9752061c0550e3edb6fbb2f0f82 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 4 Jun 2015 14:56:56 +0100
Subject: [PATCH 71/77] Don't add to start of HEVCContext structure - it is
 special

---
 libavcodec/hevc.c | 2 --
 libavcodec/hevc.h | 7 +++----
 2 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index def076c..b5c26f6 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -3662,8 +3662,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
           //av_assert0(s->num_dblk_cmds[s->pass0_job]<RPI_MAX_DEBLOCK_CMDS);
           //av_assert0(s->pass0_job<RPI_MAX_JOBS);
           //av_assert0(s->pass0_job>=0);
-          //av_assert0(s->magic_top == 0xaffe);
-          //av_assert0(s->magic_bottom == 0xaffe);
           s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]][0] = x_ctb;
           s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]++][1] = y_ctb;
           s->ctu_count++;
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index b9095a1..383ab88 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -891,10 +891,6 @@ typedef struct HEVCPredCmd {
 #endif
 
 typedef struct HEVCContext {
-#ifdef RPI
-    int magic_top; // Unclear why this is necessary - avoids segmentation fault when decoding Dumb and dumber
-    int dblk_cmds[RPI_MAX_JOBS][RPI_MAX_DEBLOCK_CMDS][2];
-#endif
     const AVClass *c;  // needed by private avoptions
     AVCodecContext *avctx;
 
@@ -1096,6 +1092,9 @@ typedef struct HEVCContext {
     int sei_hflip, sei_vflip;
 
     int picture_struct;
+#ifdef RPI
+    int dblk_cmds[RPI_MAX_JOBS][RPI_MAX_DEBLOCK_CMDS][2];
+#endif
 } HEVCContext;
 
 int ff_hevc_decode_short_term_rps(HEVCContext *s, ShortTermRPS *rps,
-- 
1.9.1


From 509a23c9c623cfe8159f664a090adea0828245b3 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 4 Jun 2015 15:48:10 +0100
Subject: [PATCH 72/77] Move deblocker into second pass

---
 libavcodec/hevc.c | 81 ++++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 66 insertions(+), 15 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index b5c26f6..761eb45 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -65,6 +65,8 @@
   static void rpi_execute_pred_cmds(HEVCContext *s);
   static void rpi_execute_inter_cmds(HEVCContext *s);
   static void rpi_begin(HEVCContext *s);
+  static void flush_frame(HEVCContext *s,AVFrame *frame);
+  static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
   
   // Define INTER_PASS0 to do inter prediction in first pass
   //#define INTER_PASS0
@@ -225,6 +227,11 @@ static void *worker_start(void *arg)
     // Wait for transform completion
     vpu_wait(s->vpu_id);
     
+    // Perform intra prediction and residual reconstruction
+    rpi_execute_pred_cmds(s);
+    // Perform deblocking for CTBs in this row
+    rpi_execute_dblk_cmds(s);
+
     worker_complete_middle_job(s);
     LOG_EXIT
   }
@@ -246,11 +253,7 @@ static void *worker_deblock_start(void *arg)
       break;
     }
     LOG_ENTER
-    // Perform intra prediction and residual reconstruction
-    rpi_execute_pred_cmds(s);
-    // Perform deblocking for CTBs in this row
-    rpi_execute_dblk_cmds(s);
-    
+
     worker_complete_job(s);
     LOG_EXIT
   }
@@ -2947,7 +2950,7 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
 static void rpi_execute_dblk_cmds(HEVCContext *s)
 {
     int n;
-    int job = s->pass2_job;
+    int job = s->pass1_job;
     int ctb_size    = 1 << s->sps->log2_ctb_size;
     int (*p)[2] = s->dblk_cmds[job];
     for(n = s->num_dblk_cmds[job]; n>0 ;n--,p++) {
@@ -2985,7 +2988,7 @@ static void rpi_execute_transform(HEVCContext *s)
 static void rpi_execute_pred_cmds(HEVCContext *s)
 {
   int i;
-  int job = s->pass2_job;
+  int job = s->pass1_job;
   HEVCPredCmd *cmd = s->univ_pred_cmds[job];
 #ifdef RPI_WORKER
   HEVCLocalContextIntra *lc = &s->HEVClcIntra;
@@ -3470,11 +3473,10 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
 
 #ifdef RPI_MULTI_MAILBOX
 #ifdef RPI_CACHE_UNIF_MVS
-    gpu_cache_flush3(&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job]);
+    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job]);
 #else
-    gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
+    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],NULL,NULL);
 #endif
-
     s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
                                    qpu_get_fn(QPU_MC_SETUP_UV),
                                    (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
@@ -3577,6 +3579,60 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
 #endif
 }
  
+static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2)
+{ 
+#ifdef RPI_FAST_CACHEFLUSH
+    struct vcsm_user_clean_invalid_s iocache = {};
+    int n = s->sps->height;
+    int curr_y = 0;
+    int curr_uv = 0;
+    int n_uv = n >> s->sps->vshift[1];
+    int sz,base;
+    sz = s->frame->linesize[1] * (n_uv-curr_uv);
+    base = s->frame->linesize[1] * curr_uv;
+    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
+    iocache.s[0].handle = p->vcsm_handle;
+    iocache.s[0].cmd = 3; // clean+invalidate
+    iocache.s[0].addr = p->arm + base;
+    iocache.s[0].size  = sz;
+    p = av_buffer_pool_opaque(frame->buf[2]);
+    iocache.s[1].handle = p->vcsm_handle;
+    iocache.s[1].cmd = 3; // clean+invalidate
+    iocache.s[1].addr = p->arm + base;
+    iocache.s[1].size  = sz;
+    p = av_buffer_pool_opaque(frame->buf[0]);
+    sz = s->frame->linesize[0] * (n-curr_y);
+    base = s->frame->linesize[0] * curr_y;
+    iocache.s[2].handle = p->vcsm_handle;
+    iocache.s[2].cmd = 3; // clean+invalidate
+    iocache.s[2].addr = p->arm + base;
+    iocache.s[2].size  = sz;
+
+    iocache.s[3].handle = p0->vcsm_handle;
+    iocache.s[3].cmd = 3; // clean+invalidate
+    iocache.s[3].addr = (int) p0->arm;
+    iocache.s[3].size  = p0->numbytes;
+    if (p1) {
+      iocache.s[4].handle = p1->vcsm_handle;
+      iocache.s[4].cmd = 3; // clean+invalidate
+      iocache.s[4].addr = (int) p1->arm;
+      iocache.s[4].size  = p1->numbytes;
+    }
+    if (p2) {
+      iocache.s[5].handle = p2->vcsm_handle;
+      iocache.s[5].cmd = 3; // clean+invalidate
+      iocache.s[5].addr = (int) p2->arm;
+      iocache.s[5].size  = p2->numbytes;
+    }
+    vcsm_clean_invalid( &iocache );
+#else            
+    flush_buffer(frame->buf[0]);
+    flush_buffer(frame->buf[1]);
+    flush_buffer(frame->buf[2]);
+    gpu_cache_flush3(p0, p1, p2);
+#endif
+}
+
 #endif
 
 static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
@@ -4038,11 +4094,6 @@ static int hevc_frame_start(HEVCContext *s)
 
     if (!s->avctx->hwaccel)
         ff_thread_finish_setup(s->avctx);
-        
-#ifdef RPI_INTER_QPU
-    // Invalidate the output data buffer so it is ready for the QPUs to write into it.
-    flush_frame(s,s->frame); 
-#endif
 
     return 0;
 
-- 
1.9.1


From 41eb5d8ae62b9322ecf01d18415bf526be80b1f4 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 4 Jun 2015 16:10:23 +0100
Subject: [PATCH 73/77] Change order of ctu accesses to improve qpu performance

---
 libavcodec/hevc.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 761eb45..9f8c142 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -3697,19 +3697,19 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
         
 #ifdef RPI_INTER_QPU
-        s->curr_u_mvs = s->u_mvs[s->pass0_job][s->ctu_count / s->ctu_per_uv_chan];
+        s->curr_u_mvs = s->u_mvs[s->pass0_job][s->ctu_count % 8];
 #endif
 #ifdef RPI_LUMA_QPU
-        s->curr_y_mvs = s->y_mvs[s->pass0_job][s->ctu_count / s->ctu_per_y_chan];
+        s->curr_y_mvs = s->y_mvs[s->pass0_job][s->ctu_count % 12];
 #endif
         
         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);
         
 #ifdef RPI_INTER_QPU
-        s->u_mvs[s->pass0_job][s->ctu_count / s->ctu_per_uv_chan] = s->curr_u_mvs;
+        s->u_mvs[s->pass0_job][s->ctu_count % 8]= s->curr_u_mvs;
 #endif
 #ifdef RPI_LUMA_QPU
-        s->y_mvs[s->pass0_job][s->ctu_count / s->ctu_per_y_chan] = s->curr_y_mvs;
+        s->y_mvs[s->pass0_job][s->ctu_count % 12] = s->curr_y_mvs;
 #endif
 
 #ifdef RPI
-- 
1.9.1


From 997f3d1e4adf75ec8426848d6ba2069093c395f6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 4 Jun 2015 17:36:35 +0100
Subject: [PATCH 74/77] Remove unneeded use_for_ref assignment

---
 libavcodec/hevc.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 9f8c142..1b5341d 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -3822,11 +3822,6 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
 
 #ifdef RPI
     s->enable_rpi = 0;
-    s->used_for_ref = !(s->nal_unit_type == NAL_TRAIL_N ||
-                        s->nal_unit_type == NAL_TSA_N   ||
-                        s->nal_unit_type == NAL_STSA_N  ||
-                        s->nal_unit_type == NAL_RADL_N  ||
-                        s->nal_unit_type == NAL_RASL_N); 
     //printf("Wavefront\n");
 #endif
 
-- 
1.9.1


From fd82b4034dd8692da132bc270e581b55574c67c1 Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Mon, 8 Jun 2015 09:36:59 +0100
Subject: [PATCH 75/77] Removed deblocker thread

---
 libavcodec/hevc.c | 87 ++++++-------------------------------------------------
 libavcodec/hevc.h |  4 ---
 2 files changed, 9 insertions(+), 82 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 1b5341d..deef3dd 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -68,11 +68,6 @@
   static void flush_frame(HEVCContext *s,AVFrame *frame);
   static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
   
-  // Define INTER_PASS0 to do inter prediction in first pass
-  //#define INTER_PASS0
-  // Define LAUNCH_PASS0 to launch QPU/VPU from pass0
-  //#define LAUNCH_PASS0
-  
 #endif
 
 // #define DISABLE_MC
@@ -145,24 +140,12 @@ static void worker_submit_job(HEVCContext *s)
 }
 
 // Call this to say we have completed pass1
-static void worker_complete_middle_job(HEVCContext *s)
-{
-  LOG_ENTER
-  pthread_mutex_lock(&s->worker_mutex);
-  s->worker_middle++;
-  s->pass1_job = (s->pass1_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
-  pthread_cond_broadcast(&s->worker_cond_middle); // Let people know that the middle has moved
-  pthread_mutex_unlock(&s->worker_mutex);
-  LOG_EXIT
-}
-
-// Call this to say we have completed pass2
 static void worker_complete_job(HEVCContext *s)
 {
   LOG_ENTER
   pthread_mutex_lock(&s->worker_mutex);
   s->worker_head++;
-  s->pass2_job = (s->pass2_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+  s->pass1_job = (s->pass1_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
   pthread_cond_broadcast(&s->worker_cond_head); // Let people know that the head has moved
   pthread_mutex_unlock(&s->worker_mutex);
   LOG_EXIT
@@ -206,7 +189,7 @@ static void *worker_start(void *arg)
   while(1) {
     pthread_mutex_lock(&s->worker_mutex);
 
-    while( !s->kill_worker && s->worker_tail - s->worker_middle <= 0)
+    while( !s->kill_worker && s->worker_tail - s->worker_head <= 0)
     {
       pthread_cond_wait(&s->worker_cond_tail, &s->worker_mutex);
     }
@@ -216,14 +199,10 @@ static void *worker_start(void *arg)
       break;
     }
     LOG_ENTER
-    // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
-#ifndef LAUNCH_PASS0   
+    // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);   
     rpi_launch_vpu_qpu(s);
-#endif
-#ifndef INTER_PASS0
     // Perform inter prediction
     rpi_execute_inter_cmds(s);
-#endif
     // Wait for transform completion
     vpu_wait(s->vpu_id);
     
@@ -232,28 +211,6 @@ static void *worker_start(void *arg)
     // Perform deblocking for CTBs in this row
     rpi_execute_dblk_cmds(s);
 
-    worker_complete_middle_job(s);
-    LOG_EXIT
-  }
-  return NULL;
-}
-
-static void *worker_deblock_start(void *arg)
-{
-  HEVCContext *s = (HEVCContext *)arg;
-  while(1) {
-    pthread_mutex_lock(&s->worker_mutex);
-    while( !s->kill_worker && s->worker_middle - s->worker_head <= 0)
-    {
-      pthread_cond_wait(&s->worker_cond_middle, &s->worker_mutex);
-    }
-    pthread_mutex_unlock(&s->worker_mutex);
-    
-    if (s->kill_worker) {
-      break;
-    }
-    LOG_ENTER
-
     worker_complete_job(s);
     LOG_EXIT
   }
@@ -2961,12 +2918,8 @@ static void rpi_execute_dblk_cmds(HEVCContext *s)
             
 static void rpi_execute_transform(HEVCContext *s)
 {
-    int i=2;
-#ifdef LAUNCH_PASS0
-    int job = s->pass0_job;
-#else    
-    int job = s->pass1_job;
-#endif    
+    int i=2;   
+    int job = s->pass1_job;   
     //int j;
     //int16_t *coeffs = s->coeffs_buf_arm[i];
     //for(j=s->num_coeffs[i]; j > 0; j-= 16*16, coeffs+=16*16) {
@@ -3021,11 +2974,7 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
 
 static void rpi_execute_inter_cmds(HEVCContext *s)
 {
-#ifdef INTER_PASS0
-    int job = s->pass0_job;
-#else
-    int job = s->pass1_job;
-#endif    
+    int job = s->pass1_job;   
     HEVCMvCmd *cmd = s->unif_mv_cmds[job];
     int n,cidx;
     AVFrame myref;
@@ -3430,12 +3379,8 @@ static void rpi_simulate_inter_qpu(HEVCContext *s)
 
 static void rpi_launch_vpu_qpu(HEVCContext *s)
 {
-    int k;
-#ifdef LAUNCH_PASS0
-    int job = s->pass0_job;
-#else    
+    int k;   
     int job = s->pass1_job;
-#endif		
     int i;
     uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr[job].vc;  
 #ifdef RPI_LUMA_QPU
@@ -3538,10 +3483,12 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
 
 #ifdef RPI
 
+#ifndef RPI_FAST_CACHEFLUSH
 static void flush_buffer(AVBufferRef *bref) {
     GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
     gpu_cache_flush(p);
 }
+#endif
 
 static void flush_frame(HEVCContext *s,AVFrame *frame) 
 { 
@@ -3676,7 +3623,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 #ifdef RPI_WORKER
     s->pass0_job = 0;
     s->pass1_job = 0;
-    s->pass2_job = 0;
 #endif
 #ifdef RPI
     rpi_begin(s);
@@ -3727,12 +3673,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 #ifdef RPI_WORKER
             if (s->used_for_ref) {
               // Split work load onto separate threads so we make as rapid progress as possible with this frame
-  #ifdef INTER_PASS0
-              rpi_execute_inter_cmds(s);
-  #endif
-  #ifdef LAUNCH_PASS0
-              rpi_launch_vpu_qpu(s);
-  #endif 
               // Pass on this job to worker thread
               worker_submit_job(s);
               // Make sure we have space to prepare the next job
@@ -3774,8 +3714,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
     // Wait for the worker to finish all its jobs
     if (s->enable_rpi) {
         worker_wait(s);
-        av_assert0(s->pass0_job==s->pass1_job);
-        av_assert0(s->pass1_job==s->pass2_job);
     }
 #endif
 
@@ -4676,16 +4614,13 @@ static av_cold void hevc_init_worker(HEVCContext *s)
 {
     int err;
     pthread_cond_init(&s->worker_cond_head, NULL);
-    pthread_cond_init(&s->worker_cond_middle, NULL);
     pthread_cond_init(&s->worker_cond_tail, NULL);
     pthread_mutex_init(&s->worker_mutex, NULL);
 
     s->worker_tail=0;
-    s->worker_middle=0;
     s->worker_head=0;
     s->kill_worker=0;
     err = pthread_create(&s->worker_thread, NULL, worker_start, s);
-    err = pthread_create(&s->worker_deblock_thread, NULL, worker_deblock_start, s);
     if (err) {
         printf("Failed to create worker thread\n");
         exit(-1);
@@ -4697,17 +4632,13 @@ static av_cold void hevc_exit_worker(HEVCContext *s)
     void *res;
     s->kill_worker=1;
     pthread_cond_broadcast(&s->worker_cond_tail);
-    pthread_cond_broadcast(&s->worker_cond_middle);
     pthread_join(s->worker_thread, &res); 
-    pthread_join(s->worker_deblock_thread, &res); 
     
     pthread_cond_destroy(&s->worker_cond_head);
-    pthread_cond_destroy(&s->worker_cond_middle);
     pthread_cond_destroy(&s->worker_cond_tail);
     pthread_mutex_destroy(&s->worker_mutex);
 
     s->worker_tail=0;
-    s->worker_middle=0;
     s->worker_head=0;
     s->kill_worker=0;
 }
diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
index 383ab88..223a5d7 100644
--- a/libavcodec/hevc.h
+++ b/libavcodec/hevc.h
@@ -927,7 +927,6 @@ typedef struct HEVCContext {
     //GPU_MEM_PTR_T dummy;
     int pass0_job; // Pass0 does coefficient decode
     int pass1_job; // Pass1 does pixel processing
-    int pass2_job; // Pass2 does reconstruction and deblocking
     int ctu_count; // Number of CTUs done in pass0 so far
     int max_ctu_count; // Number of CTUs when we trigger a round of processing
     int ctu_per_y_chan; // Number of CTUs per luma QPU 
@@ -959,15 +958,12 @@ typedef struct HEVCContext {
 
 #ifdef RPI_WORKER
     pthread_t worker_thread;
-    pthread_t worker_deblock_thread;
     pthread_cond_t worker_cond_head;
     pthread_cond_t worker_cond_tail;
-    pthread_cond_t worker_cond_middle;
     pthread_mutex_t worker_mutex;
 
     int worker_tail; // Contains the number of posted jobs
     int worker_head; // Contains the number of completed jobs
-    int worker_middle; // Contains the number of completed jobs
     int kill_worker; // set to 1 to terminate the worker
 #endif
     
-- 
1.9.1


From 1af7ec59d398fc729e22238159ede00866c79aee Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Mon, 8 Jun 2015 11:04:43 +0100
Subject: [PATCH 76/77] Reduced amount of output frame that is invalidated

---
 libavcodec/hevc.c | 45 +++++++++++++++++++++++++++++----------------
 1 file changed, 29 insertions(+), 16 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index deef3dd..8d26b7e 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -66,7 +66,7 @@
   static void rpi_execute_inter_cmds(HEVCContext *s);
   static void rpi_begin(HEVCContext *s);
   static void flush_frame(HEVCContext *s,AVFrame *frame);
-  static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
+  static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2, int job);
   
 #endif
 
@@ -3418,9 +3418,9 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
 
 #ifdef RPI_MULTI_MAILBOX
 #ifdef RPI_CACHE_UNIF_MVS
-    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job]);
+    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job], job);
 #else
-    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],NULL,NULL);
+    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],NULL,NULL, job);
 #endif
     s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
                                    qpu_get_fn(QPU_MC_SETUP_UV),
@@ -3494,6 +3494,7 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
 { 
 #ifdef RPI_FAST_CACHEFLUSH
     struct vcsm_user_clean_invalid_s iocache = {};
+    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
     int n = s->sps->height;
     int curr_y = 0;
     int curr_uv = 0;
@@ -3501,22 +3502,21 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
     int sz,base;
     sz = s->frame->linesize[1] * (n_uv-curr_uv);
     base = s->frame->linesize[1] * curr_uv;
-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
     iocache.s[0].handle = p->vcsm_handle;
     iocache.s[0].cmd = 3; // clean+invalidate
-    iocache.s[0].addr = p->arm + base;
+    iocache.s[0].addr = (int)(p->arm) + base;
     iocache.s[0].size  = sz;
     p = av_buffer_pool_opaque(frame->buf[2]);
     iocache.s[1].handle = p->vcsm_handle;
     iocache.s[1].cmd = 3; // clean+invalidate
-    iocache.s[1].addr = p->arm + base;
+    iocache.s[1].addr = (int)(p->arm) + base;
     iocache.s[1].size  = sz;
     p = av_buffer_pool_opaque(frame->buf[0]);
     sz = s->frame->linesize[0] * (n-curr_y);
     base = s->frame->linesize[0] * curr_y;
     iocache.s[2].handle = p->vcsm_handle;
     iocache.s[2].cmd = 3; // clean+invalidate
-    iocache.s[2].addr = p->arm + base;
+    iocache.s[2].addr = (int)(p->arm) + base;
     iocache.s[2].size  = sz;
     vcsm_clean_invalid( &iocache );
 #else            
@@ -3526,33 +3526,46 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
 #endif
 }
  
-static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2)
+static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2, int job)
 { 
 #ifdef RPI_FAST_CACHEFLUSH
     struct vcsm_user_clean_invalid_s iocache = {};
-    int n = s->sps->height;
-    int curr_y = 0;
-    int curr_uv = 0;
-    int n_uv = n >> s->sps->vshift[1];
+    int n;
+    int curr_y;
+    int curr_uv;
+    int n_uv;
+    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
     int sz,base;
+    int (*d)[2] = s->dblk_cmds[job];
+    int low=(*d)[1];
+    int high=(*d)[1];
+    for(n = s->num_dblk_cmds[job]; n>0 ;n--,d++) {
+        int y = (*d)[1];
+        low=FFMIN(low,y);
+        high=FFMAX(high,y);
+    }
+    curr_y = low;
+    n = high+(1 << s->sps->log2_ctb_size);
+    curr_uv = curr_y >> s->sps->vshift[1];
+    n_uv = n >> s->sps->vshift[1];
+   
     sz = s->frame->linesize[1] * (n_uv-curr_uv);
     base = s->frame->linesize[1] * curr_uv;
-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
     iocache.s[0].handle = p->vcsm_handle;
     iocache.s[0].cmd = 3; // clean+invalidate
-    iocache.s[0].addr = p->arm + base;
+    iocache.s[0].addr = (int)(p->arm) + base;
     iocache.s[0].size  = sz;
     p = av_buffer_pool_opaque(frame->buf[2]);
     iocache.s[1].handle = p->vcsm_handle;
     iocache.s[1].cmd = 3; // clean+invalidate
-    iocache.s[1].addr = p->arm + base;
+    iocache.s[1].addr = (int)(p->arm) + base;
     iocache.s[1].size  = sz;
     p = av_buffer_pool_opaque(frame->buf[0]);
     sz = s->frame->linesize[0] * (n-curr_y);
     base = s->frame->linesize[0] * curr_y;
     iocache.s[2].handle = p->vcsm_handle;
     iocache.s[2].cmd = 3; // clean+invalidate
-    iocache.s[2].addr = p->arm + base;
+    iocache.s[2].addr = (int)(p->arm) + base;
     iocache.s[2].size  = sz;
 
     iocache.s[3].handle = p0->vcsm_handle;
-- 
1.9.1


From a06b492db4411a6ea2f30c94cfd1328e385cc32e Mon Sep 17 00:00:00 2001
From: Peter de Rivaz <peter.derivaz@gmail.com>
Date: Mon, 8 Jun 2015 11:55:29 +0100
Subject: [PATCH 77/77] Packed 16x16 and 32x32 into the same buffer

---
 libavcodec/hevc.c       | 24 +++++++++++++++---------
 libavcodec/hevc_cabac.c |  9 ++++++++-
 libavcodec/rpi_qpu.c    |  2 +-
 3 files changed, 24 insertions(+), 11 deletions(-)

diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
index 8d26b7e..107ed2a 100644
--- a/libavcodec/hevc.c
+++ b/libavcodec/hevc.c
@@ -297,12 +297,12 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
         s->coeffs_buf_arm[job][0] = (int16_t*) s->coeffs_buf_default[job].arm;
         if (!s->coeffs_buf_arm[job][0])
             goto fail;
-        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated[job]);
+        gpu_malloc_cached(sizeof(int16_t) * (coefs_per_row + 32*32), &s->coeffs_buf_accelerated[job]);  // We prefetch past the end so provide an extra blocks worth of data
         s->coeffs_buf_arm[job][2] = (int16_t*) s->coeffs_buf_accelerated[job].arm;
         s->coeffs_buf_vc[job][2] = s->coeffs_buf_accelerated[job].vc;
         if (!s->coeffs_buf_arm[job][2])
             goto fail;    
-        s->coeffs_buf_arm[job][3] = coefs_per_row + s->coeffs_buf_arm[job][2];
+        s->coeffs_buf_arm[job][3] = coefs_per_row + s->coeffs_buf_arm[job][2];  // This points to just beyond the end of the buffer.  Coefficients fill in backwards.
         s->coeffs_buf_vc[job][3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[job][2];
       }
     }
@@ -2920,15 +2920,20 @@ static void rpi_execute_transform(HEVCContext *s)
 {
     int i=2;   
     int job = s->pass1_job;   
-    //int j;
-    //int16_t *coeffs = s->coeffs_buf_arm[i];
-    //for(j=s->num_coeffs[i]; j > 0; j-= 16*16, coeffs+=16*16) {
-    //    s->hevcdsp.idct[4-2](coeffs, 16);
-    //}
+    /*int j;
+    int16_t *coeffs = s->coeffs_buf_arm[job][i];
+    for(j=s->num_coeffs[job][i]; j > 0; j-= 16*16, coeffs+=16*16) {
+        s->hevcdsp.idct[4-2](coeffs, 16);
+    }
+    i=3;
+    coeffs = s->coeffs_buf_arm[job][i] - s->num_coeffs[job][i];
+    for(j=s->num_coeffs[job][i]; j > 0; j-= 32*32, coeffs+=32*32) {
+        s->hevcdsp.idct[5-2](coeffs, 32);
+    }*/
     
     gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
     s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], 
-                               s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], 
+                               s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3] - sizeof(int16_t) * s->num_coeffs[job][3], 
                                s->num_coeffs[job][3] >> 10, 0, &s->coeffs_buf_accelerated[job]);
     //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
     //gpu_cache_flush(&s->coeffs_buf_accelerated);
@@ -3422,7 +3427,8 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
 #else
     flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],NULL,NULL, job);
 #endif
-    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
+    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, 
+                                                                      s->coeffs_buf_vc[job][3] - sizeof(int16_t) * s->num_coeffs[job][3], s->num_coeffs[job][3] >> 10, 0,
                                    qpu_get_fn(QPU_MC_SETUP_UV),
                                    (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
                                    (uint32_t)(unif_vc+(s->mvs_base[job][1 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index 79fe95c..18e33d4 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -1099,7 +1099,14 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     if (s->enable_rpi) {
         int n = trafo_size * trafo_size;
         if (use_vpu) {
-            coeffs = s->coeffs_buf_arm[s->pass0_job][log2_trafo_size - 2] + s->num_coeffs[s->pass0_job][log2_trafo_size - 2];
+            // We support size 4 and size 5.
+            // Size 4 grows from the front  (Coeffs_buf_arm[2] points to start of buf)
+            // Size 5 grows from the back   (Coeffs_buf_arm[3] points to end of buf)
+            // num_coeffs is indexed by log2_trafo_size-2
+            if (log2_trafo_size == 4)
+                coeffs = s->coeffs_buf_arm[s->pass0_job][log2_trafo_size - 2] + s->num_coeffs[s->pass0_job][log2_trafo_size - 2];
+            else
+                coeffs = s->coeffs_buf_arm[s->pass0_job][log2_trafo_size - 2] - s->num_coeffs[s->pass0_job][log2_trafo_size - 2] - n;
             s->num_coeffs[s->pass0_job][log2_trafo_size - 2] += n;
         } else {
             coeffs = s->coeffs_buf_arm[s->pass0_job][0] + s->num_coeffs[s->pass0_job][0];
diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
index ec78823..6d86f06 100644
--- a/libavcodec/rpi_qpu.c
+++ b/libavcodec/rpi_qpu.c
@@ -4,7 +4,7 @@
 // define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
 //#define RPI_TIME_TOTAL_VPU
 // define RPI_TIME_TOTAL_POSTED to print out how much time is spent in the multi execute QPU/VPU combined
-//#define RPI_TIME_TOTAL_POSTED
+#define RPI_TIME_TOTAL_POSTED
 // define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
 #define RPI_ASYNC
 
-- 
1.9.1

